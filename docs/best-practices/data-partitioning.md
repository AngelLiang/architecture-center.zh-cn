---
title: 数据分区指南
titleSuffix: Best practices for cloud applications
description: 有关如何隔离分区，以便单独进行管理和访问的指导。
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 561fe6e47a4cd64aa545349dde4c76260d76e78e
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248952"
---
# <a name="horizontal-vertical-and-functional-data-partitioning"></a><span data-ttu-id="fb9a7-103">水平数据分区、垂直数据分区和功能数据分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-103">Horizontal, vertical, and functional data partitioning</span></span>

<span data-ttu-id="fb9a7-104">在许多大型解决方案中，数据分割成分区，而这些分区可以单独进行管理和访问。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-104">In many large-scale solutions, data is divided into *partitions* that can be managed and accessed separately.</span></span> <span data-ttu-id="fb9a7-105">分区可以改善可伸缩性、减少争用，以及优化性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-105">Partitioning can improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="fb9a7-106">另外，它还能提供一种按使用模式来分割数据的机制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-106">It can also provide a mechanism for dividing data by usage pattern.</span></span> <span data-ttu-id="fb9a7-107">例如，可以将较旧的数据存档在成本较低的数据存储中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-107">For example, you can archive older data in cheaper data storage.</span></span>

<span data-ttu-id="fb9a7-108">但是，必须慎重选择分区策略，才能最大程度地提高效益，将负面影响降到最低。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-108">However, the partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span>

> [!NOTE]
> <span data-ttu-id="fb9a7-109">在本文中，术语“分区”是指以物理方式将数据分割成独立数据存储的过程。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-109">In this article, the term *partitioning* means the process of physically dividing data into separate data stores.</span></span> <span data-ttu-id="fb9a7-110">它与 SQL Server 表分区不同。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-110">It is not the same as SQL Server table partitioning.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-partition-data"></a><span data-ttu-id="fb9a7-111">为何要将数据分区？</span><span class="sxs-lookup"><span data-stu-id="fb9a7-111">Why partition data?</span></span>

<!-- markdownlint-enable MD026 -->

- <span data-ttu-id="fb9a7-112">**提高缩放性**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-112">**Improve scalability**.</span></span> <span data-ttu-id="fb9a7-113">纵向扩展单一数据库系统最终会达到物理硬件的限制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-113">When you scale up a single database system, it will eventually reach a physical hardware limit.</span></span> <span data-ttu-id="fb9a7-114">如果跨多个分区来分割数据，则每个分区托管在独立的服务器上，使系统几乎能够无限横向扩展。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-114">If you divide data across multiple partitions, each hosted on a separate server, you can scale out the system almost indefinitely.</span></span>

- <span data-ttu-id="fb9a7-115">**提高性能**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-115">**Improve performance**.</span></span> <span data-ttu-id="fb9a7-116">在每个分区上的数据访问操作通过较小的数据卷进行。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-116">Data access operations on each partition take place over a smaller volume of data.</span></span> <span data-ttu-id="fb9a7-117">在正确操作的情况下，分区可以提高系统的效率。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-117">Correctly done, partitioning can make your system more efficient.</span></span> <span data-ttu-id="fb9a7-118">影响多个分区的操作可以同时运行。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-118">Operations that affect more than one partition can run in parallel.</span></span>

- <span data-ttu-id="fb9a7-119">**提高安全性**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-119">**Improve security**.</span></span> <span data-ttu-id="fb9a7-120">在某些情况下，可以将机密和非机密数据隔离到不同的分区，对敏感数据应用不同的安全控制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-120">In some cases, you can separate sensitive and non-sensitive data into different partitions and apply different security controls to the sensitive data.</span></span>

- <span data-ttu-id="fb9a7-121">**提供操作灵活性**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-121">**Provide operational flexibility**.</span></span> <span data-ttu-id="fb9a7-122">使用分区可以从多方面优化操作、最大程度提高管理效率及降低成本。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-122">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</span></span> <span data-ttu-id="fb9a7-123">例如，可以根据数据在每个分区中的重要性定义不同的策略，以管理、监视、备份和还原及其他管理任务。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-123">For example, you can define different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</span></span>

- <span data-ttu-id="fb9a7-124">**将数据存储和使用模式相匹配**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-124">**Match the data store to the pattern of use**.</span></span> <span data-ttu-id="fb9a7-125">分区允许根据数据存储提供的成本和内置功能，将每个分区部署在不同类型的数据存储上。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-125">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</span></span> <span data-ttu-id="fb9a7-126">例如，大型二进制数据可存储在 Blob 存储中，而结构化程度更高的数据则可保存在文档数据库中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-126">For example, large binary data can be stored in blob storage, while more structured data can be held in a document database.</span></span> <span data-ttu-id="fb9a7-127">请参阅[选择适当的数据存储](../guide/technology-choices/data-store-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-127">See [Choose the right data store](../guide/technology-choices/data-store-overview.md).</span></span>

- <span data-ttu-id="fb9a7-128">**提高可用性**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-128">**Improve availability**.</span></span> <span data-ttu-id="fb9a7-129">跨多个服务器隔离数据可避免单点故障。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-129">Separating data across multiple servers avoids a single point of failure.</span></span> <span data-ttu-id="fb9a7-130">如果一个实例发生故障，只有该分区中的数据不可用。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-130">If one instance fails, only the data in that partition is unavailable.</span></span> <span data-ttu-id="fb9a7-131">其他分区上的操作可以继续进行。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-131">Operations on other partitions can continue.</span></span> <span data-ttu-id="fb9a7-132">对于托管型 PaaS 数据存储，则不怎么需要进行这种考虑，因为这些服务在设计时已经考虑到了内置冗余。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-132">For managed PaaS data stores, this consideration is less relevant, because these services are designed with built-in redundancy.</span></span>

## <a name="designing-partitions"></a><span data-ttu-id="fb9a7-133">设计分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-133">Designing partitions</span></span>

<span data-ttu-id="fb9a7-134">数据分区有三个典型策略：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-134">There are three typical strategies for partitioning data:</span></span>

- <span data-ttu-id="fb9a7-135">**水平分区**\（通常称为*分片*）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-135">**Horizontal partitioning** (often called *sharding*).</span></span> <span data-ttu-id="fb9a7-136">在此策略中，每个分区都是独立的数据存储，但所有分区具有相同的架构。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-136">In this strategy, each partition is a separate data store, but all partitions have the same schema.</span></span> <span data-ttu-id="fb9a7-137">每个分区称为分片，保存数据的特定子集，例如特定的一组客户的所有订单。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-137">Each partition is known as a *shard* and holds a specific subset of the data, such as all the orders for a specific set of customers.</span></span>

- <span data-ttu-id="fb9a7-138">**垂直分区**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-138">**Vertical partitioning**.</span></span> <span data-ttu-id="fb9a7-139">在此策略中，每个分区在数据存储中保存项字段的子集。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-139">In this strategy, each partition holds a subset of the fields for items in the data store.</span></span> <span data-ttu-id="fb9a7-140">这些字段已根据其使用模式进行分割。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-140">The fields are divided according to their pattern of use.</span></span> <span data-ttu-id="fb9a7-141">例如，将经常访问的字段放在一个垂直分区，将较不经常访问的字段放在另一个垂直分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-141">For example, frequently accessed fields might be placed in one vertical partition and less frequently accessed fields in another.</span></span>

- <span data-ttu-id="fb9a7-142">**功能分区**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-142">**Functional partitioning**.</span></span> <span data-ttu-id="fb9a7-143">在此策略中，数据已根据系统中每个界限上下文使用数据的方式进行聚合。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-143">In this strategy, data is aggregated according to how it is used by each bounded context in the system.</span></span> <span data-ttu-id="fb9a7-144">例如，电子商务系统可能在一个分区中存储发票数据，在另一个分区中存储产品库存数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-144">For example, an e-commerce system might store invoice data in one partition and product inventory data in another.</span></span>

<span data-ttu-id="fb9a7-145">这些策略可以组合起来使用，建议在设计分区方案时全盘考虑。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-145">These strategies can be combined, and we recommend that you consider them all when you design a partitioning scheme.</span></span> <span data-ttu-id="fb9a7-146">例如，可以将数据分割成分片，然后使用垂直分区进一步细分每个分片中的数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-146">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</span></span>

### <a name="horizontal-partitioning-sharding"></a><span data-ttu-id="fb9a7-147">水平分区（分片）</span><span class="sxs-lookup"><span data-stu-id="fb9a7-147">Horizontal partitioning (sharding)</span></span>

<span data-ttu-id="fb9a7-148">图 1 显示了水平分区或分片。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-148">Figure 1 shows horizontal partitioning or sharding.</span></span> <span data-ttu-id="fb9a7-149">在此示例中，产品库存数据已根据产品键分割成分片。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-149">In this example, product inventory data is divided into shards based on the product key.</span></span> <span data-ttu-id="fb9a7-150">每个分片保存分区键（A-G 和 H-Z）的连续范围数据，根据字母顺序排列。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-150">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</span></span> <span data-ttu-id="fb9a7-151">分片可以将负载分散到多台计算机，减少争用并改善性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-151">Sharding spreads the load over more computers, which reduces contention and improves performance.</span></span>

![基于分区键将数据水平分区（分片）](./images/data-partitioning/DataPartitioning01.png)

<span data-ttu-id="fb9a7-153">*图 1.* 基于分区键将数据水平分区（分片）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-153">*Figure 1. Horizontally partitioning (sharding) data based on a partition key.*</span></span>

<span data-ttu-id="fb9a7-154">最重要的因素是分片键的选择。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-154">The most important factor is the choice of a sharding key.</span></span> <span data-ttu-id="fb9a7-155">系统运行之后，就很难更改该键。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-155">It can be difficult to change the key after the system is in operation.</span></span> <span data-ttu-id="fb9a7-156">键必须确保在进行数据分区时，工作负荷能够尽量跨分片平均分配。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-156">The key must ensure that data is partitioned to spread the workload as evenly as possible across the shards.</span></span>

<span data-ttu-id="fb9a7-157">分片不需大小一致。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-157">The shards don't have to be the same size.</span></span> <span data-ttu-id="fb9a7-158">请求数的平衡更为重要。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-158">It's more important to balance the number of requests.</span></span> <span data-ttu-id="fb9a7-159">有些分片可能非常大，但每个项的访问操作数目少。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-159">Some shards might be very large, but each item has a low number of access operations.</span></span> <span data-ttu-id="fb9a7-160">其他分片可能较小，但是更常访问每个项。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-160">Other shards might be smaller, but each item is accessed much more frequently.</span></span> <span data-ttu-id="fb9a7-161">另一个重点是确保单个分片不超过数据存储的规模限制（在容量和资源处理方面）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-161">It's also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store.</span></span>

<span data-ttu-id="fb9a7-162">避免产生“热”分区，否则可能会影响性能与可用性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-162">Avoid creating "hot" partitions that can affect performance and availability.</span></span> <span data-ttu-id="fb9a7-163">例如，使用客户名称的第一个字母会导致分配不均衡，因为某些字母更常见。请改用客户标识符的哈希，这样可以更均衡地跨分区分配数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-163">For example, using the first letter of a customer’s name causes an unbalanced distribution, because some letters are more common Instead, use a hash of a customer identifier to distribute data more evenly across partitions.</span></span>

<span data-ttu-id="fb9a7-164">选择分片键时，应尽量避免将来还需要把大分片拆分、把小分片合并成大分区或者更改架构的情况。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-164">Choose a sharding key that minimizes any future requirements to split large shards, coalesce small shards into larger partitions, or change the schema.</span></span> <span data-ttu-id="fb9a7-165">这些操作可能非常耗时，并且可能需要在执行时使一个或多个分片脱机。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-165">These operations can be very time consuming, and might require taking one or more shards offline while they are performed.</span></span>

<span data-ttu-id="fb9a7-166">如果复制分片，则某些副本也许能够保持联机，而其他副本会被拆分、合并，或者重新配置。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-166">If shards are replicated, it might be possible to keep some of the replicas online while others are split, merged, or reconfigured.</span></span> <span data-ttu-id="fb9a7-167">但是，系统可能需要限制可以在重新配置期间执行的操作。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-167">However, the system might need to limit the operations that can be performed during the reconfiguration.</span></span> <span data-ttu-id="fb9a7-168">例如，可以将副本中的数据标记为只读，避免出现数据不一致的情况。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-168">For example, the data in the replicas might be marked as read-only to prevent data inconsistences.</span></span>

<span data-ttu-id="fb9a7-169">有关水平分区的详细信息，请参阅[分片模式]。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-169">For more information about horizontal partitioning, see [Sharding pattern].</span></span>

### <a name="vertical-partitioning"></a><span data-ttu-id="fb9a7-170">垂直分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-170">Vertical partitioning</span></span>

<span data-ttu-id="fb9a7-171">垂直分区的最常见用途是降低与提取频繁访问的项相关的 I/O 和性能成本。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-171">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching items that are frequently accessed.</span></span> <span data-ttu-id="fb9a7-172">图 2 显示了垂直分区的示例。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-172">Figure 2 shows an example of vertical partitioning.</span></span> <span data-ttu-id="fb9a7-173">在此示例中，项的不同属性存储在不同的分区中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-173">In this example, different properties of an item are stored in different partitions.</span></span> <span data-ttu-id="fb9a7-174">一个分区保存经常访问的数据，包括产品名称、说明和价格。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-174">One partition holds data that is accessed more frequently, including product name, description, and price.</span></span> <span data-ttu-id="fb9a7-175">另一个分区保存清单数据：库存计数和上次订购日期。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-175">Another partition holds inventory data: the stock count and last-ordered date.</span></span>

![按使用模式将数据垂直分区](./images/data-partitioning/DataPartitioning02.png)

<span data-ttu-id="fb9a7-177">*图 2.* 按使用模式将数据垂直分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-177">*Figure 2. Vertically partitioning data by its pattern of use.*</span></span>

<span data-ttu-id="fb9a7-178">在此示例中，应用程序在向客户显示产品详细信息时，按常规查询产品名称、描述和价格。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-178">In this example, the application regularly queries the product name, description, and price when displaying the product details to customers.</span></span> <span data-ttu-id="fb9a7-179">库存计数和上次订购日期保存在单独的分区中，因为这两项通常一起使用。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-179">Stock count and last- ordered date are held in a separate partition because these two items are commonly used together.</span></span>

<span data-ttu-id="fb9a7-180">垂直分区的其他优势：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-180">Other advantages of vertical partitioning:</span></span>

- <span data-ttu-id="fb9a7-181">不怎么变化的数据（产品名称、说明和价格）和较动态的数据（库存水平和上次订购日期）可以彼此隔离。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-181">Relatively slow-moving data (product name, description, and price) can be separated from the more dynamic data (stock level and last ordered date).</span></span> <span data-ttu-id="fb9a7-182">应用程序可以将不怎么变化的数据缓存在内存中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-182">Slow moving data is a good candidate for an application to cache in memory.</span></span>

- <span data-ttu-id="fb9a7-183">可以将敏感数据存储在单独的分区中并施加额外的安全控制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-183">Sensitive data can be stored in a separate partition with additional security controls.</span></span>

- <span data-ttu-id="fb9a7-184">垂直分区可以减少必需的并发访问数量。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-184">Vertical partitioning can reduce the amount of concurrent access that's needed.</span></span>

<span data-ttu-id="fb9a7-185">垂直分区在数据存储中的实体级运行，会部分规范化某个实体，以将它从*宽*项分割成一组*窄*项。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-185">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a *wide* item to a set of *narrow* items.</span></span> <span data-ttu-id="fb9a7-186">在理想的情况下，垂直分区适用于 HBase 和 Cassandra 等列导向型数据存储。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-186">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</span></span> <span data-ttu-id="fb9a7-187">如果列集合中的数据不太可能会更改，还可以考虑使用 SQL Server 中的列存储。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-187">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</span></span>

### <a name="functional-partitioning"></a><span data-ttu-id="fb9a7-188">功能分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-188">Functional partitioning</span></span>

<span data-ttu-id="fb9a7-189">如果可以在应用程序中确定每个不同商业领域的受限上下文，则可通过功能分区来改善隔离效果和数据访问性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-189">When it's possible to identify a bounded context for each distinct business area in an application, functional partitioning is a way to improve isolation and data access performance.</span></span> <span data-ttu-id="fb9a7-190">功能分区的另一种常见用途是将读写数据与只读数据隔离。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-190">Another common use for functional partitioning is to separate read-write data from read-only data.</span></span> <span data-ttu-id="fb9a7-191">图 3 显示了功能分区的概览，其中的库存数据已与客户数据相隔离。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-191">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</span></span>

![按界限上下文或子域对数据进行功能分区](./images/data-partitioning/DataPartitioning03.png)

<span data-ttu-id="fb9a7-193">*图 3.* 按界限上下文或子域对数据进行功能分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-193">*Figure 3. Functionally partitioning data by bounded context or subdomain.*</span></span>

<span data-ttu-id="fb9a7-194">此分区策略可帮助减少跨系统中不同部件的数据访问争用。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-194">This partitioning strategy can help reduce data access contention across different parts of a system.</span></span>

## <a name="designing-partitions-for-scalability"></a><span data-ttu-id="fb9a7-195">针对缩放性设计分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-195">Designing partitions for scalability</span></span>

<span data-ttu-id="fb9a7-196">请务必考虑每个分区的大小和工作负荷并进行平衡，使数据分布实现最大伸缩性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-196">It's vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</span></span> <span data-ttu-id="fb9a7-197">但是，还必须将数据分区，使它不超过单个分区存储的缩放限制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-197">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</span></span>

<span data-ttu-id="fb9a7-198">在针对缩放性设计分区时，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-198">Follow these steps when designing partitions for scalability:</span></span>

1. <span data-ttu-id="fb9a7-199">分析应用程序以了解数据访问模式，例如每个查询返回的结果集大小、访问的频率、固有的延迟，以及服务器端计算处理要求。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-199">Analyze the application to understand the data access patterns, such as the size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</span></span> <span data-ttu-id="fb9a7-200">在许多情况下，一些主要实体需要大部分的处理资源。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-200">In many cases, a few major entities will demand most of the processing resources.</span></span>
2. <span data-ttu-id="fb9a7-201">使用这种分析来确定当前和将来的缩放性目标，例如数据大小和工作负荷。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-201">Use this analysis to determine the current and future scalability targets, such as data size and workload.</span></span> <span data-ttu-id="fb9a7-202">然后将数据跨分区分布以符合缩放性目标。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-202">Then distribute the data across the partitions to meet the scalability target.</span></span> <span data-ttu-id="fb9a7-203">对于水平分区，选择适当的分片键很重要，可以确保数据的均衡分配。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-203">For horizontal partitioning, choosing the right shard key is important to make sure distribution is even.</span></span> <span data-ttu-id="fb9a7-204">有关详细信息，请参阅[分片模式]。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-204">For more information, see the [Sharding pattern].</span></span>
3. <span data-ttu-id="fb9a7-205">确保每个分区有足够的资源，能够在数据大小和吞吐量方面应对可伸缩性要求。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-205">Make sure each partition has enough resources to handle the scalability requirements, in terms of data size and throughput.</span></span> <span data-ttu-id="fb9a7-206">每个分区的存储空间量、处理能力或网络带宽可能存在限制，具体取决于数据存储的情况。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-206">Depending on the data store, there might be a limit on the amount of storage space, processing power, or network bandwidth per partition.</span></span> <span data-ttu-id="fb9a7-207">如果可伸缩性要求会超出这些限制，则可能需要优化分区策略或进一步拆分数据，也许需要将至少两个策略组合在一起。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-207">If the requirements are likely to exceed these limits, you may need to refine your partitioning strategy or split data out further, possibly combining two or more strategies.</span></span>
4. <span data-ttu-id="fb9a7-208">对系统进行监视，以验证数据是否按预期分配，以及分区是否可以处理负载。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-208">Monitor the system to verify that data is distributed as expected and that the partitions can handle the load.</span></span> <span data-ttu-id="fb9a7-209">实际使用情况并非始终符合分析的预期。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-209">Actual usage does not always match what an analysis predicts.</span></span> <span data-ttu-id="fb9a7-210">如果出现这种情况，可以对分区进行再平衡，或者重新设计系统的某些部分，以实现所需的平衡。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-210">If so, it might be possible to rebalance the partitions, or else redesign some parts of the system to gain the required balance.</span></span>

<span data-ttu-id="fb9a7-211">某些云环境会根据基础结构边界分配资源。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-211">Some cloud environments allocate resources in terms of infrastructure boundaries.</span></span> <span data-ttu-id="fb9a7-212">请确保所选边界的限制可在数据存储、处理能力和带宽等方面提供足够的空间，以满足数据量的预期增长。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-212">Ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</span></span>

<span data-ttu-id="fb9a7-213">例如，如果使用 Azure 表存储，则单一分区在特定时限内能够处理的请求数会存在限制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-213">For example, if you use Azure table storage, there is a limit to the volume of requests that can be handled by a single partition in a particular period of time.</span></span> <span data-ttu-id="fb9a7-214">（请参阅 [Azure 存储可伸缩性和性能目标]。）繁忙的分片所需的资源可能会超出单个分区的处理能力。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-214">(See [Azure storage scalability and performance targets].) A busy shard might require more resources than a single partition can handle.</span></span> <span data-ttu-id="fb9a7-215">如果属于这种情况，可能需要对分片进行重新分区以分散负载。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-215">If so, the shard might need to be repartitioned to spread the load.</span></span> <span data-ttu-id="fb9a7-216">如果这些表的总大小或吞吐量超过存储帐户的容量，可能需要创建其他存储帐户并跨帐户分散表。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-216">If the total size or throughput of these tables exceeds the capacity of a storage account, you might need to create additional storage accounts and spread the tables across these accounts.</span></span>

## <a name="designing-partitions-for-query-performance"></a><span data-ttu-id="fb9a7-217">针对查询性能设计分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-217">Designing partitions for query performance</span></span>

<span data-ttu-id="fb9a7-218">使用较小的数据集和运行并行查询通常可以提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-218">Query performance can often be boosted by using smaller data sets and by running parallel queries.</span></span> <span data-ttu-id="fb9a7-219">每个分区应该包含整个数据集的一小部分。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-219">Each partition should contain a small proportion of the entire data set.</span></span> <span data-ttu-id="fb9a7-220">这种数量缩减可以提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-220">This reduction in volume can improve the performance of queries.</span></span> <span data-ttu-id="fb9a7-221">但是，分区并不是合理设计和配置数据库的替代方式。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-221">However, partitioning is not an alternative for designing and configuring a database appropriately.</span></span> <span data-ttu-id="fb9a7-222">例如，请确保编制必要的索引。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-222">For example, make sure that you have the necessary indexes in place.</span></span>

<span data-ttu-id="fb9a7-223">在针对查询性能设计分区时，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-223">Follow these steps when designing partitions for query performance:</span></span>

1. <span data-ttu-id="fb9a7-224">检查应用程序的要求和性能：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-224">Examine the application requirements and performance:</span></span>

   - <span data-ttu-id="fb9a7-225">根据业务要求来确定必须始终快速执行的重要查询。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-225">Use business requirements to determine the critical queries that must always perform quickly.</span></span>
   - <span data-ttu-id="fb9a7-226">监视系统以识别任何执行速度缓慢的查询。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-226">Monitor the system to identify any queries that perform slowly.</span></span>
   - <span data-ttu-id="fb9a7-227">找出最常执行的查询。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-227">Find which queries are performed most frequently.</span></span> <span data-ttu-id="fb9a7-228">即使单个查询的开销极少，也会出现资源累积消耗很大的情况。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-228">Even if a single query has a minimal cost, the cumulative resource consumption could be significant.</span></span>

2. <span data-ttu-id="fb9a7-229">将导致性能变慢的数据分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-229">Partition the data that is causing slow performance:</span></span>
   - <span data-ttu-id="fb9a7-230">限制每个分区的大小，使查询响应时间在目标范围内。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-230">Limit the size of each partition so that the query response time is within target.</span></span>
   - <span data-ttu-id="fb9a7-231">如果使用水平分区，请在设计分片键时，确保应用程序能够轻松地选择适当的分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-231">If you use horizontal partitioning, design the shard key so that the application can easily select the right partition.</span></span> <span data-ttu-id="fb9a7-232">这可防止查询需要扫描每个分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-232">This prevents the query from having to scan through every partition.</span></span>
   - <span data-ttu-id="fb9a7-233">考虑分区的位置。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-233">Consider the location of a partition.</span></span> <span data-ttu-id="fb9a7-234">如果可能，请尽量将数据保留在地理位置靠近访问数据的应用程序和用户的分区中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-234">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</span></span>

3. <span data-ttu-id="fb9a7-235">如果实体有吞吐量和查询性能的要求，请根据该实体使用功能分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-235">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</span></span> <span data-ttu-id="fb9a7-236">如果这样还是无法满足要求，请同时应用水平分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-236">If this still doesn't satisfy the requirements, apply horizontal partitioning as well.</span></span> <span data-ttu-id="fb9a7-237">在大多数情况下，单个分区策略就已足够，但在某些情况下，结合两种策略会更有效率。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-237">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</span></span>

4. <span data-ttu-id="fb9a7-238">考虑跨分区并行运行查询以改善性能。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-238">Consider running queries in parallel across partitions to improve performance.</span></span>

## <a name="designing-partitions-for-availability"></a><span data-ttu-id="fb9a7-239">针对可用性设计分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-239">Designing partitions for availability</span></span>

<span data-ttu-id="fb9a7-240">将数据分区可以确保整个数据集不会构成单一故障点，并可确保数据集的单个子集可以独立进行管理，从而提高应用程序的可用性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-240">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</span></span>

<span data-ttu-id="fb9a7-241">请注意以下会影响可用性的因素：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-241">Consider the following factors that affect availability:</span></span>

<span data-ttu-id="fb9a7-242">**数据对业务运营的重要程度**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-242">**How critical the data is to business operations**.</span></span> <span data-ttu-id="fb9a7-243">确定属于重要业务信息的数据（例如交易），以及较不重要的操作数据（例如日志文件）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-243">Identify which data is critical business information, such as transactions, and which data is less critical operational data, such as log files.</span></span>

- <span data-ttu-id="fb9a7-244">考虑将重要数据存储在高度可用且有适当备份计划的分区中。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-244">Consider storing critical data in highly-available partitions with an appropriate backup plan.</span></span>

- <span data-ttu-id="fb9a7-245">为不同的数据集建立独立的管理和监视过程。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-245">Establish separate management and monitoring procedures for the different datasets.</span></span>

- <span data-ttu-id="fb9a7-246">将具有相同级别重要性的数据放在相同的分区中，以便可以按照相应的频率一同备份。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-246">Place data that has the same level of criticality in the same partition so that it can be backed up together at an appropriate frequency.</span></span> <span data-ttu-id="fb9a7-247">例如，保存交易数据的分区需要备份的频率可能高于保存日志记录或跟踪信息的分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-247">For example, partitions that hold transaction data might need to be backed up more frequently than partitions that hold logging or trace information.</span></span>

<span data-ttu-id="fb9a7-248">**单个分区的管理方式**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-248">**How individual partitions can be managed**.</span></span> <span data-ttu-id="fb9a7-249">将分区设计为支持单独管理和维护可提供多种优势。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-249">Designing partitions to support independent management and maintenance provides several advantages.</span></span> <span data-ttu-id="fb9a7-250">例如：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-250">For example:</span></span>

- <span data-ttu-id="fb9a7-251">如果分区故障，可以独立恢复该分区，不需使用在其他分区中访问数据的应用程序。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-251">If a partition fails, it can be recovered independently without applications that access data in other partitions.</span></span>

- <span data-ttu-id="fb9a7-252">按地理区域将数据分区可以在每个位置的非高峰时段进行计划的维护任务。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-252">Partitioning data by geographical area allows scheduled maintenance tasks to occur at off-peak hours for each location.</span></span> <span data-ttu-id="fb9a7-253">确保分区不会太大，避免任何计划中的维护在这段时间无法完成。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-253">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</span></span>

<span data-ttu-id="fb9a7-254">**是否要跨分区复制重要数据**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-254">**Whether to replicate critical data across partitions**.</span></span> <span data-ttu-id="fb9a7-255">此策略可以提高可用性和性能，但也可能会造成一致性问题。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-255">This strategy can improve availability and performance, but can also introduce consistency issues.</span></span> <span data-ttu-id="fb9a7-256">在每个副本中同步所做的更改需要时间。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-256">It takes time to synchronize changes with every replica.</span></span> <span data-ttu-id="fb9a7-257">在这段时间，不同的分区会包含不同的数据值。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-257">During this period, different partitions will contain different data values.</span></span>

## <a name="application-design-considerations"></a><span data-ttu-id="fb9a7-258">应用程序设计注意事项</span><span class="sxs-lookup"><span data-stu-id="fb9a7-258">Application design considerations</span></span>

<span data-ttu-id="fb9a7-259">分区会增大系统设计和开发的复杂性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-259">Partitioning adds complexity to the design and development of your system.</span></span> <span data-ttu-id="fb9a7-260">即使系统一开始只包含单个分区，也必须将分区视为系统设计的基础部分。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-260">Consider partitioning as a fundamental part of system design even if the system initially only contains a single partition.</span></span> <span data-ttu-id="fb9a7-261">如果事后才解决分区问题，则会更为困难，因为有一个实时系统需要维护：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-261">If you address partitioning as an afterthought, it will be more challenging because you already have a live system to maintain:</span></span>

- <span data-ttu-id="fb9a7-262">数据访问逻辑需要修改。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-262">Data access logic will need to be modified.</span></span>
- <span data-ttu-id="fb9a7-263">大量现有数据可能需要通过迁移的方式跨分区分配。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-263">Large quantities of existing data may need to be migrated, to distribute it across partitions</span></span>
- <span data-ttu-id="fb9a7-264">用户期望在迁移期间能够继续使用系统。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-264">Users expect to be able to continue using the system during the migration.</span></span>

<span data-ttu-id="fb9a7-265">在某些情况下，分区并不重要，因为初始数据集很小，可以轻松地由单个服务器处理。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-265">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</span></span> <span data-ttu-id="fb9a7-266">对某些工作负荷来说，这可能是真的，但是许多商务系统需要随用户数的增加而扩展。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-266">This might be true for some workloads, but many commercial systems need to expand as the number of users increases.</span></span>

<span data-ttu-id="fb9a7-267">另外，并非只有大型数据存储才受益于分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-267">Moreover, it's not only large data stores that benefit from partitioning.</span></span> <span data-ttu-id="fb9a7-268">例如，数百个并发客户端可能会重度访问一个小型数据存储。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-268">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</span></span> <span data-ttu-id="fb9a7-269">在此情况下，将数据分区有助于减少争用并提高吞吐量。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-269">Partitioning the data in this situation can help to reduce contention and improve throughput.</span></span>

<span data-ttu-id="fb9a7-270">在设计数据分区方案时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-270">Consider the following points when you design a data partitioning scheme:</span></span>

<span data-ttu-id="fb9a7-271">**尽量减少跨分区数据访问操作**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-271">**Minimize cross-partition data access operations**.</span></span> <span data-ttu-id="fb9a7-272">尽可能将每个分区中最常见数据库操作的数据保存在一起，尽量减少跨分区数据访问操作。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-272">Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations.</span></span> <span data-ttu-id="fb9a7-273">跨分区查询可能比在单个分区中查询更费时，而优化一个查询集的分区可能对其他查询集造成不利影响。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-273">Querying across partitions can be more time-consuming than querying within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</span></span> <span data-ttu-id="fb9a7-274">如果必须跨分区查询，则应通过运行并行查询并在应用程序中聚合结果来尽量减少查询时间。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-274">If you must query across partitions, minimize query time by running parallel queries and aggregating the results within the application.</span></span> <span data-ttu-id="fb9a7-275">（在某些情况下可能无法使用这种方法，例如一个查询的结果会在下一个查询中使用时。）</span><span class="sxs-lookup"><span data-stu-id="fb9a7-275">(This approach might not be possible in some cases, such as when the result from one query is used in the next query.)</span></span>

<span data-ttu-id="fb9a7-276">**考虑复制静态引用数据。**</span><span class="sxs-lookup"><span data-stu-id="fb9a7-276">**Consider replicating static reference data.**</span></span> <span data-ttu-id="fb9a7-277">如果查询使用相对静态的引用数据，例如邮政编码表或产品列表，请考虑将该数据复制到所有分区，以减少不同分区中的独立查找操作。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-277">If queries use relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce separate lookup operations in different partitions.</span></span> <span data-ttu-id="fb9a7-278">这种方法还可以降低引用数据变成“热”数据集（来自整个系统的流量很大）的可能性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-278">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset, with heavy traffic from across the entire system.</span></span> <span data-ttu-id="fb9a7-279">不过，将更改同步到引用数据会产生额外的开销。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-279">However, there is an additional cost associated with synchronizing any changes to the reference data.</span></span>

<span data-ttu-id="fb9a7-280">**尽量减少跨分区联接。**</span><span class="sxs-lookup"><span data-stu-id="fb9a7-280">**Minimize cross-partition joins.**</span></span> <span data-ttu-id="fb9a7-281">尽量减少跨垂直和功能分区的引用完整性的要求。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-281">Where possible, minimize requirements for referential integrity across vertical and functional partitions.</span></span> <span data-ttu-id="fb9a7-282">在这些方案中，应用程序负责维护跨分区的引用完整性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-282">In these schemes, the application is responsible for maintaining referential integrity across partitions.</span></span> <span data-ttu-id="fb9a7-283">跨多个分区联接数据的查询效率不高，因为应用程序通常需要按照先键后外键的方式执行连续查询。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-283">Queries that join data across multiple partitions are inefficient because the application typically needs to perform consecutive queries based on a key and then a foreign key.</span></span> <span data-ttu-id="fb9a7-284">建议复制或取消规范化相关的数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-284">Instead, consider replicating or de-normalizing the relevant data.</span></span> <span data-ttu-id="fb9a7-285">如果需要进行跨分区联接，请对各分区运行并行查询，并在应用程序内部联接数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-285">If cross-partition joins are necessary, run parallel queries over the partitions and join the data within the application.</span></span>

<span data-ttu-id="fb9a7-286">**实现最终一致性**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-286">**Embrace eventual consistency**.</span></span> <span data-ttu-id="fb9a7-287">评估强一致性是否为实际要求。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-287">Evaluate whether strong consistency is actually a requirement.</span></span> <span data-ttu-id="fb9a7-288">分布式系统中的一种常见方法是实施最终一致性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-288">A common approach in distributed systems is to implement eventual consistency.</span></span> <span data-ttu-id="fb9a7-289">每个分区中的数据将单独更新，应用程序逻辑可确保所有更新成功完成。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-289">The data in each partition is updated separately, and the application logic ensures that the updates are all completed successfully.</span></span> <span data-ttu-id="fb9a7-290">此外，它还会处理在运行最终一致操作时查询数据所造成的不一致。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-290">It also handles the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span>

<span data-ttu-id="fb9a7-291">**考虑查询如何查找正确的分区**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-291">**Consider how queries locate the correct partition**.</span></span> <span data-ttu-id="fb9a7-292">如果查询必须扫描所有分区来查找所需的数据，即使运行多个并行查询，也会对性能产生严重的影响。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-292">If a query must scan all partitions to locate the required data, there is a significant impact on performance, even when multiple parallel queries are running.</span></span> <span data-ttu-id="fb9a7-293">使用垂直和功能分区时，查询可以自然地指定分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-293">With vertical and functional partitioning, queries can naturally specify the partition.</span></span> <span data-ttu-id="fb9a7-294">另一方面，水平分区可能会导致项的查找变得困难，因为每个分片都有相同的架构。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-294">Horizontal partitioning, on the other hand, can make locating an item difficult, because every shard has the same schema.</span></span> <span data-ttu-id="fb9a7-295">典型的解决方案是保留一种映射，用于查找特定项的分片位置。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-295">A typical solution to maintain a map that is used to look up the shard location for specific items.</span></span> <span data-ttu-id="fb9a7-296">此映射可以在应用程序的分片逻辑中实施，或者由数据存储维护（如果数据存储支持透明分片）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-296">This map can be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</span></span>

<span data-ttu-id="fb9a7-297">**考虑定期重新平衡分片**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-297">**Consider periodically rebalancing shards**.</span></span> <span data-ttu-id="fb9a7-298">使用水平分区时，重新平衡分片可能有助于根据大小和工作负荷均衡地分配数据，尽量减少热点，最大化查询性能，并解决物理存储限制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-298">With horizontal partitioning, rebalancing shards can help distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</span></span> <span data-ttu-id="fb9a7-299">不过，这是一个复杂的任务，通常需要使用定制工具或过程。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-299">However, this is a complex task that often requires the use of a custom tool or process.</span></span>

<span data-ttu-id="fb9a7-300">**复制分区。**</span><span class="sxs-lookup"><span data-stu-id="fb9a7-300">**Replicate partitions.**</span></span> <span data-ttu-id="fb9a7-301">复制每个分区可以进一步防范故障。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-301">If you replicate each partition, it provides additional protection against failure.</span></span> <span data-ttu-id="fb9a7-302">如果单个副本发生故障，查询可以定向到可用的副本。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-302">If a single replica fails, queries can be directed towards a working copy.</span></span>

<span data-ttu-id="fb9a7-303">**如果达到了分区策略的物理限制，可能需要将缩放性扩展到其他级别**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-303">**If you reach the physical limits of a partitioning strategy, you might need to extend the scalability to a different level**.</span></span> <span data-ttu-id="fb9a7-304">例如，如果分区位于数据库级别，则可能需要在多个数据库中查找或复制分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-304">For example, if partitioning is at the database level, you might need to locate or replicate partitions in multiple databases.</span></span> <span data-ttu-id="fb9a7-305">如果分区已在数据库级别，而物理限制成为一个问题，则可能需要在多个托管帐户中查找或复制分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-305">If partitioning is already at the database level, and physical limitations are an issue, it might mean that you need to locate or replicate partitions in multiple hosting accounts.</span></span>

<span data-ttu-id="fb9a7-306">**避免执行在多个分区中访问数据的事务**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-306">**Avoid transactions that access data in multiple partitions**.</span></span> <span data-ttu-id="fb9a7-307">某些数据存储针对修改数据的操作实施事务一致性和完整性，但仅当数据位于单个分区时才能如此。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-307">Some data stores implement transactional consistency and integrity for operations that modify data, but only when the data is located in a single partition.</span></span> <span data-ttu-id="fb9a7-308">如果需要跨多个分区的事务支持，可能需要实施此支持作为应用程序逻辑的一部分，因为大多数分区系统不提供本机支持。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-308">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</span></span>

<span data-ttu-id="fb9a7-309">所有数据存储都需要某种操作管理和监视活动。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-309">All data stores require some operational management and monitoring activity.</span></span> <span data-ttu-id="fb9a7-310">任务的范围可能包括加载数据、备份和还原数据、重新组织数据，以及确保系统正常有效地执行。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-310">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</span></span>

<span data-ttu-id="fb9a7-311">请注意以下会影响操作管理的因素：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-311">Consider the following factors that affect operational management:</span></span>

- <span data-ttu-id="fb9a7-312">**将数据分区时如何实施适当的管理和操作任务**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-312">**How to implement appropriate management and operational tasks when the data is partitioned**.</span></span> <span data-ttu-id="fb9a7-313">这些任务可能包括备份与还原、存档数据，监视系统及其他管理任务。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-313">These tasks might include backup and restore, archiving data, monitoring the system, and other administrative tasks.</span></span> <span data-ttu-id="fb9a7-314">例如，在备份和还原操作期间保持逻辑一致性可能是一个难题。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-314">For example, maintaining logical consistency during backup and restore operations can be a challenge.</span></span>

- <span data-ttu-id="fb9a7-315">**如何将数据载入多个分区，以及如何添加来自其他源的新数据**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-315">**How to load the data into multiple partitions and add new data that's arriving from other sources**.</span></span> <span data-ttu-id="fb9a7-316">某些工具和实用程序可能不支持分片数据操作（例如将数据载入正确的分区）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-316">Some tools and utilities might not support sharded data operations such as loading data into the correct partition.</span></span>

- <span data-ttu-id="fb9a7-317">**如何定期存档和删除数据**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-317">**How to archive and delete the data on a regular basis**.</span></span> <span data-ttu-id="fb9a7-318">为防止分区过度增长，需要定期（也许是每月）存档和删除数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-318">To prevent the excessive growth of partitions, you need to archive and delete data on a regular basis (perhaps monthly).</span></span> <span data-ttu-id="fb9a7-319">可能需要转换数据以符合不同的存档架构。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-319">It might be necessary to transform the data to match a different archive schema.</span></span>

- <span data-ttu-id="fb9a7-320">**如何找出数据完整性问题**。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-320">**How to locate data integrity issues**.</span></span> <span data-ttu-id="fb9a7-321">考虑运行定期过程来查找数据完整性问题，例如一个分区的数据引用了另一个分区中缺少的信息。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-321">Consider running a periodic process to locate any data integrity issues, such as data in one partition that references missing information in another.</span></span> <span data-ttu-id="fb9a7-322">该过程可能会尝试自动修复这些问题，或者会直接生成一个需手动审阅的报表。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-322">The process can either attempt to fix these issues automatically or simply generate a report for manual review.</span></span>

## <a name="rebalancing-partitions"></a><span data-ttu-id="fb9a7-323">重新平衡分区</span><span class="sxs-lookup"><span data-stu-id="fb9a7-323">Rebalancing partitions</span></span>

<span data-ttu-id="fb9a7-324">随着系统成熟，可能需要调整分区方案。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-324">As a system matures, you might have to adjust the partitioning scheme.</span></span> <span data-ttu-id="fb9a7-325">例如，各个分区可能会开始获得比例不当的流量并且变得热门，导致过度争用资源。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-325">For example, individual partitions might start get a disproportionate volume of traffic and become hot, leading to excessive contention.</span></span> <span data-ttu-id="fb9a7-326">或者，你可能低估了某些分区中的数据量，导致这些分区达到容量限制。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-326">Or you might have underestimated the volume of data in some partitions, causing some partitions to approach capacity limits.</span></span>

<span data-ttu-id="fb9a7-327">某些数据存储（例如 Cosmos DB）可能会自动对分区进行重新平衡。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-327">Some data stores, such as Cosmos DB, can automatically rebalance partitions.</span></span> <span data-ttu-id="fb9a7-328">在其他情况下，重新平衡是由两个阶段组成的管理任务：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-328">In other cases, rebalancing is an administrative task that consists of two stages:</span></span>

1. <span data-ttu-id="fb9a7-329">确定新的分区策略。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-329">Determine a new partitioning strategy.</span></span>

    - <span data-ttu-id="fb9a7-330">哪些分区需要拆分（或者可能需要合并）？</span><span class="sxs-lookup"><span data-stu-id="fb9a7-330">Which partitions need to be split (or possibly combined)?</span></span>
    - <span data-ttu-id="fb9a7-331">新分区键是什么？</span><span class="sxs-lookup"><span data-stu-id="fb9a7-331">What is the new partition key?</span></span>

2. <span data-ttu-id="fb9a7-332">将数据从旧的分区方案迁移到一组新的分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-332">Migrate data from the old partitioning scheme to the new set of partitions.</span></span>

<span data-ttu-id="fb9a7-333">也许能够在分区被使用时在分区之间迁移数据，具体取决于数据存储。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-333">Depending on the data store, you might be able to migrate data between partitions while they are in use.</span></span> <span data-ttu-id="fb9a7-334">这称为联机迁移。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-334">This is called *online migration*.</span></span> <span data-ttu-id="fb9a7-335">如果这不可行，可能需要在重定位数据时使分区不可用（脱机迁移）。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-335">If that's not possible, you might need to make partitions unavailable while the data is relocated (*offline migration*).</span></span>

### <a name="offline-migration"></a><span data-ttu-id="fb9a7-336">脱机迁移</span><span class="sxs-lookup"><span data-stu-id="fb9a7-336">Offline migration</span></span>

<span data-ttu-id="fb9a7-337">脱机迁移通常更为简单，因为降低了发生争用的可能性。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-337">Offline migration is generally simpler, because it reduces the chances of contention occurring.</span></span> <span data-ttu-id="fb9a7-338">从概念上讲，脱机迁移的工作方式如下所示：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-338">Conceptually, offline migration works as follows:</span></span>

1. <span data-ttu-id="fb9a7-339">将分区标记为脱机。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-339">Mark the partition offline.</span></span>
2. <span data-ttu-id="fb9a7-340">拆分/合并数据，并将其转移到新分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-340">Split-merge and move the data to the new partitions.</span></span>
3. <span data-ttu-id="fb9a7-341">验证数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-341">Verify the data.</span></span>
4. <span data-ttu-id="fb9a7-342">使新分区联机。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-342">Bring the new partitions online.</span></span>
5. <span data-ttu-id="fb9a7-343">删除旧分区。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-343">Remove the old partition.</span></span>

<span data-ttu-id="fb9a7-344">可以选择在步骤 1 中将分区标记为只读，使应用程序仍然能够在移动数据时读取数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-344">Optionally, you can mark a partition as read-only in step 1, so that applications can still read the data while it is being moved.</span></span>

## <a name="online-migration"></a><span data-ttu-id="fb9a7-345">联机迁移</span><span class="sxs-lookup"><span data-stu-id="fb9a7-345">Online migration</span></span>

<span data-ttu-id="fb9a7-346">联机迁移执行起来更复杂，但对用户的干扰较少。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-346">Online migration is more complex to perform but less disruptive.</span></span> <span data-ttu-id="fb9a7-347">该过程与脱机迁移类似，不同之处在于，原始分区不会标记为脱机。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-347">The process is similar to offline migration, except the original partition is not marked offline.</span></span> <span data-ttu-id="fb9a7-348">根据迁移过程的粒度（例如，是逐项迁移还是逐分片迁移），客户端应用程序中的数据访问代码可能需要处理保存在两个位置（原始分区和新分区）的数据的读取和写入。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-348">Depending on the granularity of the migration process (for example, item by item versus shard by shard), the data access code in the client applications might have to handle reading and writing data that's held in two locations, the original partition and the new partition.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="fb9a7-349">相关模式</span><span class="sxs-lookup"><span data-stu-id="fb9a7-349">Related patterns</span></span>

<span data-ttu-id="fb9a7-350">以下设计模式可能与方案相关：</span><span class="sxs-lookup"><span data-stu-id="fb9a7-350">The following design patterns might be relevant to your scenario:</span></span>

- <span data-ttu-id="fb9a7-351">[分配模式](../patterns/sharding.md)介绍了一些进行数据分片的常见策略。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-351">The [sharding pattern](../patterns/sharding.md) describes some common strategies for sharding data.</span></span>

- <span data-ttu-id="fb9a7-352">[索引表模式](../patterns/index-table.md)介绍了如何基于数据创建辅助索引。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-352">The [index table pattern](../patterns/index-table.md) shows how to create secondary indexes over data.</span></span> <span data-ttu-id="fb9a7-353">此方法可让应用程序使用未引用集合主键的查询快速检索数据。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-353">An application can quickly retrieve data with this approach, by using queries that do not reference the primary key of a collection.</span></span>

- <span data-ttu-id="fb9a7-354">[具体化视图模式](../patterns/materialized-view.md)介绍了如何生成预先填充的视图，用于汇总数据以支持快速查询操作。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-354">The [materialized view pattern](../patterns/materialized-view.md) describes how to generate pre-populated views that summarize data to support fast query operations.</span></span> <span data-ttu-id="fb9a7-355">如果包含汇总数据的分区分布在多个站点上，此方法可能对分区的数据存储很有用。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-355">This approach can be useful in a partitioned data store if the partitions that contain the data being summarized are distributed across multiple sites.</span></span>

## <a name="next-steps"></a><span data-ttu-id="fb9a7-356">后续步骤</span><span class="sxs-lookup"><span data-stu-id="fb9a7-356">Next steps</span></span>

- <span data-ttu-id="fb9a7-357">了解特定 Azure 服务的分区策略。</span><span class="sxs-lookup"><span data-stu-id="fb9a7-357">Learn about partitioning strategies for specific Azure services.</span></span> <span data-ttu-id="fb9a7-358">请参阅 [Data partitioning strategies](./data-partitioning-strategies.md)（数据分区策略）</span><span class="sxs-lookup"><span data-stu-id="fb9a7-358">See [Data partitioning strategies](./data-partitioning-strategies.md)</span></span>

[Azure 存储可伸缩性和性能目标]: /azure/storage/storage-scalability-targets
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
