---
title: 后台作业指南
titleSuffix: Best practices for cloud applications
description: 有关独立于用户界面运行的后台任务的指南。
author: dragon119
ms.date: 11/05/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 4b96c19dd8613a941a7408e1b99945d5fa0f5364
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248962"
---
# <a name="background-jobs"></a><span data-ttu-id="a8be5-103">后台作业</span><span class="sxs-lookup"><span data-stu-id="a8be5-103">Background jobs</span></span>

<span data-ttu-id="a8be5-104">许多类型的应用程序需要运行与用户界面 (UI) 无关的后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-104">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="a8be5-105">示例包括批处理作业、密集处理型任务，以及长时间运行的过程，例如工作流。</span><span class="sxs-lookup"><span data-stu-id="a8be5-105">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="a8be5-106">后台作业无需用户交互就可执行 -- 应用程序可以启动作业，并继续处理来自用户的交互请求。</span><span class="sxs-lookup"><span data-stu-id="a8be5-106">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="a8be5-107">这有助于减少应用程序 UI 上的负载，从而提高可用性，降低交互响应时间。</span><span class="sxs-lookup"><span data-stu-id="a8be5-107">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

<span data-ttu-id="a8be5-108">例如，如果应用程序需要生成用户上传的图像缩图，可以后台作业的形式执行此操作，并在完成时会缩图保存到存储中，用户无需等待过程完成。</span><span class="sxs-lookup"><span data-stu-id="a8be5-108">For example, if an application is required to generate thumbnails of images that are uploaded by users, it can do this as a background job and save the thumbnail to storage when it is complete--without the user needing to wait for the process to be completed.</span></span> <span data-ttu-id="a8be5-109">同样地，下单的用户可以启动一个后台工作流来处理订单，同时，UI 可让用户继续浏览 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="a8be5-109">In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the web app.</span></span> <span data-ttu-id="a8be5-110">当后台作业完成时，可以更新存储的订单数据，并将确认订单的电子邮件发送给用户。</span><span class="sxs-lookup"><span data-stu-id="a8be5-110">When the background job is complete, it can update the stored orders data and send an email to the user that confirms the order.</span></span>

<span data-ttu-id="a8be5-111">考虑是否将任务作为后台作业执行时，主要的准则是：是否可以在无需用户交互的情况下运行该任务，且 UI 无需等待作业完成。</span><span class="sxs-lookup"><span data-stu-id="a8be5-111">When you consider whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to be completed.</span></span> <span data-ttu-id="a8be5-112">在完成之前需要用户或 UI 等待的任务不适合作为后台作业运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-112">Tasks that require the user or the UI to wait while they are completed might not be appropriate as background jobs.</span></span>

## <a name="types-of-background-jobs"></a><span data-ttu-id="a8be5-113">后台作业的类型</span><span class="sxs-lookup"><span data-stu-id="a8be5-113">Types of background jobs</span></span>

<span data-ttu-id="a8be5-114">后台作业通常包括以下类型的一个或多个作业：</span><span class="sxs-lookup"><span data-stu-id="a8be5-114">Background jobs typically include one or more of the following types of jobs:</span></span>

- <span data-ttu-id="a8be5-115">CPU 密集型作业，例如数学计算或结构模型分析。</span><span class="sxs-lookup"><span data-stu-id="a8be5-115">CPU-intensive jobs, such as mathematical calculations or structural model analysis.</span></span>
- <span data-ttu-id="a8be5-116">I/O 密集型作业，例如执行一系列存储事务或文件索引编制。</span><span class="sxs-lookup"><span data-stu-id="a8be5-116">I/O-intensive jobs, such as executing a series of storage transactions or indexing files.</span></span>
- <span data-ttu-id="a8be5-117">批处理作业，例如夜间数据更新或计划的处理。</span><span class="sxs-lookup"><span data-stu-id="a8be5-117">Batch jobs, such as nightly data updates or scheduled processing.</span></span>
- <span data-ttu-id="a8be5-118">长时间运行的工作流，例如订单履行或预配服务和系统。</span><span class="sxs-lookup"><span data-stu-id="a8be5-118">Long-running workflows, such as order fulfillment, or provisioning services and systems.</span></span>
- <span data-ttu-id="a8be5-119">敏感数据处理，其中的任务将转移到更安全的位置以进行处理。</span><span class="sxs-lookup"><span data-stu-id="a8be5-119">Sensitive-data processing where the task is handed off to a more secure location for processing.</span></span> <span data-ttu-id="a8be5-120">例如，可能不希望处理 Web 应用中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-120">For example, you might not want to process sensitive data within a web app.</span></span> <span data-ttu-id="a8be5-121">而想使用[守护程序模式](../patterns/gatekeeper.md)等模式将数据传输到有权访问受保护存储的已隔离后台进程。</span><span class="sxs-lookup"><span data-stu-id="a8be5-121">Instead, you might use a pattern such as the [Gatekeeper pattern](../patterns/gatekeeper.md) to transfer the data to an isolated background process that has access to protected storage.</span></span>

## <a name="triggers"></a><span data-ttu-id="a8be5-122">触发器</span><span class="sxs-lookup"><span data-stu-id="a8be5-122">Triggers</span></span>

<span data-ttu-id="a8be5-123">可通过多种不同的方式启动后台作业。</span><span class="sxs-lookup"><span data-stu-id="a8be5-123">Background jobs can be initiated in several different ways.</span></span> <span data-ttu-id="a8be5-124">这些方式属于以下类别之一：</span><span class="sxs-lookup"><span data-stu-id="a8be5-124">They fall into one of the following categories:</span></span>

- <span data-ttu-id="a8be5-125">[事件驱动的触发器](#event-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-125">[**Event-driven triggers**](#event-driven-triggers).</span></span> <span data-ttu-id="a8be5-126">响应事件时启动任务，这通常是用户或工作流中的步骤执行的操作。</span><span class="sxs-lookup"><span data-stu-id="a8be5-126">The task is started in response to an event, typically an action taken by a user or a step in a workflow.</span></span>
- <span data-ttu-id="a8be5-127">[计划驱动的触发器](#schedule-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-127">[**Schedule-driven triggers**](#schedule-driven-triggers).</span></span> <span data-ttu-id="a8be5-128">基于计时器按计划调用任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-128">The task is invoked on a schedule based on a timer.</span></span> <span data-ttu-id="a8be5-129">这可能是定期计划，或者指定在以后运行的一次性调用。</span><span class="sxs-lookup"><span data-stu-id="a8be5-129">This might be a recurring schedule or a one-off invocation that is specified for a later time.</span></span>

### <a name="event-driven-triggers"></a><span data-ttu-id="a8be5-130">事件驱动的触发器</span><span class="sxs-lookup"><span data-stu-id="a8be5-130">Event-driven triggers</span></span>

<span data-ttu-id="a8be5-131">事件驱动的调用使用触发器来启动后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-131">Event-driven invocation uses a trigger to start the background task.</span></span> <span data-ttu-id="a8be5-132">使用事件驱动的触发器的示例包括：</span><span class="sxs-lookup"><span data-stu-id="a8be5-132">Examples of using event-driven triggers include:</span></span>

- <span data-ttu-id="a8be5-133">UI 或另一个作业将消息放入队列。</span><span class="sxs-lookup"><span data-stu-id="a8be5-133">The UI or another job places a message in a queue.</span></span> <span data-ttu-id="a8be5-134">该消息包含有关已执行的操作的数据，例如下单的用户。</span><span class="sxs-lookup"><span data-stu-id="a8be5-134">The message contains data about an action that has taken place, such as the user placing an order.</span></span> <span data-ttu-id="a8be5-135">后台任务将侦听此队列，并检测新消息是否已到达。</span><span class="sxs-lookup"><span data-stu-id="a8be5-135">The background task listens on this queue and detects the arrival of a new message.</span></span> <span data-ttu-id="a8be5-136">它将读取消息，并将其中的数据用作后台作业的输入。</span><span class="sxs-lookup"><span data-stu-id="a8be5-136">It reads the message and uses the data in it as the input to the background job.</span></span>
- <span data-ttu-id="a8be5-137">UI 或另一个作业将保存或更新存储中的值。</span><span class="sxs-lookup"><span data-stu-id="a8be5-137">The UI or another job saves or updates a value in storage.</span></span> <span data-ttu-id="a8be5-138">后台任务将监视存储并检测更改。</span><span class="sxs-lookup"><span data-stu-id="a8be5-138">The background task monitors the storage and detects changes.</span></span> <span data-ttu-id="a8be5-139">它将读取数据，并将数据用作后台作业的输入。</span><span class="sxs-lookup"><span data-stu-id="a8be5-139">It reads the data and uses it as the input to the background job.</span></span>
- <span data-ttu-id="a8be5-140">UI 或另一个作业向终结点（例如 HTTPS URI，或作为 Web 服务公开的 API）发出请求。</span><span class="sxs-lookup"><span data-stu-id="a8be5-140">The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API that is exposed as a web service.</span></span> <span data-ttu-id="a8be5-141">它在请求的过程中传递所需的数据以完成后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-141">It passes the data that is required to complete the background task as part of the request.</span></span> <span data-ttu-id="a8be5-142">终结点或 Web 服务调用后台任务，将数据用作其输入。</span><span class="sxs-lookup"><span data-stu-id="a8be5-142">The endpoint or web service invokes the background task, which uses the data as its input.</span></span>

<span data-ttu-id="a8be5-143">适合事件驱动调用的任务的典型示例包括图像处理、工作流、将信息发送到远程服务、发送电子邮件消息，以及在多租户应用程序中预配新用户。</span><span class="sxs-lookup"><span data-stu-id="a8be5-143">Typical examples of tasks that are suited to event-driven invocation include image processing, workflows, sending information to remote services, sending email messages, and provisioning new users in multitenant applications.</span></span>

### <a name="schedule-driven-triggers"></a><span data-ttu-id="a8be5-144">计划驱动的触发器</span><span class="sxs-lookup"><span data-stu-id="a8be5-144">Schedule-driven triggers</span></span>

<span data-ttu-id="a8be5-145">计划驱动的调用使用计时器启动后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-145">Schedule-driven invocation uses a timer to start the background task.</span></span> <span data-ttu-id="a8be5-146">使用计划驱动的触发器的示例包括：</span><span class="sxs-lookup"><span data-stu-id="a8be5-146">Examples of using schedule-driven triggers include:</span></span>

- <span data-ttu-id="a8be5-147">在应用程序本地运行的计时器或作为应用程序操作系统一部分的计时器定期调用后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-147">A timer that is running locally within the application or as part of the application's operating system invokes a background task on a regular basis.</span></span>
- <span data-ttu-id="a8be5-148">在不同应用程序中运行的计时器或计时器服务（例如 Azure 计划程序）定期将请求发送到 API 或 Web 服务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-148">A timer that is running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.</span></span> <span data-ttu-id="a8be5-149">API 或 Web 服务调用后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-149">The API or web service invokes the background task.</span></span>
- <span data-ttu-id="a8be5-150">单独的进程或应用程序启动计时器，从而在指定的时间延迟后或在特定时间调用后台任务一次。</span><span class="sxs-lookup"><span data-stu-id="a8be5-150">A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.</span></span>

<span data-ttu-id="a8be5-151">适合计划驱动调用的任务的典型示例包括批处理例程（例如，根据用户最新的行为来更新其相关产品列表）、例行数据处理任务（例如更新索引或生成累积结果）、分析每日报告的数据、清理保留的数据和数据一致性检查。</span><span class="sxs-lookup"><span data-stu-id="a8be5-151">Typical examples of tasks that are suited to schedule-driven invocation include batch-processing routines (such as updating related-products lists for users based on their recent behavior), routine data processing tasks (such as updating indexes or generating accumulated results), data analysis for daily reports, data retention cleanup, and data consistency checks.</span></span>

<span data-ttu-id="a8be5-152">如果使用必须作为单个实例运行的计划驱动任务，请注意以下事项：</span><span class="sxs-lookup"><span data-stu-id="a8be5-152">If you use a schedule-driven task that must run as a single instance, be aware of the following:</span></span>

- <span data-ttu-id="a8be5-153">如果缩放正在运行计划程序的计算实例（例如使用 Windows 计划任务的虚拟机），需要运行计划程序的多个实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-153">If the compute instance that is running the scheduler (such as a virtual machine using Windows scheduled tasks) is scaled, you will have multiple instances of the scheduler running.</span></span> <span data-ttu-id="a8be5-154">这些操作可能会启动任务的多个实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-154">These could start multiple instances of the task.</span></span>
- <span data-ttu-id="a8be5-155">如果任务的运行时间超过了计划程序事件的间隔时间，计划程序可以在前一个任务仍在运行时启动任务的另一个实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-155">If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.</span></span>

## <a name="returning-results"></a><span data-ttu-id="a8be5-156">返回结果</span><span class="sxs-lookup"><span data-stu-id="a8be5-156">Returning results</span></span>

<span data-ttu-id="a8be5-157">后台作业通过 UI 或调用后台任务的进程，以异步方式在独立进程甚至不同的位置运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-157">Background jobs execute asynchronously in a separate process, or even in a separate location, from the UI or the process that invoked the background task.</span></span> <span data-ttu-id="a8be5-158">在理想情况下，后台任务是“即发即弃”的操作，其执行进度不会影响 UI 或调用进程。</span><span class="sxs-lookup"><span data-stu-id="a8be5-158">Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.</span></span> <span data-ttu-id="a8be5-159">这意味着，调用进程不会等待任务完成。</span><span class="sxs-lookup"><span data-stu-id="a8be5-159">This means that the calling process does not wait for completion of the tasks.</span></span> <span data-ttu-id="a8be5-160">因此无法自动检测任务的结束时间。</span><span class="sxs-lookup"><span data-stu-id="a8be5-160">Therefore, it cannot automatically detect when the task ends.</span></span>

<span data-ttu-id="a8be5-161">如果需要后台任务与调用任务通信以指示进度或完成状态，则必须为此实施一种机制。</span><span class="sxs-lookup"><span data-stu-id="a8be5-161">If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.</span></span> <span data-ttu-id="a8be5-162">下面是一些示例：</span><span class="sxs-lookup"><span data-stu-id="a8be5-162">Some examples are:</span></span>

- <span data-ttu-id="a8be5-163">将状态指示器值写入可供 UI 或调用方任务访问的存储，这样可以在需要时监视或检查此值。</span><span class="sxs-lookup"><span data-stu-id="a8be5-163">Write a status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.</span></span> <span data-ttu-id="a8be5-164">可将后台任务必须返回给调用方的数据放入同一存储中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-164">Other data that the background task must return to the caller can be placed into the same storage.</span></span>
- <span data-ttu-id="a8be5-165">建立 UI 或调用方侦听的答复队列。</span><span class="sxs-lookup"><span data-stu-id="a8be5-165">Establish a reply queue that the UI or caller listens on.</span></span> <span data-ttu-id="a8be5-166">后台任务可将消息发送到指示状态和完成情况的队列。</span><span class="sxs-lookup"><span data-stu-id="a8be5-166">The background task can send messages to the queue that indicate status and completion.</span></span> <span data-ttu-id="a8be5-167">可将后台任务必须返回给调用方的数据放入消息中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-167">Data that the background task must return to the caller can be placed into the messages.</span></span> <span data-ttu-id="a8be5-168">如果使用 Azure 服务总线，则可以使用 **ReplyTo** 和 **CorrelationId** 属性来实现此功能。</span><span class="sxs-lookup"><span data-stu-id="a8be5-168">If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability.</span></span>
- <span data-ttu-id="a8be5-169">从 UI 或调用方可以访问的后台任务公开 API 或终结点以获取状态信息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-169">Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.</span></span> <span data-ttu-id="a8be5-170">可以在响应中包含后台任务必须返回给调用方的数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-170">Data that the background task must return to the caller can be included in the response.</span></span>
- <span data-ttu-id="a8be5-171">让后台任务通过 API 回调 UI 或调用方，以指示预定义时间点或完成时的状态。</span><span class="sxs-lookup"><span data-stu-id="a8be5-171">Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.</span></span> <span data-ttu-id="a8be5-172">这可以通过本地引发的事件或通过发布与订阅机制来实现。</span><span class="sxs-lookup"><span data-stu-id="a8be5-172">This might be through events raised locally or through a publish-and-subscribe mechanism.</span></span> <span data-ttu-id="a8be5-173">可在请求或事件负载中包含后台任务必须返回给调用方的数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-173">Data that the background task must return to the caller can be included in the request or event payload.</span></span>

## <a name="hosting-environment"></a><span data-ttu-id="a8be5-174">宿主环境</span><span class="sxs-lookup"><span data-stu-id="a8be5-174">Hosting environment</span></span>

<span data-ttu-id="a8be5-175">可以使用各种不同的 Azure 平台服务来托管后台任务：</span><span class="sxs-lookup"><span data-stu-id="a8be5-175">You can host background tasks by using a range of different Azure platform services:</span></span>

- <span data-ttu-id="a8be5-176">[**Azure Web 应用和 Web 作业**](#azure-web-apps-and-webjobs)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-176">[**Azure Web Apps and WebJobs**](#azure-web-apps-and-webjobs).</span></span> <span data-ttu-id="a8be5-177">可以根据 Web 应用上下文中各种不同类型的脚本或可执行程序，使用 Web 作业来执行自定义作业。</span><span class="sxs-lookup"><span data-stu-id="a8be5-177">You can use WebJobs to execute custom jobs based on a range of different types of scripts or executable programs within the context of a web app.</span></span>
- <span data-ttu-id="a8be5-178">[Azure 虚拟机](#azure-virtual-machines)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-178">[**Azure Virtual Machines**](#azure-virtual-machines).</span></span> <span data-ttu-id="a8be5-179">如果有 Windows 服务或想要使用 Windows 任务计划程序，则常见的做法是将后台任务托管在专用虚拟机中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-179">If you have a Windows service or want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.</span></span>
- <span data-ttu-id="a8be5-180">[Azure Batch](#azure-batch)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-180">[**Azure Batch**](#azure-batch).</span></span> <span data-ttu-id="a8be5-181">Batch 是一种平台服务，该服务计划在虚拟机托管集合上运行的计算密集型工作。</span><span class="sxs-lookup"><span data-stu-id="a8be5-181">Batch is a platform service that schedules compute-intensive work to run on a managed collection of virtual machines.</span></span> <span data-ttu-id="a8be5-182">它可以自动缩放计算资源。</span><span class="sxs-lookup"><span data-stu-id="a8be5-182">It can automatically scale compute resources.</span></span>
- <span data-ttu-id="a8be5-183">[**Azure Kubernetes 服务**](#azure-kubernetes-service) (AKS)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-183">[**Azure Kubernetes Service**](#azure-kubernetes-service) (AKS).</span></span> <span data-ttu-id="a8be5-184">Azure Kubernetes 服务为 Azure 上的 Kubernetes 提供一个托管型宿主环境。</span><span class="sxs-lookup"><span data-stu-id="a8be5-184">Azure Kubernetes Service provides a managed hosting environment for Kubernetes on Azure.</span></span>

<span data-ttu-id="a8be5-185">以下各节详细介绍每一个选项，并提供相关注意事项，帮助你选择适当的选项。</span><span class="sxs-lookup"><span data-stu-id="a8be5-185">The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.</span></span>

### <a name="azure-web-apps-and-webjobs"></a><span data-ttu-id="a8be5-186">Azure Web 应用和 Web 作业</span><span class="sxs-lookup"><span data-stu-id="a8be5-186">Azure Web Apps and WebJobs</span></span>

<span data-ttu-id="a8be5-187">可以使用 Azure Web 作业将自定义作业作为 Azure Web 应用中的后台任务来执行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-187">You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web App.</span></span> <span data-ttu-id="a8be5-188">Web 作业可在 Web 应用的上下文中作为连续进程运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-188">WebJobs run within the context of your web app as a continuous process.</span></span> <span data-ttu-id="a8be5-189">Web 作业还可以在响应来自 Azure 计划程序或外部因素（例如更改存储 Blob 和消息队列）的触发器事件时运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-189">WebJobs also run in response to a trigger event from Azure Scheduler or external factors, such as changes to storage blobs and message queues.</span></span> <span data-ttu-id="a8be5-190">作业可按需启动和停止，并可以正常关闭。</span><span class="sxs-lookup"><span data-stu-id="a8be5-190">Jobs can be started and stopped on demand, and shut down gracefully.</span></span> <span data-ttu-id="a8be5-191">如果连续运行的 Web 作业失败，它会自动重新启动。</span><span class="sxs-lookup"><span data-stu-id="a8be5-191">If a continuously running WebJob fails, it is automatically restarted.</span></span> <span data-ttu-id="a8be5-192">重试和错误操作可配置。</span><span class="sxs-lookup"><span data-stu-id="a8be5-192">Retry and error actions are configurable.</span></span>

<span data-ttu-id="a8be5-193">配置 Web 作业时：</span><span class="sxs-lookup"><span data-stu-id="a8be5-193">When you configure a WebJob:</span></span>

- <span data-ttu-id="a8be5-194">如果想要作业响应事件驱动的触发器，应将其配置为“连续运行”。</span><span class="sxs-lookup"><span data-stu-id="a8be5-194">If you want the job to respond to an event-driven trigger, you should configure it as **Run continuously**.</span></span> <span data-ttu-id="a8be5-195">脚本或进程存储在名为 site/wwwroot/app_data/jobs/continuous 的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-195">The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.</span></span>
- <span data-ttu-id="a8be5-196">如果想要作业响应计划驱动的触发器，应将其配置为“按计划运行”。</span><span class="sxs-lookup"><span data-stu-id="a8be5-196">If you want the job to respond to a schedule-driven trigger, you should configure it as **Run on a schedule**.</span></span> <span data-ttu-id="a8be5-197">脚本或进程存储在名为 site/wwwroot/app_data/jobs/triggered 的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-197">The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.</span></span>
- <span data-ttu-id="a8be5-198">如果在配置作业时选择了“按需要运行”选项，在启动时，该作业将执行选择了“按计划运行”选项时的相同代码。</span><span class="sxs-lookup"><span data-stu-id="a8be5-198">If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.</span></span>

<span data-ttu-id="a8be5-199">Azure Web 作业在 Web 应用沙箱中运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-199">Azure WebJobs run within the sandbox of the web app.</span></span> <span data-ttu-id="a8be5-200">这意味着，它们可以访问环境变量，并与 Web 应用共享连接字符串等信息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-200">This means that they can access environment variables and share information, such as connection strings, with the web app.</span></span> <span data-ttu-id="a8be5-201">作业有权访问运行该作业的计算机的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="a8be5-201">The job has access to the unique identifier of the machine that is running the job.</span></span> <span data-ttu-id="a8be5-202">名为 **AzureWebJobsStorage** 的连接字符串可用于访问应用程序数据的 Azure 存储队列、Blob 和表，以及用于消息传送和通信的服务总线。</span><span class="sxs-lookup"><span data-stu-id="a8be5-202">The connection string named **AzureWebJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and access to Service Bus for messaging and communication.</span></span> <span data-ttu-id="a8be5-203">名为 **AzureWebJobsDashboard** 的连接字符串可用于访问作业操作日志文件。</span><span class="sxs-lookup"><span data-stu-id="a8be5-203">The connection string named **AzureWebJobsDashboard** provides access to the job action log files.</span></span>

<span data-ttu-id="a8be5-204">Azure Web 作业具有以下特征：</span><span class="sxs-lookup"><span data-stu-id="a8be5-204">Azure WebJobs have the following characteristics:</span></span>

- <span data-ttu-id="a8be5-205">**安全性**：WebJobs 受 Web 应用的部署凭据保护。</span><span class="sxs-lookup"><span data-stu-id="a8be5-205">**Security**: WebJobs are protected by the deployment credentials of the web app.</span></span>
- <span data-ttu-id="a8be5-206">**支持的文件类型**：可以使用命令脚本 (.cmd)、批处理文件 (.bat)、PowerShell 脚本 (.ps1)、bash shell 脚本 (.sh)、PHP 脚本 (.php)、Python 脚本 (.py)、JavaScript 代码 (.js) 和可执行程序（.exe、.jar 等）来定义 WebJobs。</span><span class="sxs-lookup"><span data-stu-id="a8be5-206">**Supported file types**: You can define WebJobs by using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).</span></span>
- <span data-ttu-id="a8be5-207">**部署**：若要部署脚本和可执行文件，可以使用 [Azure 门户](/azure/app-service-web/web-sites-create-web-jobs)、[Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs)、[Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started)，也可以直接将它们复制到以下位置：</span><span class="sxs-lookup"><span data-stu-id="a8be5-207">**Deployment**: You can deploy scripts and executables by using the [Azure portal](/azure/app-service-web/web-sites-create-web-jobs), by using [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs), by using the [Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started), or by copying them directly to the following locations:</span></span>
  - <span data-ttu-id="a8be5-208">对于触发的执行：site/wwwroot/app_data/jobs/triggered/{job name}</span><span class="sxs-lookup"><span data-stu-id="a8be5-208">For triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}</span></span>
  - <span data-ttu-id="a8be5-209">对于连续执行：site/wwwroot/app_data/jobs/continuous/{job name}</span><span class="sxs-lookup"><span data-stu-id="a8be5-209">For continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}</span></span>
- <span data-ttu-id="a8be5-210">**日志记录**：Console.Out 被视为（标记为）INFO。</span><span class="sxs-lookup"><span data-stu-id="a8be5-210">**Logging**: Console.Out is treated (marked) as INFO.</span></span> <span data-ttu-id="a8be5-211">Console.Error 被视为 ERROR。</span><span class="sxs-lookup"><span data-stu-id="a8be5-211">Console.Error is treated as ERROR.</span></span> <span data-ttu-id="a8be5-212">可以使用 Azure 门户来访问监视和诊断信息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-212">You can access monitoring and diagnostics information by using the Azure portal.</span></span> <span data-ttu-id="a8be5-213">可以直接从站点下载日志文件。</span><span class="sxs-lookup"><span data-stu-id="a8be5-213">You can download log files directly from the site.</span></span> <span data-ttu-id="a8be5-214">这些信息保存在以下位置：</span><span class="sxs-lookup"><span data-stu-id="a8be5-214">They are saved in the following locations:</span></span>
  - <span data-ttu-id="a8be5-215">对于触发的执行：Vfs/data/jobs/triggered/jobName</span><span class="sxs-lookup"><span data-stu-id="a8be5-215">For triggered execution: Vfs/data/jobs/triggered/jobName</span></span>
  - <span data-ttu-id="a8be5-216">对于连续的执行：Vfs/data/jobs/continuous/jobName</span><span class="sxs-lookup"><span data-stu-id="a8be5-216">For continuous execution: Vfs/data/jobs/continuous/jobName</span></span>
- <span data-ttu-id="a8be5-217">**配置**：可以使用门户、REST API 和 PowerShell 配置 WebJobs。</span><span class="sxs-lookup"><span data-stu-id="a8be5-217">**Configuration**: You can configure WebJobs by using the portal, the REST API, and PowerShell.</span></span> <span data-ttu-id="a8be5-218">可以使用与作业脚本位于同一根目录的配置文件（名为 settings.job）来提供作业的配置信息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-218">You can use a configuration file named settings.job in the same root directory as the job script to provide configuration information for a job.</span></span> <span data-ttu-id="a8be5-219">例如：</span><span class="sxs-lookup"><span data-stu-id="a8be5-219">For example:</span></span>
  - <span data-ttu-id="a8be5-220">{ "stopping_wait_time":60 }</span><span class="sxs-lookup"><span data-stu-id="a8be5-220">{ "stopping_wait_time": 60 }</span></span>
  - <span data-ttu-id="a8be5-221">{ "is_singleton": true }</span><span class="sxs-lookup"><span data-stu-id="a8be5-221">{ "is_singleton": true }</span></span>

#### <a name="considerations"></a><span data-ttu-id="a8be5-222">注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-222">Considerations</span></span>

- <span data-ttu-id="a8be5-223">默认情况下，Web 作业会随 Web 应用缩放。</span><span class="sxs-lookup"><span data-stu-id="a8be5-223">By default, WebJobs scale with the web app.</span></span> <span data-ttu-id="a8be5-224">但是，可以通过将 **is_singleton** 配置属性设置为 **true**，将作业配置为在单个实例上运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-224">However, you can configure jobs to run on single instance by setting the **is_singleton** configuration property to **true**.</span></span> <span data-ttu-id="a8be5-225">单个实例 Web 作业适用于不希望以同时进行多个实例的方式进行缩放或运行的任务（如重建索引、数据分析和类似任务）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-225">Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as reindexing, data analysis, and similar tasks.</span></span>
- <span data-ttu-id="a8be5-226">要将 Web 应用性能对任务的影响降到最低，请考虑在新的应用服务计划中创建空的 Azure Web 应用，以托管可能长时间运行或资源密集型的 Web 作业。</span><span class="sxs-lookup"><span data-stu-id="a8be5-226">To minimize the impact of jobs on the performance of the web app, consider creating an empty Azure Web App instance in a new App Service plan to host WebJobs that may be long running or resource intensive.</span></span>

### <a name="azure-virtual-machines"></a><span data-ttu-id="a8be5-227">Azure 虚拟机</span><span class="sxs-lookup"><span data-stu-id="a8be5-227">Azure Virtual Machines</span></span>

<span data-ttu-id="a8be5-228">实施后台任务时，可以避免将其部署到 Azure Web 应用，但有时这些选项可能不方便。</span><span class="sxs-lookup"><span data-stu-id="a8be5-228">Background tasks might be implemented in a way that prevents them from being deployed to Azure Web Apps, or these options might not be convenient.</span></span> <span data-ttu-id="a8be5-229">典型的示例包括 Windows 服务、第三方实用程序和可执行程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-229">Typical examples are Windows services, and third-party utilities and executable programs.</span></span> <span data-ttu-id="a8be5-230">另一个示例是针对托管应用程序以外的执行环境所编写的程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-230">Another example might be programs written for an execution environment that is different than that hosting the application.</span></span> <span data-ttu-id="a8be5-231">例如，它可能是你想要从 Windows 或 .NET 应用程序执行的 Unix 或 Linux 程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-231">For example, it might be a Unix or Linux program that you want to execute from a Windows or .NET application.</span></span> <span data-ttu-id="a8be5-232">可以为 Azure 虚拟机选择各种操作系统，并在该虚拟机上运行服务或可执行文件。</span><span class="sxs-lookup"><span data-stu-id="a8be5-232">You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.</span></span>

<span data-ttu-id="a8be5-233">若要确定何时使用虚拟机，请参阅 [Azure 应用服务s, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/)（Azure 应用程序服务、云服务和虚拟机的比较）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-233">To help you choose when to use Virtual Machines, see [Azure App Services, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/).</span></span> <span data-ttu-id="a8be5-234">有关虚拟机选项的信息，请参阅 [Azure 中的 Windows 虚拟机大小](/azure/virtual-machines/windows/sizes)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-234">For information about the options for Virtual Machines, see [Sizes for Windows virtual machines in Azure](/azure/virtual-machines/windows/sizes).</span></span> <span data-ttu-id="a8be5-235">有关虚拟机可用的操作系统和预建映像的详细信息，请参阅 [Azure 虚拟机市场](https://azure.microsoft.com/gallery/virtual-machines/)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-235">For more information about the operating systems and prebuilt images that are available for Virtual Machines, see [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/).</span></span>

<span data-ttu-id="a8be5-236">若要在独立的虚拟机中启动后台任务，可以从多个选项中进行选择：</span><span class="sxs-lookup"><span data-stu-id="a8be5-236">To initiate the background task in a separate virtual machine, you have a range of options:</span></span>

- <span data-ttu-id="a8be5-237">可以通过将请求发送到任务公开的终结点，来根据需要直接从应用程序执行任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-237">You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes.</span></span> <span data-ttu-id="a8be5-238">这会传入任务所需的任何数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-238">This passes in any data that the task requires.</span></span> <span data-ttu-id="a8be5-239">此终结点将调用该任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-239">This endpoint invokes the task.</span></span>
- <span data-ttu-id="a8be5-240">可以将任务配置为使用所选操作系统中提供的计划程序或计时器按计划运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-240">You can configure the task to run on a schedule by using a scheduler or timer that is available in your chosen operating system.</span></span> <span data-ttu-id="a8be5-241">例如，可以在 Windows 上使用 Windows 任务计划程序来执行脚本和任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-241">For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks.</span></span> <span data-ttu-id="a8be5-242">或者，如果已在虚拟机上安装了 SQL Server，则可以使用 SQL Server 代理来执行脚本和任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-242">Or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.</span></span>
- <span data-ttu-id="a8be5-243">可以使用 Azure 计划程序来启动任务，方法是将消息添加到任务侦听的队列，或将请求发送到任务公开的 API。</span><span class="sxs-lookup"><span data-stu-id="a8be5-243">You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.</span></span>

<span data-ttu-id="a8be5-244">有关如何启动后台任务的详细信息，请参阅前面的[触发器](#triggers)部分。</span><span class="sxs-lookup"><span data-stu-id="a8be5-244">See the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.</span></span>

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a><span data-ttu-id="a8be5-245">注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-245">Considerations</span></span>

<!-- markdownlint-enable MD024 -->

<span data-ttu-id="a8be5-246">在确定是否要在 Azure 虚拟机中部署后台任务时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="a8be5-246">Consider the following points when you are deciding whether to deploy background tasks in an Azure virtual machine:</span></span>

- <span data-ttu-id="a8be5-247">在单独的 Azure 虚拟机中托管后台任务可提供弹性，并可通过启动、执行、计划和资源分配来实现精确控制。</span><span class="sxs-lookup"><span data-stu-id="a8be5-247">Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.</span></span> <span data-ttu-id="a8be5-248">但是，如果只是出于运行后台任务的目的而必须部署虚拟机，则会增加运行时成本。</span><span class="sxs-lookup"><span data-stu-id="a8be5-248">However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.</span></span>
- <span data-ttu-id="a8be5-249">没有任何工具可以监视 Azure 门户中的任务，并且对于失败的任务没有任何自动重新启动功能 -- 不过，用户可以监视虚拟机的基本状态，并使用[Azure 资源管理器 Cmdlet](https://msdn.microsoft.com/library/mt125356.aspx) 来管理它。</span><span class="sxs-lookup"><span data-stu-id="a8be5-249">There is no facility to monitor the tasks in the Azure portal and no automated restart capability for failed tasks--although you can monitor the basic status of the virtual machine and manage it by using the  [Azure Resource Manager Cmdlets](https://msdn.microsoft.com/library/mt125356.aspx).</span></span> <span data-ttu-id="a8be5-250">但是，计算节点中没有任何工具可用于控制进程和线程。</span><span class="sxs-lookup"><span data-stu-id="a8be5-250">However, there are no facilities to control processes and threads in compute nodes.</span></span> <span data-ttu-id="a8be5-251">通常，使用虚拟机时，需要付出额外的工作量才能实施一个机制用于从任务的检测中收集数据，以及从虚拟机中的操作系统收集数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-251">Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.</span></span> <span data-ttu-id="a8be5-252">一个适当的解决方案是使用 [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013)（用于 Azure 的 System Center 管理包）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-252">One solution that might be appropriate is to use the [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013).</span></span>
- <span data-ttu-id="a8be5-253">可以考虑创建通过 HTTP 终结点公开的监视探测。</span><span class="sxs-lookup"><span data-stu-id="a8be5-253">You might consider creating monitoring probes that are exposed through HTTP endpoints.</span></span> <span data-ttu-id="a8be5-254">这些探测器的代码可以执行运行状况检查、收集操作信息和统计信息，或者整理错误信息，并将其返回给管理应用程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-254">The code for these probes could perform health checks, collect operational information and statistics--or collate error information and return it to a management application.</span></span> <span data-ttu-id="a8be5-255">有关详细信息，请参阅[运行状况终结点监视模式](../patterns/health-endpoint-monitoring.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-255">For more information, see the [Health Endpoint Monitoring pattern](../patterns/health-endpoint-monitoring.md).</span></span>

<span data-ttu-id="a8be5-256">有关详细信息，请参阅：</span><span class="sxs-lookup"><span data-stu-id="a8be5-256">For more information, see:</span></span>

- [<span data-ttu-id="a8be5-257">虚拟机</span><span class="sxs-lookup"><span data-stu-id="a8be5-257">Virtual Machines</span></span>](https://azure.microsoft.com/services/virtual-machines/)
- [<span data-ttu-id="a8be5-258">Azure 虚拟机常见问题解答</span><span class="sxs-lookup"><span data-stu-id="a8be5-258">Azure Virtual Machines FAQ</span></span>](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a><span data-ttu-id="a8be5-259">Azure 批处理</span><span class="sxs-lookup"><span data-stu-id="a8be5-259">Azure Batch</span></span>

<span data-ttu-id="a8be5-260">如果需要在数十、数百或数千个 VM 上运行大型、并行的高性能计算 (HPC) 工作负载，请考虑使用 [Azure Batch](/azure/batch/)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-260">Consider [Azure Batch](/azure/batch/) if you need to run large, parallel high-performance computing (HPC) workloads across tens, hundreds, or thousands of VMs.</span></span>

<span data-ttu-id="a8be5-261">Batch 服务预配 VM、将任务分配给 VM、运行任务并监视进度。</span><span class="sxs-lookup"><span data-stu-id="a8be5-261">The Batch service provisions the VMs, assign tasks to the VMs, runs the tasks, and monitors the progress.</span></span> <span data-ttu-id="a8be5-262">Batch 可以根据工作负载横向扩展 VM。</span><span class="sxs-lookup"><span data-stu-id="a8be5-262">Batch can automatically scale out the VMs in response to the workload.</span></span> <span data-ttu-id="a8be5-263">Batch 还提供作业计划。</span><span class="sxs-lookup"><span data-stu-id="a8be5-263">Batch also provides job scheduling.</span></span> <span data-ttu-id="a8be5-264">Azure Batch 支持 Linux 和 Windows VM。</span><span class="sxs-lookup"><span data-stu-id="a8be5-264">Azure Batch supports both Linux and Windows VMs.</span></span>

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a><span data-ttu-id="a8be5-265">注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-265">Considerations</span></span>

<!-- markdownlint-enable MD024 -->

<span data-ttu-id="a8be5-266">Batch 在固有并行的工作负载上运行良好。</span><span class="sxs-lookup"><span data-stu-id="a8be5-266">Batch works well with intrinsically parallel workloads.</span></span> <span data-ttu-id="a8be5-267">它还可执行并行计算（最后有一个减少单步执行），或者为需要在节点间传递的消息的并行任务，运行[消息传递接口 (MPI) 应用程序](/azure/batch/batch-mpi)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-267">It can also perform parallel calculations with a reduce step at the end, or run [Message Passing Interface (MPI) applications](/azure/batch/batch-mpi) for parallel tasks that require message passing between nodes.</span></span>

<span data-ttu-id="a8be5-268">Azure Batch 作业在节点池上运行 (VM)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-268">An Azure Batch job runs on a pool of nodes (VMs).</span></span> <span data-ttu-id="a8be5-269">一种方法是仅在需要时分配池并在作业完成后将其删除。</span><span class="sxs-lookup"><span data-stu-id="a8be5-269">One approach is to allocate a pool only when needed and then delete it after the job completes.</span></span> <span data-ttu-id="a8be5-270">这可最大化利用率，因为节点不是空闲状态，但是作业必须等待节点分配。</span><span class="sxs-lookup"><span data-stu-id="a8be5-270">This maximizes utilization, because nodes are not idle, but the job must wait for nodes to be allocated.</span></span> <span data-ttu-id="a8be5-271">或者，可以提前创建池。</span><span class="sxs-lookup"><span data-stu-id="a8be5-271">Alternatively, you can create a pool ahead of time.</span></span> <span data-ttu-id="a8be5-272">此方法可最小化启动作业的时间，但是会导致节点处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="a8be5-272">That approach minimizes the time that it takes for a job to start, but can result in having nodes that sit idle.</span></span> <span data-ttu-id="a8be5-273">有关详细信息，请参阅[池和计算节点生存期](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-273">For more information, see [Pool and compute node lifetime](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime).</span></span>

<span data-ttu-id="a8be5-274">有关详细信息，请参阅：</span><span class="sxs-lookup"><span data-stu-id="a8be5-274">For more information, see:</span></span>

- [<span data-ttu-id="a8be5-275">什么是 Azure Batch？</span><span class="sxs-lookup"><span data-stu-id="a8be5-275">What is Azure Batch?</span></span>](/azure/batch/batch-technical-overview)
- [<span data-ttu-id="a8be5-276">使用 Batch 开发大规模并行计算解决方案</span><span class="sxs-lookup"><span data-stu-id="a8be5-276">Develop large-scale parallel compute solutions with Batch</span></span>](/azure/batch/batch-api-basics)
- [<span data-ttu-id="a8be5-277">适用于大规模计算工作负载的 Batch 和 HPC 解决方案</span><span class="sxs-lookup"><span data-stu-id="a8be5-277">Batch and HPC solutions for large-scale computing workloads</span></span>](/azure/batch/batch-hpc-solutions)

### <a name="azure-kubernetes-service"></a><span data-ttu-id="a8be5-278">Azure Kubernetes 服务</span><span class="sxs-lookup"><span data-stu-id="a8be5-278">Azure Kubernetes Service</span></span>

<span data-ttu-id="a8be5-279">Azure Kubernetes 服务 (AKS) 管理托管的 Kubernetes 环境，使用户可以轻松地部署和管理容器化的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-279">Azure Kubernetes Service (AKS) manages your hosted Kubernetes environment, which makes it easy to deploy and manage containerized applications.</span></span>

<span data-ttu-id="a8be5-280">容器有助于运行后台作业。</span><span class="sxs-lookup"><span data-stu-id="a8be5-280">Containers can be useful for running background jobs.</span></span> <span data-ttu-id="a8be5-281">一些优点包括：</span><span class="sxs-lookup"><span data-stu-id="a8be5-281">Some of the benefits include:</span></span>

- <span data-ttu-id="a8be5-282">容器支持高密度托管。</span><span class="sxs-lookup"><span data-stu-id="a8be5-282">Containers support high-density hosting.</span></span> <span data-ttu-id="a8be5-283">可以隔离容器中的后台任务，同时在每个 VM 中放置多个容器。</span><span class="sxs-lookup"><span data-stu-id="a8be5-283">You can isolate a background task in a container, while placing multiple containers in each VM.</span></span>
- <span data-ttu-id="a8be5-284">容器业务流程协调程序处理内部负载均衡、配置内部网络和其他配置任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-284">The container orchestrator handles internal load balancing, configuring the internal network, and other configuration tasks.</span></span>
- <span data-ttu-id="a8be5-285">容器可在需要时启动和停止。</span><span class="sxs-lookup"><span data-stu-id="a8be5-285">Containers can be started and stopped as needed.</span></span>
- <span data-ttu-id="a8be5-286">通过Azure 容器注册表，可注册 Azure 边界内的容器。</span><span class="sxs-lookup"><span data-stu-id="a8be5-286">Azure Container Registry allows you to register your containers inside Azure boundaries.</span></span> <span data-ttu-id="a8be5-287">这会带来安全性、隐私和邻近感应方面的好处。</span><span class="sxs-lookup"><span data-stu-id="a8be5-287">This comes with security, privacy, and proximity benefits.</span></span>

<!-- markdownlint-disable MD024 -->

#### <a name="considerations"></a><span data-ttu-id="a8be5-288">注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-288">Considerations</span></span>

<!-- markdownlint-enable MD024 -->

- <span data-ttu-id="a8be5-289">需要了解如何使用容器业务流程协调程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-289">Requires an understanding of how to use a container orchestrator.</span></span> <span data-ttu-id="a8be5-290">这是否可能成为一个问题取决于 DevOps 团队的技能组合。</span><span class="sxs-lookup"><span data-stu-id="a8be5-290">Depending on the skillset of your DevOps team, this may or may not be an issue.</span></span>

<span data-ttu-id="a8be5-291">有关详细信息，请参阅：</span><span class="sxs-lookup"><span data-stu-id="a8be5-291">For more information, see:</span></span>

- [<span data-ttu-id="a8be5-292">Azure 中的容器概述</span><span class="sxs-lookup"><span data-stu-id="a8be5-292">Overview of containers in Azure</span></span>](https://azure.microsoft.com/overview/containers/)

- [<span data-ttu-id="a8be5-293">专用 Docker 容器注册表简介</span><span class="sxs-lookup"><span data-stu-id="a8be5-293">Introduction to private Docker container registries</span></span>](/azure/container-registry/container-registry-intro)

## <a name="partitioning"></a><span data-ttu-id="a8be5-294">分区</span><span class="sxs-lookup"><span data-stu-id="a8be5-294">Partitioning</span></span>

<span data-ttu-id="a8be5-295">如果决定在现有的计算实例中包括后台任务，必须考虑这会如何影响计算实例和后台任务本身的质量属性。</span><span class="sxs-lookup"><span data-stu-id="a8be5-295">If you decide to include background tasks within an existing compute instance, you must consider how this will affect the quality attributes of the compute instance and the background task itself.</span></span> <span data-ttu-id="a8be5-296">这些因素可帮助你确定是要将任务与现有计算实例放在一起，还是将它们隔离成独立的计算实例：</span><span class="sxs-lookup"><span data-stu-id="a8be5-296">These factors will help you to decide whether to colocate the tasks with the existing compute instance or separate them out into a separate compute instance:</span></span>

- <span data-ttu-id="a8be5-297">**可用性**：后台任务可能无需具有应用程序其他部分所具有的相同可用性级别，特别是直接参与用户交互的 UI 和其他部分。</span><span class="sxs-lookup"><span data-stu-id="a8be5-297">**Availability**: Background tasks might not need to have the same level of availability as other parts of the application, in particular the UI and other parts that are directly involved in user interaction.</span></span> <span data-ttu-id="a8be5-298">由于可将操作排入队列，后台任务可能更容许延迟、重试的连接失败，以及影响可用性的其他因素。</span><span class="sxs-lookup"><span data-stu-id="a8be5-298">Background tasks might be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.</span></span> <span data-ttu-id="a8be5-299">但是，必须有足够的容量来防止备份可能阻止队列和影响整个应用程序的请求。</span><span class="sxs-lookup"><span data-stu-id="a8be5-299">However, there must be sufficient capacity to prevent the backup of requests that could block queues and affect the application as a whole.</span></span>

- <span data-ttu-id="a8be5-300">**可伸缩性**：后台任务的可伸缩性要求可能不同于应用程序的 UI 和交互部分。</span><span class="sxs-lookup"><span data-stu-id="a8be5-300">**Scalability**: Background tasks are likely to have a different scalability requirement than the UI and the interactive parts of the application.</span></span> <span data-ttu-id="a8be5-301">缩放 UI 可能需要符合需求的高峰，而未完成的后台任务可能在较空闲的时间由较少的计算实例数完成。</span><span class="sxs-lookup"><span data-stu-id="a8be5-301">Scaling the UI might be necessary to meet peaks in demand, while outstanding background tasks might be completed during less busy times by a fewer number of compute instances.</span></span>

- <span data-ttu-id="a8be5-302">**复原能力**：如果后台任务的请求可以排入队列或延迟到任务再次可用为止，则刚好托管这些任务的计算实例失败不会严重影响整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-302">**Resiliency**: Failure of a compute instance that just hosts background tasks might not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.</span></span> <span data-ttu-id="a8be5-303">如果计算实例和/或任务可以在适当的间隔内重新启动，则不可以影响应用程序的用户。</span><span class="sxs-lookup"><span data-stu-id="a8be5-303">If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application might not be affected.</span></span>

- <span data-ttu-id="a8be5-304">**安全性**：相较于 UI 或应用程序的其他部分，后台任务可能有不同的安全要求或限制。</span><span class="sxs-lookup"><span data-stu-id="a8be5-304">**Security**: Background tasks might have different security requirements or restrictions than the UI or other parts of the application.</span></span> <span data-ttu-id="a8be5-305">通过使用单独的计算实例，可以为任务指定不同的安全环境。</span><span class="sxs-lookup"><span data-stu-id="a8be5-305">By using a separate compute instance, you can specify a different security environment for the tasks.</span></span> <span data-ttu-id="a8be5-306">还可以使用模式（例如守护程序）将后台计算实例与 UI 相隔离，以最大程度地提供安全性和隔离性。</span><span class="sxs-lookup"><span data-stu-id="a8be5-306">You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.</span></span>

- <span data-ttu-id="a8be5-307">**性能**：可以选择与任务的性能要求刚好相符的后台任务计算实例类型。</span><span class="sxs-lookup"><span data-stu-id="a8be5-307">**Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.</span></span> <span data-ttu-id="a8be5-308">这可能意味着，当任务无需与 UI 具有相同处理功能时，可以使用更便宜的计算选项；或者如果任务需要附加的容量和资源，则使用更大的实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-308">This might mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.</span></span>

- <span data-ttu-id="a8be5-309">**可管理性**：相较于主应用程序代码或 UI，后台任务可能有不同的开发和部署节奏。</span><span class="sxs-lookup"><span data-stu-id="a8be5-309">**Manageability**: Background tasks might have a different development and deployment rhythm from the main application code or the UI.</span></span> <span data-ttu-id="a8be5-310">将它们部署到不同的计算实例可简化更新与版本控制。</span><span class="sxs-lookup"><span data-stu-id="a8be5-310">Deploying them to a separate compute instance can simplify updates and versioning.</span></span>

- <span data-ttu-id="a8be5-311">**成本**：添加计算实例来执行后台任务会增加托管成本。</span><span class="sxs-lookup"><span data-stu-id="a8be5-311">**Cost**: Adding compute instances to execute background tasks increases hosting costs.</span></span> <span data-ttu-id="a8be5-312">应该仔细考虑如何在添加容量与产生的成本之间做出取舍。</span><span class="sxs-lookup"><span data-stu-id="a8be5-312">You should carefully consider the trade-off between additional capacity and these extra costs.</span></span>

<span data-ttu-id="a8be5-313">有关详细信息，请参阅[领导选拔模式](../patterns/leader-election.md)和[使用者竞争模式](../patterns/competing-consumers.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-313">For more information, see the [Leader Election pattern](../patterns/leader-election.md) and the [Competing Consumers pattern](../patterns/competing-consumers.md).</span></span>

## <a name="conflicts"></a><span data-ttu-id="a8be5-314">冲突</span><span class="sxs-lookup"><span data-stu-id="a8be5-314">Conflicts</span></span>

<span data-ttu-id="a8be5-315">如果有后台作业的多个实例，这些实例可能会争用对资源和服务（例如数据库和存储）的访问权。</span><span class="sxs-lookup"><span data-stu-id="a8be5-315">If you have multiple instances of a background job, it is possible that they will compete for access to resources and services, such as databases and storage.</span></span> <span data-ttu-id="a8be5-316">这种并发访问可能会导致资源争用情况，从而造成服务可用性及存储中数据完整性的冲突。</span><span class="sxs-lookup"><span data-stu-id="a8be5-316">This concurrent access can result in resource contention, which might cause conflicts in availability of the services and in the integrity of data in storage.</span></span> <span data-ttu-id="a8be5-317">可以使用悲观锁定方法来解决资源争用。</span><span class="sxs-lookup"><span data-stu-id="a8be5-317">You can resolve resource contention by using a pessimistic locking approach.</span></span> <span data-ttu-id="a8be5-318">这可以防止任务的竞争实例同时访问某个服务或损坏数据。</span><span class="sxs-lookup"><span data-stu-id="a8be5-318">This prevents competing instances of a task from concurrently accessing a service or corrupting data.</span></span>

<span data-ttu-id="a8be5-319">另一种解决冲突的方法是将后台任务定义为单一实例，以便只有一个运行中的实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-319">Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.</span></span> <span data-ttu-id="a8be5-320">但是，这会消除多实例配置可提供的可靠性和性能优势。</span><span class="sxs-lookup"><span data-stu-id="a8be5-320">However, this eliminates the reliability and performance benefits that a multiple-instance configuration can provide.</span></span> <span data-ttu-id="a8be5-321">当 UI 可以提供足够的工作让多个后台任务保持繁忙时尤其如此。</span><span class="sxs-lookup"><span data-stu-id="a8be5-321">This is especially true if the UI can supply sufficient work to keep more than one background task busy.</span></span>

<span data-ttu-id="a8be5-322">必须确保后台任务可以自动重新启动，并且有足够的容量来应对需求高峰。</span><span class="sxs-lookup"><span data-stu-id="a8be5-322">It is vital to ensure that the background task can automatically restart and that it has sufficient capacity to cope with peaks in demand.</span></span> <span data-ttu-id="a8be5-323">这可以通过将足够的资源分配给计算实例、实施队列机制（可存储请求以便日后续需求降低时执行）或使用这些方法的组合来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="a8be5-323">You can achieve this by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by using a combination of these techniques.</span></span>

## <a name="coordination"></a><span data-ttu-id="a8be5-324">协调</span><span class="sxs-lookup"><span data-stu-id="a8be5-324">Coordination</span></span>

<span data-ttu-id="a8be5-325">后台任务可能很复杂，需要执行多个不同的任务来生成结果或满足所有要求。</span><span class="sxs-lookup"><span data-stu-id="a8be5-325">The background tasks might be complex and might require multiple individual tasks to execute to produce a result or to fulfil all the requirements.</span></span> <span data-ttu-id="a8be5-326">在这些方案中，住往会将任务分割成可由多个使用者执行的较小离散步骤或子任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-326">It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.</span></span> <span data-ttu-id="a8be5-327">多步骤操作可能更有效率且更具弹性，因为单个步骤可以在多个作业中重复使用。</span><span class="sxs-lookup"><span data-stu-id="a8be5-327">Multistep jobs can be more efficient and more flexible because individual steps might be reusable in multiple jobs.</span></span> <span data-ttu-id="a8be5-328">还可以轻松地添加、删除或修改步骤的顺序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-328">It is also easy to add, remove, or modify the order of the steps.</span></span>

<span data-ttu-id="a8be5-329">协调多个任务和步骤可能相当困难，但可以参考三种常见的模式来实施解决方案：</span><span class="sxs-lookup"><span data-stu-id="a8be5-329">Coordinating multiple tasks and steps can be challenging, but there are three common patterns that you can use to guide your implementation of a solution:</span></span>

- <span data-ttu-id="a8be5-330">**将一个任务分解成多个可重复使用的步骤**。</span><span class="sxs-lookup"><span data-stu-id="a8be5-330">**Decomposing a task into multiple reusable steps**.</span></span> <span data-ttu-id="a8be5-331">对于处理的信息，应用程序可能需要执行复杂性不一的各种任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-331">An application might be required to perform a variety of tasks of varying complexity on the information that it processes.</span></span> <span data-ttu-id="a8be5-332">实施此应用程序的一种直接但有弹性的方法是将这种处理当作单一模块来执行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-332">A straightforward but inflexible approach to implementing this application might be to perform this processing as a monolithic module.</span></span> <span data-ttu-id="a8be5-333">但是，这种方法可能会降低重构代码、优化代码或在应用程序的其他位置需要相同处理的部分时重复使用代码的机会。</span><span class="sxs-lookup"><span data-stu-id="a8be5-333">However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.</span></span> <span data-ttu-id="a8be5-334">有关详细信息，请参阅[管道和筛选器模式](../patterns/pipes-and-filters.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-334">For more information, see the [Pipes and Filters pattern](../patterns/pipes-and-filters.md).</span></span>

- <span data-ttu-id="a8be5-335">**管理任务的步骤执行**。</span><span class="sxs-lookup"><span data-stu-id="a8be5-335">**Managing execution of the steps for a task**.</span></span> <span data-ttu-id="a8be5-336">应用程序可以执行包含多个步骤的任务（其中有些步骤可以调用远程服务或访问远程资源）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-336">An application might perform tasks that comprise a number of steps (some of which might invoke remote services or access remote resources).</span></span> <span data-ttu-id="a8be5-337">各个步骤可以彼此独立，但它们由实施任务的应用程序逻辑进行协调。</span><span class="sxs-lookup"><span data-stu-id="a8be5-337">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span> <span data-ttu-id="a8be5-338">有关详细信息，请参阅[计划程序代理监督程序模式](../patterns/scheduler-agent-supervisor.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-338">For more information, see [Scheduler Agent Supervisor pattern](../patterns/scheduler-agent-supervisor.md).</span></span>

- <span data-ttu-id="a8be5-339">**管理失败任务步骤的恢复**。</span><span class="sxs-lookup"><span data-stu-id="a8be5-339">**Managing recovery for task steps that fail**.</span></span> <span data-ttu-id="a8be5-340">如果一个或多个步骤失败，应用程序可能需要撤消一系列步骤执行的工作（所有步骤共同定义了最终一致的操作）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-340">An application might need to undo the work that is performed by a series of steps (which together define an eventually consistent operation) if one or more of the steps fail.</span></span> <span data-ttu-id="a8be5-341">有关详细信息，请参阅[补偿事务模式](../patterns/compensating-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-341">For more information, see the [Compensating Transaction pattern](../patterns/compensating-transaction.md).</span></span>

## <a name="resiliency-considerations"></a><span data-ttu-id="a8be5-342">复原注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-342">Resiliency considerations</span></span>

<span data-ttu-id="a8be5-343">后台任务必须具有复原能力，以便为应用程序提供可靠的服务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-343">Background tasks must be resilient in order to provide reliable services to the application.</span></span> <span data-ttu-id="a8be5-344">规划和设计后台任务时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="a8be5-344">When you are planning and designing background tasks, consider the following points:</span></span>

- <span data-ttu-id="a8be5-345">后台任务必须能够正常应对重启，不会损坏数据，也不会导致应用程序中出现不一致的情况。</span><span class="sxs-lookup"><span data-stu-id="a8be5-345">Background tasks must be able to gracefully handle restarts without corrupting data or introducing inconsistency into the application.</span></span> <span data-ttu-id="a8be5-346">对于长时间运行的任务或多步骤任务，请考虑使用*检查点*，方法是在永久性存储中保存作业状态，或者在队列中将作业状态另存为消息（如果适当）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-346">For long-running or multistep tasks, consider using *check pointing* by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.</span></span> <span data-ttu-id="a8be5-347">例如，可以在队列的消息中永久保存状态信息，并根据任务进度增量更新此状态信息，以便从上次已知正常的检查点处理任务，而不必从头重新开始。</span><span class="sxs-lookup"><span data-stu-id="a8be5-347">For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint--instead of restarting from the beginning.</span></span> <span data-ttu-id="a8be5-348">使用 Azure 服务总线队列时，可以使用消息会话来实现相同的方案。</span><span class="sxs-lookup"><span data-stu-id="a8be5-348">When using Azure Service Bus queues, you can use message sessions to enable the same scenario.</span></span> <span data-ttu-id="a8be5-349">会话允许用户使用 [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) 和 [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) 方法来保存和检索应用程序处理状态。</span><span class="sxs-lookup"><span data-stu-id="a8be5-349">Sessions allow you to save and retrieve the application processing state by using the [SetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) and [GetState](/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) methods.</span></span> <span data-ttu-id="a8be5-350">若要详细了解如何设计可靠的多步骤过程和工作流，请参阅[计划程序代理监督程序模式](../patterns/scheduler-agent-supervisor.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-350">For more information about designing reliable multistep processes and workflows, see the [Scheduler Agent Supervisor pattern](../patterns/scheduler-agent-supervisor.md).</span></span>

- <span data-ttu-id="a8be5-351">使用队列来与后台任务通信时，队列可以充当缓冲区，用于在应用程序超过一般负载时，存储发送给任务的请求。</span><span class="sxs-lookup"><span data-stu-id="a8be5-351">When you use queues to communicate with background tasks, the queues can act as a buffer to store requests that are sent to the tasks while the application is under higher than usual load.</span></span> <span data-ttu-id="a8be5-352">这样，任务便可以在相对空闲期间与 UI 同步。</span><span class="sxs-lookup"><span data-stu-id="a8be5-352">This allows the tasks to catch up with the UI during less busy periods.</span></span> <span data-ttu-id="a8be5-353">这也意味着，重启不会阻止 UI。</span><span class="sxs-lookup"><span data-stu-id="a8be5-353">It also means that restarts will not block the UI.</span></span> <span data-ttu-id="a8be5-354">有关详细信息，请参阅[基于队列的负载调节模式](../patterns/queue-based-load-leveling.md)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-354">For more information, see the [Queue-Based Load Leveling pattern](../patterns/queue-based-load-leveling.md).</span></span> <span data-ttu-id="a8be5-355">如果某些任务比其他任务更重要，请考虑实施[优先级队列模式](../patterns/priority-queue.md)，确保这些任务在较不重要的任务之前运行。</span><span class="sxs-lookup"><span data-stu-id="a8be5-355">If some tasks are more important than others, consider implementing the [Priority Queue pattern](../patterns/priority-queue.md) to ensure that these tasks run before less important ones.</span></span>

- <span data-ttu-id="a8be5-356">必须将消息或进程消息启动的后台任务设计为处理不一致情况，例如消息以错误顺序到达、消息重复导致错误（通常称为*有害消息*）和消息传送多次。</span><span class="sxs-lookup"><span data-stu-id="a8be5-356">Background tasks that are initiated by messages or process messages must be designed to handle inconsistencies, such as messages arriving out of order, messages that repeatedly cause an error (often referred to as *poison messages*), and messages that are delivered more than once.</span></span> <span data-ttu-id="a8be5-357">请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="a8be5-357">Consider the following:</span></span>

  - <span data-ttu-id="a8be5-358">必须按特定顺序处理消息，例如，根据数据的现有数据值更改数据的消息（例如，将值添加到现有值）可能不以其原始发送顺序到达。</span><span class="sxs-lookup"><span data-stu-id="a8be5-358">Messages that must be processed in a specific order, such as those that change data based on the existing data value (for example, adding a value to an existing value), might not arrive in the original order in which they were sent.</span></span> <span data-ttu-id="a8be5-359">或者，可能因为每个实例上的负载不同，后台任务的不同实例按不同的顺序处理消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-359">Alternatively, they might be handled by different instances of a background task in a different order due to varying loads on each instance.</span></span> <span data-ttu-id="a8be5-360">必须按特定顺序处理的消息应该包括序号、键，或者可由后台任务用来确保按正确顺序处理这些消息的其他某个指示器。</span><span class="sxs-lookup"><span data-stu-id="a8be5-360">Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure that they are processed in the correct order.</span></span> <span data-ttu-id="a8be5-361">如果使用 Azure 服务总线，可以使用消息会话来保证传送顺序。</span><span class="sxs-lookup"><span data-stu-id="a8be5-361">If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.</span></span> <span data-ttu-id="a8be5-362">但是，尽可能设计好过程，使消息顺序变得不重要的思路通常更有效率。</span><span class="sxs-lookup"><span data-stu-id="a8be5-362">However, it is usually more efficient, where possible, to design the process so that the message order is not important.</span></span>

  - <span data-ttu-id="a8be5-363">一般而言，后台任务会在队列中扫视消息，这会暂时向其他消息使用者隐藏消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-363">Typically, a background task will peek at messages in the queue, which temporarily hides them from other message consumers.</span></span> <span data-ttu-id="a8be5-364">然后，它会在成功处理消息后，将其删除。</span><span class="sxs-lookup"><span data-stu-id="a8be5-364">Then it deletes the messages after they have been successfully processed.</span></span> <span data-ttu-id="a8be5-365">如果后台任务在处理某个消息时失败，该消息会在扫视超时后重新出现在队列中。</span><span class="sxs-lookup"><span data-stu-id="a8be5-365">If a background task fails when processing a message, that message will reappear on the queue after the peek time-out expires.</span></span> <span data-ttu-id="a8be5-366">该消息由任务的另一个实例处理，或在此实例的下一个处理周期进行处理。</span><span class="sxs-lookup"><span data-stu-id="a8be5-366">It will be processed by another instance of the task or during the next processing cycle of this instance.</span></span> <span data-ttu-id="a8be5-367">如果消息一直导致使用者出错，则会阻止任务、队列，并最终在队列填满时阻止应用程序本身。</span><span class="sxs-lookup"><span data-stu-id="a8be5-367">If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.</span></span> <span data-ttu-id="a8be5-368">因此，请务必在队列中检测并删除有害消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-368">Therefore, it is vital to detect and remove poison messages from the queue.</span></span> <span data-ttu-id="a8be5-369">如果使用 Azure 服务总线，导致出错的消息可以自动或手动移到关联的死信队列。</span><span class="sxs-lookup"><span data-stu-id="a8be5-369">If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.</span></span>

  - <span data-ttu-id="a8be5-370">系统为队列保证*至少一次*传送机制，但队列可能会多次传送同一条消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-370">Queues are guaranteed at *least once* delivery mechanisms, but they might deliver the same message more than once.</span></span> <span data-ttu-id="a8be5-371">此外，如果在处理消息之后、从队列中删除消息之前后台任务失败，消息将可再次处理。</span><span class="sxs-lookup"><span data-stu-id="a8be5-371">In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.</span></span> <span data-ttu-id="a8be5-372">后台任务应该具有幂等性，这意味着多次处理同一条消息不会导致错误，或者使应用程序的数据不一致。</span><span class="sxs-lookup"><span data-stu-id="a8be5-372">Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.</span></span> <span data-ttu-id="a8be5-373">某些操作原生就是幂等的，例如，将存储的值设置为特定的新值。</span><span class="sxs-lookup"><span data-stu-id="a8be5-373">Some operations are naturally idempotent, such as setting a stored value to a specific new value.</span></span> <span data-ttu-id="a8be5-374">但是，有些操作（例如，将值添加到现有的存储值而不检查存储值是否仍与最初发送的消息相同）会导致不一致情况。</span><span class="sxs-lookup"><span data-stu-id="a8be5-374">However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.</span></span> <span data-ttu-id="a8be5-375">可将 Azure 服务总线队列配置为自动删除重复消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-375">Azure Service Bus queues can be configured to automatically remove duplicated messages.</span></span>

  - <span data-ttu-id="a8be5-376">某些消息传送系统（例如 Azure 存储队列和 Azure 服务总线队列）支持用于指示已从队列中读取消息次数的取消排队计数属性。</span><span class="sxs-lookup"><span data-stu-id="a8be5-376">Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.</span></span> <span data-ttu-id="a8be5-377">这在处理重复消息和有害消息时可能很有用。</span><span class="sxs-lookup"><span data-stu-id="a8be5-377">This can be useful in handling repeated and poison messages.</span></span> <span data-ttu-id="a8be5-378">有关详细信息，请参阅[异步消息传送入门](https://msdn.microsoft.com/library/dn589781.aspx)和[幂等模式](https://blog.jonathanoliver.com/idempotency-patterns/)。</span><span class="sxs-lookup"><span data-stu-id="a8be5-378">For more information, see [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/).</span></span>

## <a name="scaling-and-performance-considerations"></a><span data-ttu-id="a8be5-379">缩放和性能注意事项</span><span class="sxs-lookup"><span data-stu-id="a8be5-379">Scaling and performance considerations</span></span>

<span data-ttu-id="a8be5-380">后台任务必须提供足够的性能，确保它们不会阻止应用程序，或者不会因系统负载不足而延迟操作时导致不一致。</span><span class="sxs-lookup"><span data-stu-id="a8be5-380">Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.</span></span> <span data-ttu-id="a8be5-381">通常，可以通过缩放托管后台任务的计算实例来提高性能。</span><span class="sxs-lookup"><span data-stu-id="a8be5-381">Typically, performance is improved by scaling the compute instances that host the background tasks.</span></span> <span data-ttu-id="a8be5-382">规划和设计后台任务时，请注意以下有关伸缩性和性能的要点：</span><span class="sxs-lookup"><span data-stu-id="a8be5-382">When you are planning and designing background tasks, consider the following points around scalability and performance:</span></span>

- <span data-ttu-id="a8be5-383">Azure 根据当前的需求和负载或预定义的计划，支持对 Web 应用和虚拟机托管的部署使用自动缩放（向外缩放和向内缩放）。</span><span class="sxs-lookup"><span data-stu-id="a8be5-383">Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load or on a predefined schedule, for Web Apps and Virtual Machines hosted deployments.</span></span> <span data-ttu-id="a8be5-384">使用此功能可确保整个应用程序具有足够的性能，同时将运行时成本降到最低。</span><span class="sxs-lookup"><span data-stu-id="a8be5-384">Use this feature to ensure that the application as a whole has sufficient performance capabilities while minimizing runtime costs.</span></span>

- <span data-ttu-id="a8be5-385">当后台任务的执行功能不同于应用程序的其他部分（例如，UI 或数据访问层等组件）时，在另一计算服务中将后台任务托管在一起可让 UI 和后台任务单独进行缩放，便于管理负载。</span><span class="sxs-lookup"><span data-stu-id="a8be5-385">Where background tasks have a different performance capability from the other parts of a application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate compute service allows the UI and background tasks to scale independently to manage the load.</span></span> <span data-ttu-id="a8be5-386">如果多个后台任务彼此有明显不同的执行功能，请考虑将它们分割并单独缩放每个类型。</span><span class="sxs-lookup"><span data-stu-id="a8be5-386">If multiple background tasks have significantly different performance capabilities from each other, consider dividing them and scaling each type independently.</span></span> <span data-ttu-id="a8be5-387">但请注意，这可能会增加运行时成本。</span><span class="sxs-lookup"><span data-stu-id="a8be5-387">However, note that this might increase runtime costs.</span></span>

- <span data-ttu-id="a8be5-388">只是缩放计算资源可能不足以防止在相应的负载下损失性能。</span><span class="sxs-lookup"><span data-stu-id="a8be5-388">Simply scaling the compute resources might not be sufficient to prevent loss of performance under load.</span></span> <span data-ttu-id="a8be5-389">还可能需要缩放存储队列和其他资源，以防止整体处理链的单个点变成瓶颈。</span><span class="sxs-lookup"><span data-stu-id="a8be5-389">You might also need to scale storage queues and other resources to prevent a single point of the overall processing chain from becoming a bottleneck.</span></span> <span data-ttu-id="a8be5-390">另外，请考虑其他限制，例如存储的最大吞吐量，以及应用程序的其他服务和后台任务依赖的服务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-390">Also, consider other limitations, such as the maximum throughput of storage and other services that the application and the background tasks rely on.</span></span>

- <span data-ttu-id="a8be5-391">必须针对缩放设计后台任务。</span><span class="sxs-lookup"><span data-stu-id="a8be5-391">Background tasks must be designed for scaling.</span></span> <span data-ttu-id="a8be5-392">例如，后台任务必须能够动态检测正在使用的存储队列数，以侦听相应的队列或向其发送消息。</span><span class="sxs-lookup"><span data-stu-id="a8be5-392">For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.</span></span>

- <span data-ttu-id="a8be5-393">默认情况下，Web 作业会随着其关联的 Azure Web 应用实例进行缩放。</span><span class="sxs-lookup"><span data-stu-id="a8be5-393">By default, WebJobs scale with their associated Azure Web Apps instance.</span></span> <span data-ttu-id="a8be5-394">但是，如果只想要将 Web 作业当作单个实例运行，可以创建包含 JSON 数据 { "is_singleton": true } 的 Settings.job 文件。</span><span class="sxs-lookup"><span data-stu-id="a8be5-394">However, if you want a WebJob to run as only a single instance, you can create a Settings.job file that contains the JSON data **{ "is_singleton": true }**.</span></span> <span data-ttu-id="a8be5-395">这会强制 Azure 只运行 Web 作业的一个实例，即使关联的 Web 应用有多个实例。</span><span class="sxs-lookup"><span data-stu-id="a8be5-395">This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated web app.</span></span> <span data-ttu-id="a8be5-396">对于必须以单个实例运行的计划作业而言，这可能是有用的方法。</span><span class="sxs-lookup"><span data-stu-id="a8be5-396">This can be a useful technique for scheduled jobs that must run as only a single instance.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="a8be5-397">相关模式</span><span class="sxs-lookup"><span data-stu-id="a8be5-397">Related patterns</span></span>

- [<span data-ttu-id="a8be5-398">计算分区指南</span><span class="sxs-lookup"><span data-stu-id="a8be5-398">Compute Partitioning Guidance</span></span>](https://msdn.microsoft.com/library/dn589773.aspx)
