---
title: 后台作业指南
description: 有关独立于用户界面运行的后台任务的指南。
author: dragon119
ms.date: 05/24/2017
pnp.series.title: Best Practices
ms.openlocfilehash: 57fd7a6cc400b53e51e08fb5a1377dce4ae61327
ms.sourcegitcommit: e9eb2b895037da0633ef3ccebdea2fcce047620f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/30/2018
ms.locfileid: "50251917"
---
# <a name="background-jobs"></a><span data-ttu-id="5dcd7-103">后台作业</span><span class="sxs-lookup"><span data-stu-id="5dcd7-103">Background jobs</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="5dcd7-104">许多类型的应用程序需要运行与用户界面 (UI) 无关的后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-104">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="5dcd7-105">示例包括批处理作业、密集处理型任务，以及长时间运行的过程，例如工作流。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-105">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="5dcd7-106">后台作业无需用户交互就可执行 -- 应用程序可以启动作业，并继续处理来自用户的交互请求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-106">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="5dcd7-107">这有助于减少应用程序 UI 上的负载，从而提高可用性，降低交互响应时间。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-107">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

<span data-ttu-id="5dcd7-108">例如，如果应用程序需要生成用户上传的图像缩图，可以后台作业的形式执行此操作，并在完成时会缩图保存到存储中，用户无需等待过程完成。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-108">For example, if an application is required to generate thumbnails of images that are uploaded by users, it can do this as a background job and save the thumbnail to storage when it is complete--without the user needing to wait for the process to be completed.</span></span> <span data-ttu-id="5dcd7-109">同样地，下单的用户可以启动一个后台工作流来处理订单，同时，UI 可让用户继续浏览 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-109">In the same way, a user placing an order can initiate a background workflow that processes the order, while the UI allows the user to continue browsing the web app.</span></span> <span data-ttu-id="5dcd7-110">当后台作业完成时，可以更新存储的订单数据，并将确认订单的电子邮件发送给用户。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-110">When the background job is complete, it can update the stored orders data and send an email to the user that confirms the order.</span></span>

<span data-ttu-id="5dcd7-111">考虑是否将任务作为后台作业执行时，主要的准则是：是否可以在无需用户交互的情况下运行该任务，且 UI 无需等待作业完成。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-111">When you consider whether to implement a task as a background job, the main criteria is whether the task can run without user interaction and without the UI needing to wait for the job to be completed.</span></span> <span data-ttu-id="5dcd7-112">在完成之前需要用户或 UI 等待的任务不适合作为后台作业运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-112">Tasks that require the user or the UI to wait while they are completed might not be appropriate as background jobs.</span></span>

## <a name="types-of-background-jobs"></a><span data-ttu-id="5dcd7-113">后台作业的类型</span><span class="sxs-lookup"><span data-stu-id="5dcd7-113">Types of background jobs</span></span>
<span data-ttu-id="5dcd7-114">后台作业通常包括以下类型的一个或多个作业：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-114">Background jobs typically include one or more of the following types of jobs:</span></span>

* <span data-ttu-id="5dcd7-115">CPU 密集型作业，例如数学计算或结构模型分析。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-115">CPU-intensive jobs, such as mathematical calculations or structural model analysis.</span></span>
* <span data-ttu-id="5dcd7-116">I/O 密集型作业，例如执行一系列存储事务或文件索引编制。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-116">I/O-intensive jobs, such as executing a series of storage transactions or indexing files.</span></span>
* <span data-ttu-id="5dcd7-117">批处理作业，例如夜间数据更新或计划的处理。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-117">Batch jobs, such as nightly data updates or scheduled processing.</span></span>
* <span data-ttu-id="5dcd7-118">长时间运行的工作流，例如订单履行或预配服务和系统。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-118">Long-running workflows, such as order fulfillment, or provisioning services and systems.</span></span>
* <span data-ttu-id="5dcd7-119">敏感数据处理，其中的任务将转移到更安全的位置以进行处理。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-119">Sensitive-data processing where the task is handed off to a more secure location for processing.</span></span> <span data-ttu-id="5dcd7-120">例如，可能不希望处理 Web 应用中的敏感数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-120">For example, you might not want to process sensitive data within a web app.</span></span> <span data-ttu-id="5dcd7-121">而想使用[守护程序](https://msdn.microsoft.com/library/dn589793.aspx)等模式将数据传输到有权访问受保护存储的已隔离后台进程。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-121">Instead, you might use a pattern such as [Gatekeeper](https://msdn.microsoft.com/library/dn589793.aspx) to transfer the data to an isolated background process that has access to protected storage.</span></span>

## <a name="triggers"></a><span data-ttu-id="5dcd7-122">触发器</span><span class="sxs-lookup"><span data-stu-id="5dcd7-122">Triggers</span></span>
<span data-ttu-id="5dcd7-123">可通过多种不同的方式启动后台作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-123">Background jobs can be initiated in several different ways.</span></span> <span data-ttu-id="5dcd7-124">这些方式属于以下类别之一：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-124">They fall into one of the following categories:</span></span>

* <span data-ttu-id="5dcd7-125">[事件驱动的触发器](#event-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-125">[**Event-driven triggers**](#event-driven-triggers).</span></span> <span data-ttu-id="5dcd7-126">响应事件时启动任务，这通常是用户或工作流中的步骤执行的操作。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-126">The task is started in response to an event, typically an action taken by a user or a step in a workflow.</span></span>
* <span data-ttu-id="5dcd7-127">[计划驱动的触发器](#schedule-driven-triggers)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-127">[**Schedule-driven triggers**](#schedule-driven-triggers).</span></span> <span data-ttu-id="5dcd7-128">基于计时器按计划调用任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-128">The task is invoked on a schedule based on a timer.</span></span> <span data-ttu-id="5dcd7-129">这可能是定期计划，或者指定在以后运行的一次性调用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-129">This might be a recurring schedule or a one-off invocation that is specified for a later time.</span></span>

### <a name="event-driven-triggers"></a><span data-ttu-id="5dcd7-130">事件驱动的触发器</span><span class="sxs-lookup"><span data-stu-id="5dcd7-130">Event-driven triggers</span></span>
<span data-ttu-id="5dcd7-131">事件驱动的调用使用触发器来启动后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-131">Event-driven invocation uses a trigger to start the background task.</span></span> <span data-ttu-id="5dcd7-132">使用事件驱动的触发器的示例包括：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-132">Examples of using event-driven triggers include:</span></span>

* <span data-ttu-id="5dcd7-133">UI 或另一个作业将消息放入队列。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-133">The UI or another job places a message in a queue.</span></span> <span data-ttu-id="5dcd7-134">该消息包含有关已执行的操作的数据，例如下单的用户。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-134">The message contains data about an action that has taken place, such as the user placing an order.</span></span> <span data-ttu-id="5dcd7-135">后台任务将侦听此队列，并检测新消息是否已到达。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-135">The background task listens on this queue and detects the arrival of a new message.</span></span> <span data-ttu-id="5dcd7-136">它将读取消息，并将其中的数据用作后台作业的输入。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-136">It reads the message and uses the data in it as the input to the background job.</span></span>
* <span data-ttu-id="5dcd7-137">UI 或另一个作业将保存或更新存储中的值。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-137">The UI or another job saves or updates a value in storage.</span></span> <span data-ttu-id="5dcd7-138">后台任务将监视存储并检测更改。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-138">The background task monitors the storage and detects changes.</span></span> <span data-ttu-id="5dcd7-139">它将读取数据，并将数据用作后台作业的输入。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-139">It reads the data and uses it as the input to the background job.</span></span>
* <span data-ttu-id="5dcd7-140">UI 或另一个作业向终结点（例如 HTTPS URI，或作为 Web 服务公开的 API）发出请求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-140">The UI or another job makes a request to an endpoint, such as an HTTPS URI, or an API that is exposed as a web service.</span></span> <span data-ttu-id="5dcd7-141">它在请求的过程中传递所需的数据以完成后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-141">It passes the data that is required to complete the background task as part of the request.</span></span> <span data-ttu-id="5dcd7-142">终结点或 Web 服务调用后台任务，将数据用作其输入。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-142">The endpoint or web service invokes the background task, which uses the data as its input.</span></span>

<span data-ttu-id="5dcd7-143">适合事件驱动调用的任务的典型示例包括图像处理、工作流、将信息发送到远程服务、发送电子邮件消息，以及在多租户应用程序中预配新用户。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-143">Typical examples of tasks that are suited to event-driven invocation include image processing, workflows, sending information to remote services, sending email messages, and provisioning new users in multitenant applications.</span></span>

### <a name="schedule-driven-triggers"></a><span data-ttu-id="5dcd7-144">计划驱动的触发器</span><span class="sxs-lookup"><span data-stu-id="5dcd7-144">Schedule-driven triggers</span></span>
<span data-ttu-id="5dcd7-145">计划驱动的调用使用计时器启动后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-145">Schedule-driven invocation uses a timer to start the background task.</span></span> <span data-ttu-id="5dcd7-146">使用计划驱动的触发器的示例包括：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-146">Examples of using schedule-driven triggers include:</span></span>

* <span data-ttu-id="5dcd7-147">在应用程序本地运行的计时器或作为应用程序操作系统一部分的计时器定期调用后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-147">A timer that is running locally within the application or as part of the application’s operating system invokes a background task on a regular basis.</span></span>
* <span data-ttu-id="5dcd7-148">在不同应用程序中运行的计时器或计时器服务（例如 Azure 计划程序）定期将请求发送到 API 或 Web 服务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-148">A timer that is running in a different application, or a timer service such as Azure Scheduler, sends a request to an API or web service on a regular basis.</span></span> <span data-ttu-id="5dcd7-149">API 或 Web 服务调用后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-149">The API or web service invokes the background task.</span></span>
* <span data-ttu-id="5dcd7-150">单独的进程或应用程序启动计时器，从而在指定的时间延迟后或在特定时间调用后台任务一次。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-150">A separate process or application starts a timer that causes the background task to be invoked once after a specified time delay, or at a specific time.</span></span>

<span data-ttu-id="5dcd7-151">适合计划驱动调用的任务的典型示例包括批处理例程（例如，根据用户最新的行为来更新其相关产品列表）、例行数据处理任务（例如更新索引或生成累积结果）、分析每日报告的数据、清理保留的数据和数据一致性检查。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-151">Typical examples of tasks that are suited to schedule-driven invocation include batch-processing routines (such as updating related-products lists for users based on their recent behavior), routine data processing tasks (such as updating indexes or generating accumulated results), data analysis for daily reports, data retention cleanup, and data consistency checks.</span></span>

<span data-ttu-id="5dcd7-152">如果使用必须作为单个实例运行的计划驱动任务，请注意以下事项：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-152">If you use a schedule-driven task that must run as a single instance, be aware of the following:</span></span>

* <span data-ttu-id="5dcd7-153">如果缩放正在运行计划程序的计算实例（例如使用 Windows 计划任务的虚拟机），需要运行计划程序的多个实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-153">If the compute instance that is running the scheduler (such as a virtual machine using Windows scheduled tasks) is scaled, you will have multiple instances of the scheduler running.</span></span> <span data-ttu-id="5dcd7-154">这些操作可能会启动任务的多个实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-154">These could start multiple instances of the task.</span></span>
* <span data-ttu-id="5dcd7-155">如果任务的运行时间超过了计划程序事件的间隔时间，计划程序可以在前一个任务仍在运行时启动任务的另一个实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-155">If tasks run for longer than the period between scheduler events, the scheduler may start another instance of the task while the previous one is still running.</span></span>

## <a name="returning-results"></a><span data-ttu-id="5dcd7-156">返回结果</span><span class="sxs-lookup"><span data-stu-id="5dcd7-156">Returning results</span></span>
<span data-ttu-id="5dcd7-157">后台作业通过 UI 或调用后台任务的进程，以异步方式在独立进程甚至不同的位置运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-157">Background jobs execute asynchronously in a separate process, or even in a separate location, from the UI or the process that invoked the background task.</span></span> <span data-ttu-id="5dcd7-158">在理想情况下，后台任务是“即发即弃”的操作，其执行进度不会影响 UI 或调用进程。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-158">Ideally, background tasks are “fire and forget” operations, and their execution progress has no impact on the UI or the calling process.</span></span> <span data-ttu-id="5dcd7-159">这意味着，调用进程不会等待任务完成。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-159">This means that the calling process does not wait for completion of the tasks.</span></span> <span data-ttu-id="5dcd7-160">因此无法自动检测任务的结束时间。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-160">Therefore, it cannot automatically detect when the task ends.</span></span>

<span data-ttu-id="5dcd7-161">如果需要后台任务与调用任务通信以指示进度或完成状态，则必须为此实施一种机制。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-161">If you require a background task to communicate with the calling task to indicate progress or completion, you must implement a mechanism for this.</span></span> <span data-ttu-id="5dcd7-162">下面是一些示例：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-162">Some examples are:</span></span>

* <span data-ttu-id="5dcd7-163">将状态指示器值写入可供 UI 或调用方任务访问的存储，这样可以在需要时监视或检查此值。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-163">Write a status indicator value to storage that is accessible to the UI or caller task, which can monitor or check this value when required.</span></span> <span data-ttu-id="5dcd7-164">可将后台任务必须返回给调用方的数据放入同一存储中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-164">Other data that the background task must return to the caller can be placed into the same storage.</span></span>
* <span data-ttu-id="5dcd7-165">建立 UI 或调用方侦听的答复队列。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-165">Establish a reply queue that the UI or caller listens on.</span></span> <span data-ttu-id="5dcd7-166">后台任务可将消息发送到指示状态和完成情况的队列。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-166">The background task can send messages to the queue that indicate status and completion.</span></span> <span data-ttu-id="5dcd7-167">可将后台任务必须返回给调用方的数据放入消息中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-167">Data that the background task must return to the caller can be placed into the messages.</span></span> <span data-ttu-id="5dcd7-168">如果使用 Azure 服务总线，则可以使用 **ReplyTo** 和 **CorrelationId** 属性来实现此功能。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-168">If you are using Azure Service Bus, you can use the **ReplyTo** and **CorrelationId** properties to implement this capability.</span></span>
* <span data-ttu-id="5dcd7-169">从 UI 或调用方可以访问的后台任务公开 API 或终结点以获取状态信息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-169">Expose an API or endpoint from the background task that the UI or caller can access to obtain status information.</span></span> <span data-ttu-id="5dcd7-170">可以在响应中包含后台任务必须返回给调用方的数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-170">Data that the background task must return to the caller can be included in the response.</span></span>
* <span data-ttu-id="5dcd7-171">让后台任务通过 API 回调 UI 或调用方，以指示预定义时间点或完成时的状态。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-171">Have the background task call back to the UI or caller through an API to indicate status at predefined points or on completion.</span></span> <span data-ttu-id="5dcd7-172">这可以通过本地引发的事件或通过发布与订阅机制来实现。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-172">This might be through events raised locally or through a publish-and-subscribe mechanism.</span></span> <span data-ttu-id="5dcd7-173">可在请求或事件负载中包含后台任务必须返回给调用方的数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-173">Data that the background task must return to the caller can be included in the request or event payload.</span></span>

## <a name="hosting-environment"></a><span data-ttu-id="5dcd7-174">宿主环境</span><span class="sxs-lookup"><span data-stu-id="5dcd7-174">Hosting environment</span></span>
<span data-ttu-id="5dcd7-175">可以使用各种不同的 Azure 平台服务来托管后台任务：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-175">You can host background tasks by using a range of different Azure platform services:</span></span>

* <span data-ttu-id="5dcd7-176">[**Azure Web 应用和 Web 作业**](#azure-web-apps-and-webjobs)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-176">[**Azure Web Apps and WebJobs**](#azure-web-apps-and-webjobs).</span></span> <span data-ttu-id="5dcd7-177">可以根据 Web 应用上下文中各种不同类型的脚本或可执行程序，使用 Web 作业来执行自定义作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-177">You can use WebJobs to execute custom jobs based on a range of different types of scripts or executable programs within the context of a web app.</span></span>
* <span data-ttu-id="5dcd7-178">[Azure 虚拟机](#azure-virtual-machines)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-178">[**Azure Virtual Machines**](#azure-virtual-machines).</span></span> <span data-ttu-id="5dcd7-179">如果有 Windows 服务或想要使用 Windows 任务计划程序，则常见的做法是将后台任务托管在专用虚拟机中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-179">If you have a Windows service or want to use the Windows Task Scheduler, it is common to host your background tasks within a dedicated virtual machine.</span></span>
* <span data-ttu-id="5dcd7-180">[Azure Batch](#azure-batch)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-180">[**Azure Batch**](#azure-batch).</span></span> <span data-ttu-id="5dcd7-181">Batch 是一种平台服务，该服务计划在虚拟机托管集合上运行的计算密集型工作。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-181">Batch is a platform service that schedules compute-intensive work to run on a managed collection of virtual machines.</span></span> <span data-ttu-id="5dcd7-182">它可以自动缩放计算资源。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-182">It can automatically scale compute resources.</span></span>
* <span data-ttu-id="5dcd7-183">[Azure 容器服务](#azure-container-service)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-183">[**Azure Container Service**](#azure-container-service).</span></span> <span data-ttu-id="5dcd7-184">Azure 容器服务在 Azure 上提供容器托管环境。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-184">Azure Container Service provides a container hosting environment on Azure.</span></span> 
* <span data-ttu-id="5dcd7-185">[Azure 云服务](#azure-cloud-services)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-185">[**Azure Cloud Services**](#azure-cloud-services).</span></span> <span data-ttu-id="5dcd7-186">可以在作为后台任务执行的角色中编写代码。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-186">You can write code within a role that executes as a background task.</span></span>

<span data-ttu-id="5dcd7-187">以下各节详细介绍每一个选项，并提供相关注意事项，帮助你选择适当的选项。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-187">The following sections describe each of these options in more detail, and include considerations to help you choose the appropriate option.</span></span>

### <a name="azure-web-apps-and-webjobs"></a><span data-ttu-id="5dcd7-188">Azure Web 应用和 Web 作业</span><span class="sxs-lookup"><span data-stu-id="5dcd7-188">Azure Web Apps and WebJobs</span></span>

<span data-ttu-id="5dcd7-189">可以使用 Azure Web 作业将自定义作业作为 Azure Web 应用中的后台任务来执行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-189">You can use Azure WebJobs to execute custom jobs as background tasks within an Azure Web App.</span></span> <span data-ttu-id="5dcd7-190">Web 作业可在 Web 应用的上下文中作为连续进程运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-190">WebJobs run within the context of your web app as a continuous process.</span></span> <span data-ttu-id="5dcd7-191">Web 作业还可以在响应来自 Azure 计划程序或外部因素（例如更改存储 Blob 和消息队列）的触发器事件时运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-191">WebJobs also run in response to a trigger event from Azure Scheduler or external factors, such as changes to storage blobs and message queues.</span></span> <span data-ttu-id="5dcd7-192">作业可按需启动和停止，并可以正常关闭。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-192">Jobs can be started and stopped on demand, and shut down gracefully.</span></span> <span data-ttu-id="5dcd7-193">如果连续运行的 Web 作业失败，它会自动重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-193">If a continuously running WebJob fails, it is automatically restarted.</span></span> <span data-ttu-id="5dcd7-194">重试和错误操作可配置。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-194">Retry and error actions are configurable.</span></span>

<span data-ttu-id="5dcd7-195">配置 Web 作业时：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-195">When you configure a WebJob:</span></span>

* <span data-ttu-id="5dcd7-196">如果想要作业响应事件驱动的触发器，应将其配置为“连续运行”。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-196">If you want the job to respond to an event-driven trigger, you should configure it as **Run continuously**.</span></span> <span data-ttu-id="5dcd7-197">脚本或进程存储在名为 site/wwwroot/app_data/jobs/continuous 的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-197">The script or program is stored in the folder named site/wwwroot/app_data/jobs/continuous.</span></span>
* <span data-ttu-id="5dcd7-198">如果想要作业响应计划驱动的触发器，应将其配置为“按计划运行”。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-198">If you want the job to respond to a schedule-driven trigger, you should configure it as **Run on a schedule**.</span></span> <span data-ttu-id="5dcd7-199">脚本或进程存储在名为 site/wwwroot/app_data/jobs/triggered 的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-199">The script or program is stored in the folder named site/wwwroot/app_data/jobs/triggered.</span></span>
* <span data-ttu-id="5dcd7-200">如果在配置作业时选择了“按需要运行”选项，在启动时，该作业将执行选择了“按计划运行”选项时的相同代码。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-200">If you choose the **Run on demand** option when you configure a job, it will execute the same code as the **Run on a schedule** option when you start it.</span></span>

<span data-ttu-id="5dcd7-201">Azure Web 作业在 Web 应用沙箱中运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-201">Azure WebJobs run within the sandbox of the web app.</span></span> <span data-ttu-id="5dcd7-202">这意味着，它们可以访问环境变量，并与 Web 应用共享连接字符串等信息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-202">This means that they can access environment variables and share information, such as connection strings, with the web app.</span></span> <span data-ttu-id="5dcd7-203">作业有权访问运行该作业的计算机的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-203">The job has access to the unique identifier of the machine that is running the job.</span></span> <span data-ttu-id="5dcd7-204">名为 **AzureWebJobsStorage** 的连接字符串可用于访问应用程序数据的 Azure 存储队列、Blob 和表，以及用于消息传送和通信的服务总线。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-204">The connection string named **AzureWebJobsStorage** provides access to Azure storage queues, blobs, and tables for application data, and access to Service Bus for messaging and communication.</span></span> <span data-ttu-id="5dcd7-205">名为 **AzureWebJobsDashboard** 的连接字符串可用于访问作业操作日志文件。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-205">The connection string named **AzureWebJobsDashboard** provides access to the job action log files.</span></span>

<span data-ttu-id="5dcd7-206">Azure Web 作业具有以下特征：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-206">Azure WebJobs have the following characteristics:</span></span>

* <span data-ttu-id="5dcd7-207">**安全性**：Web 作业受 Web 应用的部署凭据保护。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-207">**Security**: WebJobs are protected by the deployment credentials of the web app.</span></span>
* <span data-ttu-id="5dcd7-208">**支持的文件类型**：可以使用命令脚本 (.cmd)、批处理文件 (.bat)、PowerShell 脚本 (.ps1)、bash shell 脚本 (.sh)、PHP 脚本 (.php)、Python 脚本 (.py)、JavaScript 代码 (.js) 和可执行程序（.exe、.jar 等等）来定义 Web 作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-208">**Supported file types**: You can define WebJobs by using command scripts (.cmd), batch files (.bat), PowerShell scripts (.ps1), bash shell scripts (.sh), PHP scripts (.php), Python scripts (.py), JavaScript code (.js), and executable programs (.exe, .jar, and more).</span></span>
* <span data-ttu-id="5dcd7-209">**部署**：可以使用 [Azure 门户](/azure/app-service-web/web-sites-create-web-jobs)、[Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs)、[Azure Web 作业 SDK](/azure/app-service/webjobs-sdk-get-started) 或直接将它们复制到以下位置以部署脚本和可执行文件：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-209">**Deployment**: You can deploy scripts and executables by using the [Azure portal](/azure/app-service-web/web-sites-create-web-jobs), by using [Visual Studio](/azure/app-service-web/websites-dotnet-deploy-webjobs), by using the [Azure WebJobs SDK](/azure/app-service/webjobs-sdk-get-started), or by copying them directly to the following locations:</span></span>
  * <span data-ttu-id="5dcd7-210">对于触发的执行：site/wwwroot/app_data/jobs/triggered/{job name}</span><span class="sxs-lookup"><span data-stu-id="5dcd7-210">For triggered execution: site/wwwroot/app_data/jobs/triggered/{job name}</span></span>
  * <span data-ttu-id="5dcd7-211">对于连续执行：site/wwwroot/app_data/jobs/continuous/{job name}</span><span class="sxs-lookup"><span data-stu-id="5dcd7-211">For continuous execution: site/wwwroot/app_data/jobs/continuous/{job name}</span></span>
* <span data-ttu-id="5dcd7-212">**日志记录**：Console.Out 被视为（标记为）INFO。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-212">**Logging**: Console.Out is treated (marked) as INFO.</span></span> <span data-ttu-id="5dcd7-213">Console.Error 被视为 ERROR。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-213">Console.Error is treated as ERROR.</span></span> <span data-ttu-id="5dcd7-214">可以使用 Azure 门户来访问监视和诊断信息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-214">You can access monitoring and diagnostics information by using the Azure portal.</span></span> <span data-ttu-id="5dcd7-215">可以直接从站点下载日志文件。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-215">You can download log files directly from the site.</span></span> <span data-ttu-id="5dcd7-216">这些信息保存在以下位置：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-216">They are saved in the following locations:</span></span>
  * <span data-ttu-id="5dcd7-217">对于触发的执行：Vfs/data/jobs/triggered/jobName</span><span class="sxs-lookup"><span data-stu-id="5dcd7-217">For triggered execution: Vfs/data/jobs/triggered/jobName</span></span>
  * <span data-ttu-id="5dcd7-218">对于连续执行：Vfs/data/jobs/continuous/jobName</span><span class="sxs-lookup"><span data-stu-id="5dcd7-218">For continuous execution: Vfs/data/jobs/continuous/jobName</span></span>
* <span data-ttu-id="5dcd7-219">**配置**：可以使用门户、REST API 和 PowerShell 配置 Web 作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-219">**Configuration**: You can configure WebJobs by using the portal, the REST API, and PowerShell.</span></span> <span data-ttu-id="5dcd7-220">可以使用与作业脚本位于同一根目录的配置文件（名为 settings.job）来提供作业的配置信息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-220">You can use a configuration file named settings.job in the same root directory as the job script to provide configuration information for a job.</span></span> <span data-ttu-id="5dcd7-221">例如：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-221">For example:</span></span>
  * <span data-ttu-id="5dcd7-222">{ "stopping_wait_time": 60 }</span><span class="sxs-lookup"><span data-stu-id="5dcd7-222">{ "stopping_wait_time": 60 }</span></span>
  * <span data-ttu-id="5dcd7-223">{ "is_singleton": true }</span><span class="sxs-lookup"><span data-stu-id="5dcd7-223">{ "is_singleton": true }</span></span>

#### <a name="considerations"></a><span data-ttu-id="5dcd7-224">注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-224">Considerations</span></span>

* <span data-ttu-id="5dcd7-225">默认情况下，Web 作业会随 Web 应用缩放。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-225">By default, WebJobs scale with the web app.</span></span> <span data-ttu-id="5dcd7-226">但是，可以通过将 **is_singleton** 配置属性设置为 **true**，将作业配置为在单个实例上运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-226">However, you can configure jobs to run on single instance by setting the **is_singleton** configuration property to **true**.</span></span> <span data-ttu-id="5dcd7-227">单个实例 Web 作业适用于不希望以同时进行多个实例的方式进行缩放或运行的任务（如重建索引、数据分析和类似任务）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-227">Single instance WebJobs are useful for tasks that you do not want to scale or run as simultaneous multiple instances, such as reindexing, data analysis, and similar tasks.</span></span>
* <span data-ttu-id="5dcd7-228">要将 Web 应用性能对任务的影响降到最低，请考虑在新的应用服务计划中创建空的 Azure Web 应用，以托管可能长时间运行或资源密集型的 Web 作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-228">To minimize the impact of jobs on the performance of the web app, consider creating an empty Azure Web App instance in a new App Service plan to host WebJobs that may be long running or resource intensive.</span></span>

### <a name="more-information"></a><span data-ttu-id="5dcd7-229">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-229">More information</span></span>
* <span data-ttu-id="5dcd7-230">[有关 Azure Web 作业的推荐资源](/azure/app-service-web/websites-webjobs-resources)列出了 Web 作业的许多有用资源、下载内容和示例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-230">[Azure WebJobs recommended resources](/azure/app-service-web/websites-webjobs-resources) lists the many useful resources, downloads, and samples for WebJobs.</span></span>

### <a name="azure-virtual-machines"></a><span data-ttu-id="5dcd7-231">Azure 虚拟机</span><span class="sxs-lookup"><span data-stu-id="5dcd7-231">Azure Virtual Machines</span></span>
<span data-ttu-id="5dcd7-232">实施后台任务时，可以避免将其部署到 Azure Web 应用或云服务，但有时这些选项可能不方便。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-232">Background tasks might be implemented in a way that prevents them from being deployed to Azure Web Apps or Cloud Services, or these options might not be convenient.</span></span> <span data-ttu-id="5dcd7-233">典型的示例包括 Windows 服务、第三方实用程序和可执行程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-233">Typical examples are Windows services, and third-party utilities and executable programs.</span></span> <span data-ttu-id="5dcd7-234">另一个示例是针对托管应用程序以外的执行环境所编写的程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-234">Another example might be programs written for an execution environment that is different than that hosting the application.</span></span> <span data-ttu-id="5dcd7-235">例如，它可能是你想要从 Windows 或 .NET 应用程序执行的 Unix 或 Linux 程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-235">For example, it might be a Unix or Linux program that you want to execute from a Windows or .NET application.</span></span> <span data-ttu-id="5dcd7-236">可以为 Azure 虚拟机选择各种操作系统，并在该虚拟机上运行服务或可执行文件。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-236">You can choose from a range of operating systems for an Azure virtual machine, and run your service or executable on that virtual machine.</span></span>

<span data-ttu-id="5dcd7-237">若要确定何时使用虚拟机，请参阅 [Azure 应用服务s, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/)（Azure 应用程序服务、云服务和虚拟机的比较）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-237">To help you choose when to use Virtual Machines, see [Azure App Services, Cloud Services and Virtual Machines comparison](/azure/app-service-web/choose-web-site-cloud-service-vm/).</span></span> <span data-ttu-id="5dcd7-238">有关虚拟机选项的信息，请参阅 [Azure 中的 Windows 虚拟机大小](/azure/virtual-machines/windows/sizes)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-238">For information about the options for Virtual Machines, see [Sizes for Windows virtual machines in Azure](/azure/virtual-machines/windows/sizes).</span></span> <span data-ttu-id="5dcd7-239">有关虚拟机可用的操作系统和预建映像的详细信息，请参阅 [Azure 虚拟机市场](https://azure.microsoft.com/gallery/virtual-machines/)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-239">For more information about the operating systems and prebuilt images that are available for Virtual Machines, see [Azure Virtual Machines Marketplace](https://azure.microsoft.com/gallery/virtual-machines/).</span></span>

<span data-ttu-id="5dcd7-240">若要在独立的虚拟机中启动后台任务，可以从多个选项中进行选择：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-240">To initiate the background task in a separate virtual machine, you have a range of options:</span></span>

* <span data-ttu-id="5dcd7-241">可以通过将请求发送到任务公开的终结点，来根据需要直接从应用程序执行任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-241">You can execute the task on demand directly from your application by sending a request to an endpoint that the task exposes.</span></span> <span data-ttu-id="5dcd7-242">这会传入任务所需的任何数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-242">This passes in any data that the task requires.</span></span> <span data-ttu-id="5dcd7-243">此终结点将调用该任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-243">This endpoint invokes the task.</span></span>
* <span data-ttu-id="5dcd7-244">可以将任务配置为使用所选操作系统中提供的计划程序或计时器按计划运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-244">You can configure the task to run on a schedule by using a scheduler or timer that is available in your chosen operating system.</span></span> <span data-ttu-id="5dcd7-245">例如，可以在 Windows 上使用 Windows 任务计划程序来执行脚本和任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-245">For example, on Windows you can use Windows Task Scheduler to execute scripts and tasks.</span></span> <span data-ttu-id="5dcd7-246">或者，如果已在虚拟机上安装了 SQL Server，则可以使用 SQL Server 代理来执行脚本和任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-246">Or, if you have SQL Server installed on the virtual machine, you can use the SQL Server Agent to execute scripts and tasks.</span></span>
* <span data-ttu-id="5dcd7-247">可以使用 Azure 计划程序来启动任务，方法是将消息添加到任务侦听的队列，或将请求发送到任务公开的 API。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-247">You can use Azure Scheduler to initiate the task by adding a message to a queue that the task listens on, or by sending a request to an API that the task exposes.</span></span>

<span data-ttu-id="5dcd7-248">有关如何启动后台任务的详细信息，请参阅前面的[触发器](#triggers)部分。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-248">See the earlier section [Triggers](#triggers) for more information about how you can initiate background tasks.</span></span>  

#### <a name="considerations"></a><span data-ttu-id="5dcd7-249">注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-249">Considerations</span></span>
<span data-ttu-id="5dcd7-250">在确定是否要在 Azure 虚拟机中部署后台任务时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-250">Consider the following points when you are deciding whether to deploy background tasks in an Azure virtual machine:</span></span>

* <span data-ttu-id="5dcd7-251">在单独的 Azure 虚拟机中托管后台任务可提供弹性，并可通过启动、执行、计划和资源分配来实现精确控制。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-251">Hosting background tasks in a separate Azure virtual machine provides flexibility and allows precise control over initiation, execution, scheduling, and resource allocation.</span></span> <span data-ttu-id="5dcd7-252">但是，如果只是出于运行后台任务的目的而必须部署虚拟机，则会增加运行时成本。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-252">However, it will increase runtime cost if a virtual machine must be deployed just to run background tasks.</span></span>
* <span data-ttu-id="5dcd7-253">没有任何工具可以监视 Azure 门户中的任务，并且对于失败的任务没有任何自动重新启动功能 -- 不过，用户可以监视虚拟机的基本状态，并使用[Azure 资源管理器 Cmdlet](https://msdn.microsoft.com/library/mt125356.aspx) 来管理它。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-253">There is no facility to monitor the tasks in the Azure portal and no automated restart capability for failed tasks--although you can monitor the basic status of the virtual machine and manage it by using the  [Azure Resource Manager Cmdlets](https://msdn.microsoft.com/library/mt125356.aspx).</span></span> <span data-ttu-id="5dcd7-254">但是，计算节点中没有任何工具可用于控制进程和线程。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-254">However, there are no facilities to control processes and threads in compute nodes.</span></span> <span data-ttu-id="5dcd7-255">通常，使用虚拟机时，需要付出额外的工作量才能实施一个机制用于从任务的检测中收集数据，以及从虚拟机中的操作系统收集数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-255">Typically, using a virtual machine will require additional effort to implement a mechanism that collects data from instrumentation in the task, and from the operating system in the virtual machine.</span></span> <span data-ttu-id="5dcd7-256">一个适当的解决方案是使用 [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013)（用于 Azure 的 System Center 管理包）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-256">One solution that might be appropriate is to use the [System Center Management Pack for Azure](https://www.microsoft.com/download/details.aspx?id=50013).</span></span>
* <span data-ttu-id="5dcd7-257">可以考虑创建通过 HTTP 终结点公开的监视探测。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-257">You might consider creating monitoring probes that are exposed through HTTP endpoints.</span></span> <span data-ttu-id="5dcd7-258">这些探测器的代码可以执行运行状况检查、收集操作信息和统计信息，或者整理错误信息，并将其返回给管理应用程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-258">The code for these probes could perform health checks, collect operational information and statistics--or collate error information and return it to a management application.</span></span> <span data-ttu-id="5dcd7-259">有关详细信息，请参阅[运行状况终结点监视模式](../patterns/health-endpoint-monitoring.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-259">For more information, see [Health Endpoint Monitoring Pattern](../patterns/health-endpoint-monitoring.md).</span></span>

#### <a name="more-information"></a><span data-ttu-id="5dcd7-260">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-260">More information</span></span>
* <span data-ttu-id="5dcd7-261">Azure 上的[虚拟机](https://azure.microsoft.com/services/virtual-machines/)</span><span class="sxs-lookup"><span data-stu-id="5dcd7-261">[Virtual Machines](https://azure.microsoft.com/services/virtual-machines/) on Azure</span></span>
* [<span data-ttu-id="5dcd7-262">Azure 虚拟机常见问题解答</span><span class="sxs-lookup"><span data-stu-id="5dcd7-262">Azure Virtual Machines FAQ</span></span>](/azure/virtual-machines/virtual-machines-linux-classic-faq?toc=%2fazure%2fvirtual-machines%2flinux%2fclassic%2ftoc.json)

### <a name="azure-batch"></a><span data-ttu-id="5dcd7-263">Azure 批处理</span><span class="sxs-lookup"><span data-stu-id="5dcd7-263">Azure Batch</span></span> 

<span data-ttu-id="5dcd7-264">如果需要在数十、数百或数千个 VM 上运行大型、并行的高性能计算 (HPC) 工作负载，请考虑使用 [Azure Batch](/azure/batch/)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-264">Consider [Azure Batch](/azure/batch/) if you need to run large, parallel high-performance computing (HPC) workloads across tens, hundreds, or thousands of VMs.</span></span>  

<span data-ttu-id="5dcd7-265">Batch 服务预配 VM、将任务分配给 VM、运行任务并监视进度。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-265">The Batch service provisions the VMs, assign tasks to the VMs, runs the tasks, and monitors the progress.</span></span> <span data-ttu-id="5dcd7-266">Batch 可以根据工作负载横向扩展 VM。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-266">Batch can automatically scale out the VMs in response to the workload.</span></span> <span data-ttu-id="5dcd7-267">Batch 还提供作业计划。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-267">Batch also provides job scheduling.</span></span> <span data-ttu-id="5dcd7-268">Azure Batch 支持 Linux 和 Windows VM。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-268">Azure Batch supports both Linux and Windows VMs.</span></span>

#### <a name="considerations"></a><span data-ttu-id="5dcd7-269">注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-269">Considerations</span></span> 

<span data-ttu-id="5dcd7-270">Batch 在固有并行的工作负载上运行良好。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-270">Batch works well with intrinsically parallel workloads.</span></span> <span data-ttu-id="5dcd7-271">它还可执行并行计算（最后有一个减少单步执行），或者为需要在节点间传递的消息的并行任务，运行[消息传递接口 (MPI) 应用程序](/azure/batch/batch-mpi)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-271">It can also perform parallel calculations with a reduce step at the end, or run [Message Passing Interface (MPI) applications](/azure/batch/batch-mpi) for parallel tasks that require message passing between nodes.</span></span> 

<span data-ttu-id="5dcd7-272">Azure Batch 作业在节点池上运行 (VM)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-272">An Azure Batch job runs on a pool of nodes (VMs).</span></span> <span data-ttu-id="5dcd7-273">一种方法是仅在需要时分配池并在作业完成后将其删除。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-273">One approach is to allocate a pool only when needed and then delete it after the job completes.</span></span> <span data-ttu-id="5dcd7-274">这可最大化利用率，因为节点不是空闲状态，但是作业必须等待节点分配。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-274">This maximizes utilization, because nodes are not idle, but the job must wait for nodes to be allocated.</span></span> <span data-ttu-id="5dcd7-275">或者，可以提前创建池。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-275">Alternatively, you can create a pool ahead of time.</span></span> <span data-ttu-id="5dcd7-276">此方法可最小化启动作业的时间，但是会导致节点处于空闲状态。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-276">That approach minimizes the time that it takes for a job to start, but can result in having nodes that sit idle.</span></span> <span data-ttu-id="5dcd7-277">有关详细信息，请参阅[池和计算节点生存期](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-277">For more information, see [Pool and compute node lifetime](/azure/batch/batch-api-basics#pool-and-compute-node-lifetime).</span></span>

#### <a name="more-information"></a><span data-ttu-id="5dcd7-278">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-278">More information</span></span> 

* [<span data-ttu-id="5dcd7-279">使用 Batch 运行固有并行的工作负载</span><span class="sxs-lookup"><span data-stu-id="5dcd7-279">Run intrinsically parallel workloads with Batch</span></span>](/azure/batch/batch-technical-overview) 
* [<span data-ttu-id="5dcd7-280">使用 Batch 开发大规模并行计算解决方案</span><span class="sxs-lookup"><span data-stu-id="5dcd7-280">Develop large-scale parallel compute solutions with Batch</span></span>](/azure/batch/batch-api-basics) 
* [<span data-ttu-id="5dcd7-281">适用于大规模计算工作负载的 Batch 和 HPC 解决方案</span><span class="sxs-lookup"><span data-stu-id="5dcd7-281">Batch and HPC solutions for large-scale computing workloads</span></span>](/azure/batch/batch-hpc-solutions)

### <a name="azure-container-service"></a><span data-ttu-id="5dcd7-282">Azure 容器服务</span><span class="sxs-lookup"><span data-stu-id="5dcd7-282">Azure Container Service</span></span> 

<span data-ttu-id="5dcd7-283">通过 Azure 容器服务，可在 Azure 中配置和管理 VM 以运行容器化的应用程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-283">Azure Container Service lets you configure and manage a cluster of VMs in Azure to run containerized applications.</span></span> <span data-ttu-id="5dcd7-284">它针对业务流程提供了 Docker Swarm、DC/OS 或 Kubernetes 选项。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-284">It provides a choice of Docker Swarm, DC/OS, or Kubernetes for orchestration.</span></span> 

<span data-ttu-id="5dcd7-285">容器有助于运行后台作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-285">Containers can be useful for running background jobs.</span></span> <span data-ttu-id="5dcd7-286">一些优点包括：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-286">Some of the benefits include:</span></span> 

- <span data-ttu-id="5dcd7-287">容器支持高密度托管。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-287">Containers support high-density hosting.</span></span> <span data-ttu-id="5dcd7-288">可以隔离容器中的后台任务，同时在每个 VM 中放置多个容器。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-288">You can isolate a background task in a container, while placing multiple containers in each VM.</span></span>
- <span data-ttu-id="5dcd7-289">容器业务流程协调程序处理内部负载均衡、配置内部网络和其他配置任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-289">The container orchestrator handles internal load balancing, configuring the internal network, and other configuration tasks.</span></span>
- <span data-ttu-id="5dcd7-290">容器可在需要时启动和停止。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-290">Containers can be started and stopped as needed.</span></span> 
- <span data-ttu-id="5dcd7-291">通过Azure 容器注册表，可注册 Azure 边界内的容器。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-291">Azure Container Registry allows you to register your containers inside Azure boundaries.</span></span> <span data-ttu-id="5dcd7-292">这会带来安全性、隐私和邻近感应方面的好处。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-292">This comes with security, privacy, and proximity benefits.</span></span> 

#### <a name="considerations"></a><span data-ttu-id="5dcd7-293">注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-293">Considerations</span></span>

- <span data-ttu-id="5dcd7-294">需要了解如何使用容器业务流程协调程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-294">Requires an understanding of how to use a container orchestrator.</span></span> <span data-ttu-id="5dcd7-295">这是否可能成为一个问题取决于 DevOps 团队的技能组合。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-295">Depending on the skillset of your DevOps team, this may or may not be an issue.</span></span>  
- <span data-ttu-id="5dcd7-296">容器服务在 IaaS 环境中运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-296">Container Service runs in an IaaS environment.</span></span> <span data-ttu-id="5dcd7-297">它预配专用 VNet 内的 VM 的群集。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-297">It provisions a cluster of VMs inside a dedicated VNet.</span></span> 

#### <a name="more-information"></a><span data-ttu-id="5dcd7-298">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-298">More information</span></span> 

* [<span data-ttu-id="5dcd7-299">Azure 容器服务的 Docker 容器托管解决方案简介</span><span class="sxs-lookup"><span data-stu-id="5dcd7-299">Introduction to Docker container hosting solutions with Azure Container Service</span></span>](/azure/container-service/container-service-intro) 
* [<span data-ttu-id="5dcd7-300">专用 Docker 容器注册表简介</span><span class="sxs-lookup"><span data-stu-id="5dcd7-300">Introduction to private Docker container registries</span></span>](/azure/container-registry/container-registry-intro) 

### <a name="azure-cloud-services"></a><span data-ttu-id="5dcd7-301">Azure 云服务</span><span class="sxs-lookup"><span data-stu-id="5dcd7-301">Azure Cloud Services</span></span> 
<span data-ttu-id="5dcd7-302">可以在 Web 角色或单独的辅助角色中执行后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-302">You can execute background tasks within a web role or in a separate worker role.</span></span> <span data-ttu-id="5dcd7-303">是否使用辅助角色的决定应该基于伸缩性和弹性要求、任务生存期、发行安排、安全性、容错、资源争用、复杂性和逻辑体系结构等考虑因素。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-303">When you are deciding whether to use a worker role, consider scalability and elasticity requirements, task lifetime, release cadence, security, fault tolerance, contention, complexity, and the logical architecture.</span></span> <span data-ttu-id="5dcd7-304">有关详细信息，请参阅[计算资源整合模式](../patterns/compute-resource-consolidation.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-304">For more information, see [Compute Resource Consolidation Pattern](../patterns/compute-resource-consolidation.md).</span></span>

<span data-ttu-id="5dcd7-305">可通过多种方式在云服务角色中实施后台任务：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-305">There are several ways to implement background tasks within a Cloud Services role:</span></span>

* <span data-ttu-id="5dcd7-306">在角色中创建 **RoleEntryPoint** 类的实现，并使用它的方法来执行后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-306">Create an implementation of the **RoleEntryPoint** class in the role and use its methods to execute background tasks.</span></span> <span data-ttu-id="5dcd7-307">任务在 WaIISHost.exe 的上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-307">The tasks run in the context of WaIISHost.exe.</span></span> <span data-ttu-id="5dcd7-308">它们可以使用 **CloudConfigurationManager** 类的 **GetSetting** 方法来加载配置设置。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-308">They can use the **GetSetting** method of the **CloudConfigurationManager** class to load configuration settings.</span></span> <span data-ttu-id="5dcd7-309">有关详细信息，请参阅[生命周期](#lifecycle)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-309">For more information, see [Lifecycle](#lifecycle).</span></span>
* <span data-ttu-id="5dcd7-310">应用程序启动时，使用启动任务来执行后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-310">Use startup tasks to execute background tasks when the application starts.</span></span> <span data-ttu-id="5dcd7-311">要强制任务继续在后台运行，请将 **taskType** 属性设置为 **background**（如果不这样做，应用程序启动进程会中止并等待任务完成）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-311">To force the tasks to continue to run in the background, set the **taskType** property to **background** (if you do not do this, the application startup process will halt and wait for the task to finish).</span></span> <span data-ttu-id="5dcd7-312">有关详细信息，请参阅 [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks)（在 Azure 中运行启动任务）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-312">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>
* <span data-ttu-id="5dcd7-313">可以使用 WebJobs SDK 来实施作为启动任务启动的后台任务（如 Web 作业）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-313">Use the WebJobs SDK to implement background tasks such as WebJobs that are initiated as a startup task.</span></span> <span data-ttu-id="5dcd7-314">有关详细信息，请参阅[在 Azure 应用服务中创建 .NET Web 作业](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-314">For more information, see [Create a .NET WebJob in Azure App Service](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started).</span></span>
* <span data-ttu-id="5dcd7-315">使用启动任务可以安装一个 Windows 服务来执行一个或多个后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-315">Use a startup task to install a Windows service that executes one or more background tasks.</span></span> <span data-ttu-id="5dcd7-316">必须将 **taskType** 属性设置为 **background**，以便服务在后台执行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-316">You must set the **taskType** property to **background** so that the service executes in the background.</span></span> <span data-ttu-id="5dcd7-317">有关详细信息，请参阅 [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks)（在 Azure 中运行启动任务）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-317">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks).</span></span>

<span data-ttu-id="5dcd7-318">在 Web 角色中运行后台任务的主要优势在于可以节省托管成本，因为不要求部署其他角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-318">The main advantage of running background tasks in the web role is the saving in hosting costs because there is no requirement to deploy additional roles.</span></span>

<span data-ttu-id="5dcd7-319">在辅助角色中运行后台任务具有以下优势：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-319">Running background tasks in a worker role has several advantages:</span></span>

* <span data-ttu-id="5dcd7-320">可让为每种类型的角色单独管理缩放。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-320">It allows you to manage scaling separately for each type of role.</span></span> <span data-ttu-id="5dcd7-321">例如，可能需要更多的 Web 角色实例才能支持当前负载，但需要更少的辅助角色实例即可执行后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-321">For example, you might need more instances of a web role to support the current load, but fewer instances of the worker role that executes background tasks.</span></span> <span data-ttu-id="5dcd7-322">从 UI 角色单独缩放后台任务计算实例可以减少托管成本，同时保持可接受的性能。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-322">By scaling background task compute instances separately from the UI roles, you can reduce hosting costs, while maintaining acceptable performance.</span></span>
* <span data-ttu-id="5dcd7-323">卸载来自 Web 角色的后台任务的处理开销。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-323">It offloads the processing overhead for background tasks from the web role.</span></span> <span data-ttu-id="5dcd7-324">提供 UI 的 Web 角色可以保持响应度，这还可能意味着需要更少的实例，即可支持来自用户的给定请求数量。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-324">The web role that provides the UI can remain responsive, and it may mean fewer instances are required to support a given volume of requests from users.</span></span>
* <span data-ttu-id="5dcd7-325">通过它，可实现关注点分离。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-325">It allows you to implement separation of concerns.</span></span> <span data-ttu-id="5dcd7-326">每种角色类型可以实施特定一组明确定义的相关任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-326">Each role type can implement a specific set of clearly defined and related tasks.</span></span> <span data-ttu-id="5dcd7-327">这就简化了代码设计和维护，因为各角色之间的代码和功能依赖性降低。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-327">This makes designing and maintaining the code easier because there is less interdependence of code and functionality between each role.</span></span>
* <span data-ttu-id="5dcd7-328">有助于隔离敏感的进程和数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-328">It can help to isolate sensitive processes and data.</span></span> <span data-ttu-id="5dcd7-329">例如，实施 UI 的 Web 角色无需访问辅助角色管理和控制的数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-329">For example, web roles that implement the UI do not need to have access to data that is managed and controlled by a worker role.</span></span> <span data-ttu-id="5dcd7-330">这可用于增强安全性，尤其是使用[守护程序模式](../patterns/gatekeeper.md)等模式时。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-330">This can be useful in strengthening security, especially when you use a pattern such as the [Gatekeeper Pattern](../patterns/gatekeeper.md).</span></span>  

#### <a name="considerations"></a><span data-ttu-id="5dcd7-331">注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-331">Considerations</span></span>
<span data-ttu-id="5dcd7-332">如果使用云服务 Web 和辅助角色，请在选择部署后台任务的方式和位置时注意以下要点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-332">Consider the following points when choosing how and where to deploy background tasks when using Cloud Services web and worker roles:</span></span>

* <span data-ttu-id="5dcd7-333">在现有 Web 角色中托管后台任务可以节省只对这些任务运行不同辅助角色的成本。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-333">Hosting background tasks in an existing web role can save the cost of running a separate worker role just for these tasks.</span></span> <span data-ttu-id="5dcd7-334">但如果争用进程和其他资源，则可能影响应用程序的性能和可用性。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-334">However, it is likely to affect the performance and availability of the application if there is contention for processing and other resources.</span></span> <span data-ttu-id="5dcd7-335">使用单独的辅助角色可防止长时间运行或资源密集型后台任务影响 Web 角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-335">Using a separate worker role protects the web role from the impact of long-running or resource-intensive background tasks.</span></span>
* <span data-ttu-id="5dcd7-336">如果使用 **RoleEntryPoint** 类托管后台任务，可以轻松地将该类移到另一个角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-336">If you host background tasks by using the **RoleEntryPoint** class, you can easily move this to another role.</span></span> <span data-ttu-id="5dcd7-337">例如，如果在 Web 角色中创建该类，后来确定需要在辅助角色中运行任务，可以将 **RoleEntryPoint** 类实现移入辅助角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-337">For example, if you create the class in a web role and later decide that you need to run the tasks in a worker role, you can move the **RoleEntryPoint** class implementation into the worker role.</span></span>
* <span data-ttu-id="5dcd7-338">启动任务旨在执行程序或脚本。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-338">Startup tasks are designed to execute a program or a script.</span></span> <span data-ttu-id="5dcd7-339">将后台作业部署为可执行程序可能更困难，尤其是还需要部署依赖程序集时。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-339">Deploying a background job as an executable program might be more difficult, especially if it also requires deployment of dependent assemblies.</span></span> <span data-ttu-id="5dcd7-340">在使用启动任务时，部署和使用脚本定义后台作业可能更容易。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-340">It might be easier to deploy and use a script to define a background job when you use startup tasks.</span></span>
* <span data-ttu-id="5dcd7-341">导致后台任务失败的异常会造成不同的影响，具体取决于任务的托管方式：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-341">Exceptions that cause a background task to fail have a different impact, depending on the way that they are hosted:</span></span>
  * <span data-ttu-id="5dcd7-342">如果使用 **RoleEntryPoint** 类的方式，失败的任务将导致角色重新启动，从而使任务自动重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-342">If you use the **RoleEntryPoint** class approach, a failed task will cause the role to restart so that the task automatically restarts.</span></span> <span data-ttu-id="5dcd7-343">这可能会影响应用程序的可用性。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-343">This can affect availability of the application.</span></span> <span data-ttu-id="5dcd7-344">若要避免此问题，请确保在 **RoleEntryPoint** 类和所有后台任务中包含可靠的异常处理。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-344">To prevent this, ensure that you include robust exception handling within the **RoleEntryPoint** class and all the background tasks.</span></span> <span data-ttu-id="5dcd7-345">如果适用，请使用代码来重新启动失败的任务，并且仅当无法正常地从代码失败中恢复时，才引发异常来重新启动角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-345">Use code to restart tasks that fail where this is appropriate, and throw the exception to restart the role only if you cannot gracefully recover from the failure within your code.</span></span>
  * <span data-ttu-id="5dcd7-346">如果使用启动任务，则需要负责管理任务执行，并检查任务是否失败。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-346">If you use startup tasks, you are responsible for managing the task execution and checking if it fails.</span></span>
* <span data-ttu-id="5dcd7-347">管理和监视启动任务比使用 **RoleEntryPoint** 类的方式更困难。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-347">Managing and monitoring startup tasks is more difficult than using the **RoleEntryPoint** class approach.</span></span> <span data-ttu-id="5dcd7-348">但是，Azure Web WebJobs SDK 包含了仪表板，以方便管理通过启动任务启动的 Web 作业。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-348">However, the Azure WebJobs SDK includes a dashboard to make it easier to manage WebJobs that you initiate through startup tasks.</span></span>

#### <a name="lifecycle"></a><span data-ttu-id="5dcd7-349">生命周期</span><span class="sxs-lookup"><span data-stu-id="5dcd7-349">Lifecycle</span></span> 
 <span data-ttu-id="5dcd7-350">如果决定使用 **RoleEntryPoint** 类为使用 Web 角色和辅助角色的云服务应用程序实施后台作业，则必须了解此类的生命周期以正确使用它。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-350">If you decide to implement background jobs for Cloud Services applications that use web and worker roles by using the **RoleEntryPoint** class, it is important to understand the lifecycle of this class in order to use it correctly.</span></span>

<span data-ttu-id="5dcd7-351">Web 角色和辅助角色在启动、运行和停止时会经历一组不同的阶段。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-351">Web and worker roles go through a set of distinct phases as they start, run, and stop.</span></span> <span data-ttu-id="5dcd7-352">**RoleEntryPoint** 类将公开一系列事件，用于指示这些阶段何时发生。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-352">The **RoleEntryPoint** class exposes a series of events that indicate when these stages are occurring.</span></span> <span data-ttu-id="5dcd7-353">可以使用这些事件来初始化、运行和停止自定义后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-353">You use these to initialize, run, and stop your custom background tasks.</span></span> <span data-ttu-id="5dcd7-354">整个周期为：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-354">The complete cycle is:</span></span>

* <span data-ttu-id="5dcd7-355">Azure 加载角色程序集，并在其中搜索派生自 **RoleEntryPoint** 的类。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-355">Azure loads the role assembly and searches it for a class that derives from **RoleEntryPoint**.</span></span>
* <span data-ttu-id="5dcd7-356">如果找到此类，则调用 **RoleEntryPoint.OnStart()**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-356">If it finds this class, it calls **RoleEntryPoint.OnStart()**.</span></span> <span data-ttu-id="5dcd7-357">重写此方法可初始化后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-357">You override this method to initialize your background tasks.</span></span>
* <span data-ttu-id="5dcd7-358">完成 **OnStart** 方法后，Azure 将调用应用程序全局文件（如果存在，例如，运行 ASP.NET 的 Web 角色中的 Global.asax）中的 **Application_Start()**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-358">After the **OnStart** method has completed, Azure calls **Application_Start()** in the application’s Global file if this is present (for example, Global.asax in a web role running ASP.NET).</span></span>
* <span data-ttu-id="5dcd7-359">Azure 在与 **OnStart()** 对同时执行的新前台线程调用 **RoleEntryPoint.Run()**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-359">Azure calls **RoleEntryPoint.Run()** on a new foreground thread that executes in parallel with **OnStart()**.</span></span> <span data-ttu-id="5dcd7-360">重写此方法可启动后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-360">You override this method to start your background tasks.</span></span>
* <span data-ttu-id="5dcd7-361">Run 方法结束时，Azure 首先调用应用程序的全局文件中的 **Application_End()**（若存在），然后调用 **RoleEntryPoint.OnStop()**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-361">When the Run method ends, Azure first calls **Application_End()** in the application’s Global file if this is present, and then calls **RoleEntryPoint.OnStop()**.</span></span> <span data-ttu-id="5dcd7-362">可以重写 **OnStop** 方法来停止后台任务、清理资源、处置对象，并关闭任务可能已使用的连接。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-362">You override the **OnStop** method to stop your background tasks, clean up resources, dispose of objects, and close connections that the tasks may have used.</span></span>
* <span data-ttu-id="5dcd7-363">Azure 辅助角色主机进程已停止。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-363">The Azure worker role host process is stopped.</span></span> <span data-ttu-id="5dcd7-364">此时，该角色会被回收并重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-364">At this point, the role will be recycled and will restart.</span></span>

<span data-ttu-id="5dcd7-365">有关 **RoleEntryPoint** 类的用法详细信息和示例，请参阅[计算资源整合模式](../patterns/compute-resource-consolidation.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-365">For more details and an example of using the methods of the **RoleEntryPoint** class, see [Compute Resource Consolidation Pattern](../patterns/compute-resource-consolidation.md).</span></span>

#### <a name="implementation-considerations"></a><span data-ttu-id="5dcd7-366">实现注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-366">Implementation considerations</span></span>

<span data-ttu-id="5dcd7-367">如果正在 Web 或辅助角色中执行后台任务，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-367">Consider the following points if you are implementing background tasks in a web or worker role:</span></span>

* <span data-ttu-id="5dcd7-368">**RoleEntryPoint** 类中的默认 **Run** 方法实现包含对 **Thread.Sleep(Timeout.Infinite)**（将角色保持为无限生存）的调用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-368">The default **Run** method implementation in the **RoleEntryPoint** class contains a call to **Thread.Sleep(Timeout.Infinite)** that keeps the role alive indefinitely.</span></span> <span data-ttu-id="5dcd7-369">若重写 **Run** 方法（执行后台任务通常需要这样做），则不能允许代码从该方法退出，除非想要回收角色实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-369">If you override the **Run** method (which is typically necessary to execute background tasks), you must not allow your code to exit from the method unless you want to recycle the role instance.</span></span>
* <span data-ttu-id="5dcd7-370">**Run** 方法的典型实现包含用于启动每个后台任务的代码，以及定期检查所有后台任务状态的循环构造。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-370">A typical implementation of the **Run** method includes code to start each of the background tasks and a loop construct that periodically checks the state of all the background tasks.</span></span> <span data-ttu-id="5dcd7-371">它可以重新启动任何失败的任务，或监视用于指示作业已完成的取消标记。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-371">It can restart any that fail or monitor for cancellation tokens that indicate that jobs have completed.</span></span>
* <span data-ttu-id="5dcd7-372">如果后台任务引发了未处理的异常，则应该回收该任务，同时允许角色中的任何其他后台任务继续运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-372">If a background task throws an unhandled exception, that task should be recycled while allowing any other background tasks in the role to continue running.</span></span> <span data-ttu-id="5dcd7-373">但是，如果异常是由于任务外部的对象（例如共享存储）损坏所造成的，则应由 **RoleEntryPoint** 类处理异常，应取消所有任务，并允许 **Run** 方法结束。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-373">However, if the exception is caused by corruption of objects outside the task, such as shared storage, the exception should be handled by your **RoleEntryPoint** class, all tasks should be cancelled, and the **Run** method should be allowed to end.</span></span> <span data-ttu-id="5dcd7-374">然后，Azure 将重新启动角色。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-374">Azure will then restart the role.</span></span>
* <span data-ttu-id="5dcd7-375">使用 **OnStop** 方法可以暂停或终止后台任务并清理资源。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-375">Use the **OnStop** method to pause or kill background tasks and clean up resources.</span></span> <span data-ttu-id="5dcd7-376">这可能涉及到停止长时间运行的任务或多步骤任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-376">This might involve stopping long-running or multistep tasks.</span></span> <span data-ttu-id="5dcd7-377">请务必考虑到这种操作的后果，以避免数据不一致。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-377">It is vital to consider how this can be done to avoid data inconsistencies.</span></span> <span data-ttu-id="5dcd7-378">如果角色实例出于任何原因（用户启动的关机除外）而停止，**OnStop** 方法中运行的代码必须在五分钟内完成，然后才能将它强行终止。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-378">If a role instance stops for any reason other than a user-initiated shutdown, the code running in the **OnStop** method must be completed within five minutes before it is forcibly terminated.</span></span> <span data-ttu-id="5dcd7-379">确保代码可以在这段时间内完成，或者可以容忍无法完成运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-379">Ensure that your code can be completed in that time or can tolerate not running to completion.</span></span>  
* <span data-ttu-id="5dcd7-380">当 **RoleEntryPoint.OnStart** 方法返回值 **true** 时，Azure 负载均衡器开始将流量定向到角色实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-380">The Azure load balancer starts directing traffic to the role instance when the **RoleEntryPoint.OnStart** method returns the value **true**.</span></span> <span data-ttu-id="5dcd7-381">因此，请考虑将所有初始化代码置于 **OnStart** 方法中，使未成功初始化的角色实例不会收到任何流量。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-381">Therefore, consider putting all your initialization code in the **OnStart** method so that role instances that do not successfully initialize will not receive any traffic.</span></span>
* <span data-ttu-id="5dcd7-382">除了 **RoleEntryPoint** 类的方法以外，还可以使用启动任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-382">You can use startup tasks in addition to the methods of the **RoleEntryPoint** class.</span></span> <span data-ttu-id="5dcd7-383">应该使用启动任务来初始化需要在 Azure 负载均衡器中更改的任何设置，因为在角色接收任何请求之前将执行这些任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-383">You should use startup tasks to initialize any settings that you need to change in the Azure load balancer because these tasks will execute before the role receives any requests.</span></span> <span data-ttu-id="5dcd7-384">有关详细信息，请参阅 [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks/)（在 Azure 中运行启动任务）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-384">For more information, see [Run startup tasks in Azure](/azure/cloud-services/cloud-services-startup-tasks/).</span></span>
* <span data-ttu-id="5dcd7-385">如果启动任务发生错误，它可以强制角色持续重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-385">If there is an error in a startup task, it might force the role to continually restart.</span></span> <span data-ttu-id="5dcd7-386">这可能阻止虚拟 IP (VIP) 地址交换回之前暂存版本，因为交换需要具有对该角色的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-386">This can prevent you from performing a virtual IP (VIP) address swap back to a previously staged version because the swap requires exclusive access to the role.</span></span> <span data-ttu-id="5dcd7-387">在角色重新启动时无法做到这一点。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-387">This cannot be obtained while the role is restarting.</span></span> <span data-ttu-id="5dcd7-388">若要解决此问题：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-388">To resolve this:</span></span>
  
  * <span data-ttu-id="5dcd7-389">将以下代码添加到角色中 **OnStart** 和 **Run** 方法的开头：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-389">Add the following code to the beginning of the **OnStart** and **Run** methods in your role:</span></span>
    
    ```C#
    var freeze = CloudConfigurationManager.GetSetting("Freeze");
    if (freeze != null)
    {
      if (Boolean.Parse(freeze))
      {
        Thread.Sleep(System.Threading.Timeout.Infinite);
      }
    }
    ```
    
  * <span data-ttu-id="5dcd7-390">对于角色，请将 **Freeze** 设置的定义作为布尔值添加到 ServiceDefinition.csdef 和 ServiceConfiguration.\*.cscfg 文件，并将它设置为 **false**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-390">Add the definition of the **Freeze** setting as a Boolean value to the ServiceDefinition.csdef and ServiceConfiguration.\*.cscfg files for the role and set it to **false**.</span></span> <span data-ttu-id="5dcd7-391">如果角色进入重复重新启动模式，可以将设置更改为 true 以冻结角色的执行，并允许他与以前的版本交换。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-391">If the role goes into a repeated restart mode, you can change the setting to **true** to freeze role execution and allow it to be swapped with a previous version.</span></span>

#### <a name="more-information"></a><span data-ttu-id="5dcd7-392">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-392">More information</span></span>
* [<span data-ttu-id="5dcd7-393">计算资源整合模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-393">Compute Resource Consolidation Pattern</span></span>](../patterns/compute-resource-consolidation.md)
* [<span data-ttu-id="5dcd7-394">Azure WebJobs SDK 入门</span><span class="sxs-lookup"><span data-stu-id="5dcd7-394">Get started with the Azure WebJobs SDK</span></span>](/azure/app-service-web/websites-dotnet-webjobs-sdk-get-started/)


## <a name="partitioning"></a><span data-ttu-id="5dcd7-395">分区</span><span class="sxs-lookup"><span data-stu-id="5dcd7-395">Partitioning</span></span>
<span data-ttu-id="5dcd7-396">如果确定在现有的计算实例（例如 Web 应用、Web 角色、现有辅助角色或虚拟机）中包含后台任务，必须考虑这会如何影响计算实例和后台任务本身的质量属性。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-396">If you decide to include background tasks within an existing compute instance (such as a web app, web role, existing worker role, or virtual machine), you must consider how this will affect the quality attributes of the compute instance and the background task itself.</span></span> <span data-ttu-id="5dcd7-397">这些因素可帮助你确定是要将任务与现有计算实例放在一起，还是将它们隔离成独立的计算实例：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-397">These factors will help you to decide whether to colocate the tasks with the existing compute instance or separate them out into a separate compute instance:</span></span>

* <span data-ttu-id="5dcd7-398">**可用性**：后台任务可能无需具有应用程序其他部分所具有的相同可用性级别，特别是直接参与用户交互的 UI 和其他部分。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-398">**Availability**: Background tasks might not need to have the same level of availability as other parts of the application, in particular the UI and other parts that are directly involved in user interaction.</span></span> <span data-ttu-id="5dcd7-399">由于可将操作排入队列，后台任务可能更容许延迟、重试的连接失败，以及影响可用性的其他因素。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-399">Background tasks might be more tolerant of latency, retried connection failures, and other factors that affect availability because the operations can be queued.</span></span> <span data-ttu-id="5dcd7-400">但是，必须有足够的容量来防止备份可能阻止队列和影响整个应用程序的请求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-400">However, there must be sufficient capacity to prevent the backup of requests that could block queues and affect the application as a whole.</span></span>
* <span data-ttu-id="5dcd7-401">**伸缩性**：后台任务对 UI 和应用程序的交互部分可能有不同的伸缩性要求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-401">**Scalability**: Background tasks are likely to have a different scalability requirement than the UI and the interactive parts of the application.</span></span> <span data-ttu-id="5dcd7-402">缩放 UI 可能需要符合需求的高峰，而未完成的后台任务可能在较空闲的时间由较少的计算实例数完成。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-402">Scaling the UI might be necessary to meet peaks in demand, while outstanding background tasks might be completed during less busy times by a fewer number of compute instances.</span></span>
* <span data-ttu-id="5dcd7-403">**复原能力**：如果只有托管后台任务的请求可以排入队列或延迟到任务再次可用为止，则这些任务的计算实例失败不会严重影响整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-403">**Resiliency**: Failure of a compute instance that just hosts background tasks might not fatally affect the application as a whole if the requests for these tasks can be queued or postponed until the task is available again.</span></span> <span data-ttu-id="5dcd7-404">如果计算实例和/或任务可以在适当的间隔内重新启动，则不可以影响应用程序的用户。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-404">If the compute instance and/or tasks can be restarted within an appropriate interval, users of the application might not be affected.</span></span>
* <span data-ttu-id="5dcd7-405">**安全性**：相较于 UI 或应用程序的其他部分，后台任务可能有不同的安全要求或限制。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-405">**Security**: Background tasks might have different security requirements or restrictions than the UI or other parts of the application.</span></span> <span data-ttu-id="5dcd7-406">通过使用单独的计算实例，可以为任务指定不同的安全环境。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-406">By using a separate compute instance, you can specify a different security environment for the tasks.</span></span> <span data-ttu-id="5dcd7-407">还可以使用模式（例如守护程序）将后台计算实例与 UI 相隔离，以最大程度地提供安全性和隔离性。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-407">You can also use patterns such as Gatekeeper to isolate the background compute instances from the UI in order to maximize security and separation.</span></span>
* <span data-ttu-id="5dcd7-408">**性能**：可以选择专门与任务的性能要求相符的后台任务计算实例类型。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-408">**Performance**: You can choose the type of compute instance for background tasks to specifically match the performance requirements of the tasks.</span></span> <span data-ttu-id="5dcd7-409">这可能意味着，当任务无需与 UI 具有相同处理功能时，可以使用更便宜的计算选项；或者如果任务需要附加的容量和资源，则使用更大的实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-409">This might mean using a less expensive compute option if the tasks do not require the same processing capabilities as the UI, or a larger instance if they require additional capacity and resources.</span></span>
* <span data-ttu-id="5dcd7-410">**易管理性**：相较于主应用程序代码或 UI，后台任务可能有不同的开发和部署节奏。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-410">**Manageability**: Background tasks might have a different development and deployment rhythm from the main application code or the UI.</span></span> <span data-ttu-id="5dcd7-411">将它们部署到不同的计算实例可简化更新与版本控制。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-411">Deploying them to a separate compute instance can simplify updates and versioning.</span></span>
* <span data-ttu-id="5dcd7-412">**成本**：添加计算实例来执行后台任务会增加托管成本。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-412">**Cost**: Adding compute instances to execute background tasks increases hosting costs.</span></span> <span data-ttu-id="5dcd7-413">应该仔细考虑如何在添加容量与产生的成本之间做出取舍。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-413">You should carefully consider the trade-off between additional capacity and these extra costs.</span></span>

<span data-ttu-id="5dcd7-414">有关详细信息，请参阅 [Leader Election Pattern](../patterns/leader-election.md)（领导选拔模式）和 [Competing Consumers Pattern](../patterns/competing-consumers.md)（使用者竞争模式）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-414">For more information, see [Leader Election Pattern](../patterns/leader-election.md) and [Competing Consumers Pattern](../patterns/competing-consumers.md).</span></span>

## <a name="conflicts"></a><span data-ttu-id="5dcd7-415">冲突</span><span class="sxs-lookup"><span data-stu-id="5dcd7-415">Conflicts</span></span>
<span data-ttu-id="5dcd7-416">如果有后台作业的多个实例，这些实例可能会争用对资源和服务（例如数据库和存储）的访问权。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-416">If you have multiple instances of a background job, it is possible that they will compete for access to resources and services, such as databases and storage.</span></span> <span data-ttu-id="5dcd7-417">这种并发访问可能会导致资源争用情况，从而造成服务可用性及存储中数据完整性的冲突。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-417">This concurrent access can result in resource contention, which might cause conflicts in availability of the services and in the integrity of data in storage.</span></span> <span data-ttu-id="5dcd7-418">可以使用悲观锁定方法来解决资源争用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-418">You can resolve resource contention by using a pessimistic locking approach.</span></span> <span data-ttu-id="5dcd7-419">这可以防止任务的竞争实例同时访问某个服务或损坏数据。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-419">This prevents competing instances of a task from concurrently accessing a service or corrupting data.</span></span>

<span data-ttu-id="5dcd7-420">另一种解决冲突的方法是将后台任务定义为单一实例，以便只有一个运行中的实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-420">Another approach to resolve conflicts is to define background tasks as a singleton, so that there is only ever one instance running.</span></span> <span data-ttu-id="5dcd7-421">但是，这会消除多实例配置可提供的可靠性和性能优势。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-421">However, this eliminates the reliability and performance benefits that a multiple-instance configuration can provide.</span></span> <span data-ttu-id="5dcd7-422">当 UI 可以提供足够的工作让多个后台任务保持繁忙时尤其如此。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-422">This is especially true if the UI can supply sufficient work to keep more than one background task busy.</span></span>

<span data-ttu-id="5dcd7-423">必须确保后台任务可以自动重新启动，并且有足够的容量来应对需求高峰。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-423">It is vital to ensure that the background task can automatically restart and that it has sufficient capacity to cope with peaks in demand.</span></span> <span data-ttu-id="5dcd7-424">这可以通过将足够的资源分配给计算实例、实施队列机制（可存储请求以便日后续需求降低时执行）或使用这些方法的组合来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-424">You can achieve this by allocating a compute instance with sufficient resources, by implementing a queueing mechanism that can store requests for later execution when demand decreases, or by using a combination of these techniques.</span></span>

## <a name="coordination"></a><span data-ttu-id="5dcd7-425">协调</span><span class="sxs-lookup"><span data-stu-id="5dcd7-425">Coordination</span></span>
<span data-ttu-id="5dcd7-426">后台任务可能很复杂，需要执行多个不同的任务来生成结果或满足所有要求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-426">The background tasks might be complex and might require multiple individual tasks to execute to produce a result or to fulfil all the requirements.</span></span> <span data-ttu-id="5dcd7-427">在这些方案中，住往会将任务分割成可由多个使用者执行的较小离散步骤或子任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-427">It is common in these scenarios to divide the task into smaller discreet steps or subtasks that can be executed by multiple consumers.</span></span> <span data-ttu-id="5dcd7-428">多步骤操作可能更有效率且更具弹性，因为单个步骤可以在多个作业中重复使用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-428">Multistep jobs can be more efficient and more flexible because individual steps might be reusable in multiple jobs.</span></span> <span data-ttu-id="5dcd7-429">还可以轻松地添加、删除或修改步骤的顺序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-429">It is also easy to add, remove, or modify the order of the steps.</span></span>

<span data-ttu-id="5dcd7-430">协调多个任务和步骤可能相当困难，但可以参考三种常见的模式来实施解决方案：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-430">Coordinating multiple tasks and steps can be challenging, but there are three common patterns that you can use to guide your implementation of a solution:</span></span>

* <span data-ttu-id="5dcd7-431">**将一个任务分解成多个可重复使用的步骤**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-431">**Decomposing a task into multiple reusable steps**.</span></span> <span data-ttu-id="5dcd7-432">对于处理的信息，应用程序可能需要执行复杂性不一的各种任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-432">An application might be required to perform a variety of tasks of varying complexity on the information that it processes.</span></span> <span data-ttu-id="5dcd7-433">实施此应用程序的一种直接但有弹性的方法是将这种处理当作单一模块来执行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-433">A straightforward but inflexible approach to implementing this application might be to perform this processing as a monolithic module.</span></span> <span data-ttu-id="5dcd7-434">但是，这种方法可能会降低重构代码、优化代码或在应用程序的其他位置需要相同处理的部分时重复使用代码的机会。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-434">However, this approach is likely to reduce the opportunities for refactoring the code, optimizing it, or reusing it if parts of the same processing are required elsewhere within the application.</span></span> <span data-ttu-id="5dcd7-435">有关详细信息，请参阅[管道和筛选器模式](../patterns/pipes-and-filters.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-435">For more information, see [Pipes and Filters Pattern](../patterns/pipes-and-filters.md).</span></span>
* <span data-ttu-id="5dcd7-436">**管理任务的步骤执行**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-436">**Managing execution of the steps for a task**.</span></span> <span data-ttu-id="5dcd7-437">应用程序可以执行包含多个步骤的任务（其中有些步骤可以调用远程服务或访问远程资源）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-437">An application might perform tasks that comprise a number of steps (some of which might invoke remote services or access remote resources).</span></span> <span data-ttu-id="5dcd7-438">各个步骤可以彼此独立，但它们由实施任务的应用程序逻辑进行协调。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-438">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span> <span data-ttu-id="5dcd7-439">有关详细信息，请参阅[计划程序代理监督程序模式](../patterns/scheduler-agent-supervisor.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-439">For more information, see [Scheduler Agent Supervisor Pattern](../patterns/scheduler-agent-supervisor.md).</span></span>
* <span data-ttu-id="5dcd7-440">**管理失败任务步骤的恢复**。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-440">**Managing recovery for task steps that fail**.</span></span> <span data-ttu-id="5dcd7-441">如果一个或多个步骤失败，应用程序可能需要撤消一系列步骤执行的工作（所有步骤共同定义了最终一致的操作）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-441">An application might need to undo the work that is performed by a series of steps (which together define an eventually consistent operation) if one or more of the steps fail.</span></span> <span data-ttu-id="5dcd7-442">有关详细信息，请参阅[补偿事务模式](../patterns/compensating-transaction.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-442">For more information, see [Compensating Transaction Pattern](../patterns/compensating-transaction.md).</span></span>


## <a name="resiliency-considerations"></a><span data-ttu-id="5dcd7-443">复原注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-443">Resiliency considerations</span></span>
<span data-ttu-id="5dcd7-444">后台任务必须具有复原能力，以便为应用程序提供可靠的服务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-444">Background tasks must be resilient in order to provide reliable services to the application.</span></span> <span data-ttu-id="5dcd7-445">规划和设计后台任务时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-445">When you are planning and designing background tasks, consider the following points:</span></span>

* <span data-ttu-id="5dcd7-446">后台任务必须能够正常处理角色或服务重新启动，而不会损坏数据或导致应用程序不一致。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-446">Background tasks must be able to gracefully handle role or service restarts without corrupting data or introducing inconsistency into the application.</span></span> <span data-ttu-id="5dcd7-447">对于长时间运行的任务或多步骤任务，请考虑使用*检查点*，方法是在永久性存储中保存作业状态，或者在队列中将作业状态另存为消息（如果适当）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-447">For long-running or multistep tasks, consider using *check pointing* by saving the state of jobs in persistent storage, or as messages in a queue if this is appropriate.</span></span> <span data-ttu-id="5dcd7-448">例如，可以在队列的消息中永久保存状态信息，并根据任务进度增量更新此状态信息，以便从上次已知正常的检查点处理任务，而不必从头重新开始。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-448">For example, you can persist state information in a message in a queue and incrementally update this state information with the task progress so that the task can be processed from the last known good checkpoint--instead of restarting from the beginning.</span></span> <span data-ttu-id="5dcd7-449">使用 Azure 服务总线队列时，可以使用消息会话来实现相同的方案。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-449">When using Azure Service Bus queues, you can use message sessions to enable the same scenario.</span></span> <span data-ttu-id="5dcd7-450">会话允许用户使用 [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) 和 [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) 方法来保存和检索应用程序处理状态。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-450">Sessions allow you to save and retrieve the application processing state by using the [SetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.setstate?view=azureservicebus-4.0.0) and [GetState](https://docs.microsoft.com/dotnet/api/microsoft.servicebus.messaging.messagesession.getstate?view=azureservicebus-4.0.0) methods.</span></span> <span data-ttu-id="5dcd7-451">有关设计可靠的多步骤过程和工作流的详细信息，请参阅 [Scheduler Agent Supervisor Pattern](../patterns/scheduler-agent-supervisor.md)（计划程序代理监督程序模式）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-451">For more information about designing reliable multistep processes and workflows, see [Scheduler Agent Supervisor Pattern](../patterns/scheduler-agent-supervisor.md).</span></span>
* <span data-ttu-id="5dcd7-452">使用 Web 角色或辅助角色托管多个后台任务时，请设计 **Run** 方法的重写来监视失败或已停止的任务，并将其重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-452">When you use web or worker roles to host multiple background tasks, design your override of the **Run** method to monitor for failed or stalled tasks, and restart them.</span></span> <span data-ttu-id="5dcd7-453">如果这不可行，并且你正在使用辅助角色，可从 Run 方法中退出，强制执行辅助角色以重新启动。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-453">Where this is not practical, and you are using a worker role, force the worker role to restart by exiting from the **Run** method.</span></span>
* <span data-ttu-id="5dcd7-454">使用队列来与后台任务通信时，队列可以充当缓冲区，用于在应用程序超过一般负载时，存储发送给任务的请求。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-454">When you use queues to communicate with background tasks, the queues can act as a buffer to store requests that are sent to the tasks while the application is under higher than usual load.</span></span> <span data-ttu-id="5dcd7-455">这样，任务便可以在相对空闲期间与 UI 同步。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-455">This allows the tasks to catch up with the UI during less busy periods.</span></span> <span data-ttu-id="5dcd7-456">这也意味着，回收角色不会阻止 UI。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-456">It also means that recycling the role will not block the UI.</span></span> <span data-ttu-id="5dcd7-457">有关详细信息，请参阅[基于队列的负载调节模式](../patterns/queue-based-load-leveling.md)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-457">For more information, see [Queue-Based Load Leveling Pattern](../patterns/queue-based-load-leveling.md).</span></span> <span data-ttu-id="5dcd7-458">如果某些任务比其他任务更重要，请考虑实施[优先级队列模式](../patterns/priority-queue.md)，确保这些任务在较不重要的任务之前运行。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-458">If some tasks are more important than others, consider implementing the [Priority Queue Pattern](../patterns/priority-queue.md) to ensure that these tasks run before less important ones.</span></span>
* <span data-ttu-id="5dcd7-459">必须将消息或进程消息启动的后台任务设计为处理不一致情况，例如消息以错误顺序到达、消息重复导致错误（通常称为*有害消息*）和消息传送多次。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-459">Background tasks that are initiated by messages or process messages must be designed to handle inconsistencies, such as messages arriving out of order, messages that repeatedly cause an error (often referred to as *poison messages*), and messages that are delivered more than once.</span></span> <span data-ttu-id="5dcd7-460">请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-460">Consider the following:</span></span>
  * <span data-ttu-id="5dcd7-461">必须按特定顺序处理消息，例如，根据数据的现有数据值更改数据的消息（例如，将值添加到现有值）可能不以其原始发送顺序到达。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-461">Messages that must be processed in a specific order, such as those that change data based on the existing data value (for example, adding a value to an existing value), might not arrive in the original order in which they were sent.</span></span> <span data-ttu-id="5dcd7-462">或者，可能因为每个实例上的负载不同，后台任务的不同实例按不同的顺序处理消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-462">Alternatively, they might be handled by different instances of a background task in a different order due to varying loads on each instance.</span></span> <span data-ttu-id="5dcd7-463">必须按特定顺序处理的消息应该包括序号、键，或者可由后台任务用来确保按正确顺序处理这些消息的其他某个指示器。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-463">Messages that must be processed in a specific order should include a sequence number, key, or some other indicator that background tasks can use to ensure that they are processed in the correct order.</span></span> <span data-ttu-id="5dcd7-464">如果使用 Azure 服务总线，可以使用消息会话来保证传送顺序。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-464">If you are using Azure Service Bus, you can use message sessions to guarantee the order of delivery.</span></span> <span data-ttu-id="5dcd7-465">但是，尽可能设计好过程，使消息顺序变得不重要的思路通常更有效率。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-465">However, it is usually more efficient, where possible, to design the process so that the message order is not important.</span></span>
  * <span data-ttu-id="5dcd7-466">一般而言，后台任务会在队列中扫视消息，这会暂时向其他消息使用者隐藏消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-466">Typically, a background task will peek at messages in the queue, which temporarily hides them from other message consumers.</span></span> <span data-ttu-id="5dcd7-467">然后，它会在成功处理消息后，将其删除。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-467">Then it deletes the messages after they have been successfully processed.</span></span> <span data-ttu-id="5dcd7-468">如果后台任务在处理某个消息时失败，该消息会在扫视超时后重新出现在队列中。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-468">If a background task fails when processing a message, that message will reappear on the queue after the peek time-out expires.</span></span> <span data-ttu-id="5dcd7-469">该消息由任务的另一个实例处理，或在此实例的下一个处理周期进行处理。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-469">It will be processed by another instance of the task or during the next processing cycle of this instance.</span></span> <span data-ttu-id="5dcd7-470">如果消息一直导致使用者出错，则会阻止任务、队列，并最终在队列填满时阻止应用程序本身。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-470">If the message consistently causes an error in the consumer, it will block the task, the queue, and eventually the application itself when the queue becomes full.</span></span> <span data-ttu-id="5dcd7-471">因此，请务必在队列中检测并删除有害消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-471">Therefore, it is vital to detect and remove poison messages from the queue.</span></span> <span data-ttu-id="5dcd7-472">如果使用 Azure 服务总线，导致出错的消息可以自动或手动移到关联的死信队列。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-472">If you are using Azure Service Bus, messages that cause an error can be moved automatically or manually to an associated dead letter queue.</span></span>
  * <span data-ttu-id="5dcd7-473">系统为队列保证*至少一次*传送机制，但队列可能会多次传送同一条消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-473">Queues are guaranteed at *least once* delivery mechanisms, but they might deliver the same message more than once.</span></span> <span data-ttu-id="5dcd7-474">此外，如果在处理消息之后、从队列中删除消息之前后台任务失败，消息将可再次处理。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-474">In addition, if a background task fails after processing a message but before deleting it from the queue, the message will become available for processing again.</span></span> <span data-ttu-id="5dcd7-475">后台任务应该具有幂等性，这意味着多次处理同一条消息不会导致错误，或者使应用程序的数据不一致。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-475">Background tasks should be idempotent, which means that processing the same message more than once does not cause an error or inconsistency in the application’s data.</span></span> <span data-ttu-id="5dcd7-476">某些操作原生就是幂等的，例如，将存储的值设置为特定的新值。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-476">Some operations are naturally idempotent, such as setting a stored value to a specific new value.</span></span> <span data-ttu-id="5dcd7-477">但是，有些操作（例如，将值添加到现有的存储值而不检查存储值是否仍与最初发送的消息相同）会导致不一致情况。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-477">However, operations such as adding a value to an existing stored value without checking that the stored value is still the same as when the message was originally sent will cause inconsistencies.</span></span> <span data-ttu-id="5dcd7-478">可将 Azure 服务总线队列配置为自动删除重复消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-478">Azure Service Bus queues can be configured to automatically remove duplicated messages.</span></span>
  * <span data-ttu-id="5dcd7-479">某些消息传送系统（例如 Azure 存储队列和 Azure 服务总线队列）支持用于指示已从队列中读取消息次数的取消排队计数属性。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-479">Some messaging systems, such as Azure storage queues and Azure Service Bus queues, support a de-queue count property that indicates the number of times a message has been read from the queue.</span></span> <span data-ttu-id="5dcd7-480">这在处理重复消息和有害消息时可能很有用。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-480">This can be useful in handling repeated and poison messages.</span></span> <span data-ttu-id="5dcd7-481">有关详细信息，请参阅[异步消息传送入门](https://msdn.microsoft.com/library/dn589781.aspx)和[幂等模式](https://blog.jonathanoliver.com/idempotency-patterns/)。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-481">For more information, see [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx) and [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/).</span></span>

## <a name="scaling-and-performance-considerations"></a><span data-ttu-id="5dcd7-482">缩放和性能注意事项</span><span class="sxs-lookup"><span data-stu-id="5dcd7-482">Scaling and performance considerations</span></span>
<span data-ttu-id="5dcd7-483">后台任务必须提供足够的性能，确保它们不会阻止应用程序，或者不会因系统负载不足而延迟操作时导致不一致。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-483">Background tasks must offer sufficient performance to ensure they do not block the application, or cause inconsistencies due to delayed operation when the system is under load.</span></span> <span data-ttu-id="5dcd7-484">通常，可以通过缩放托管后台任务的计算实例来提高性能。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-484">Typically, performance is improved by scaling the compute instances that host the background tasks.</span></span> <span data-ttu-id="5dcd7-485">规划和设计后台任务时，请注意以下有关伸缩性和性能的要点：</span><span class="sxs-lookup"><span data-stu-id="5dcd7-485">When you are planning and designing background tasks, consider the following points around scalability and performance:</span></span>

* <span data-ttu-id="5dcd7-486">Azure 根据当前的需求和负载或预定义的计划，支持对 Web 应用、云服务 Web 角色和辅助角色以及虚拟机托管的部署使用自动缩放（向外缩放和向内缩放）。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-486">Azure supports autoscaling (both scaling out and scaling back in) based on current demand and load--or on a predefined schedule, for Web Apps, Cloud Services web and worker roles, and Virtual Machines hosted deployments.</span></span> <span data-ttu-id="5dcd7-487">使用此功能可确保整个应用程序具有足够的性能，同时将运行时成本降到最低。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-487">Use this feature to ensure that the application as a whole has sufficient performance capabilities while minimizing runtime costs.</span></span>
* <span data-ttu-id="5dcd7-488">当后台任务具有与云服务应用程序其他部分（例如，UI 或数据访问层等组件）的不同的性能时，将不同辅助角色的后台任务托管在一起可让 UI 和辅助任务角色单独进行缩放以管理负载。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-488">Where background tasks have a different performance capability from the other parts of a Cloud Services application (for example, the UI or components such as the data access layer), hosting the background tasks together in a separate worker role allows the UI and background task roles to scale independently to manage the load.</span></span> <span data-ttu-id="5dcd7-489">如果多个后台任务彼此有明显不同的性能，请考虑将它们分割成不同的辅助角色并单独缩放每个角色类型。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-489">If multiple background tasks have significantly different performance capabilities from each other, consider dividing them into separate worker roles and scaling each role type independently.</span></span> <span data-ttu-id="5dcd7-490">但请注意，相比将所有任务合并成较少的角色，这可能会增加运行时成本。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-490">However, note that this might increase runtime costs compared to combining all the tasks into fewer roles.</span></span>
* <span data-ttu-id="5dcd7-491">只是缩放角色可能不足以防止在低负载下损失性能。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-491">Simply scaling the roles might not be sufficient to prevent loss of performance under load.</span></span> <span data-ttu-id="5dcd7-492">还可能需要缩放存储队列和其他资源，以防止整体处理链的单个点变成瓶颈。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-492">You might also need to scale storage queues and other resources to prevent a single point of the overall processing chain from becoming a bottleneck.</span></span> <span data-ttu-id="5dcd7-493">另外，请考虑其他限制，例如存储的最大吞吐量，以及应用程序的其他服务和后台任务依赖的服务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-493">Also, consider other limitations, such as the maximum throughput of storage and other services that the application and the background tasks rely on.</span></span>
* <span data-ttu-id="5dcd7-494">必须针对缩放设计后台任务。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-494">Background tasks must be designed for scaling.</span></span> <span data-ttu-id="5dcd7-495">例如，后台任务必须能够动态检测正在使用的存储队列数，以侦听相应的队列或向其发送消息。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-495">For example, they must be able to dynamically detect the number of storage queues in use in order to listen on or send messages to the appropriate queue.</span></span>
* <span data-ttu-id="5dcd7-496">默认情况下，Web 作业会随着其关联的 Azure Web 应用实例进行缩放。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-496">By default, WebJobs scale with their associated Azure Web Apps instance.</span></span> <span data-ttu-id="5dcd7-497">但是，如果只想要将 Web 作业当作单个实例运行，可以创建包含 JSON 数据 { "is_singleton": true } 的 Settings.job 文件。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-497">However, if you want a WebJob to run as only a single instance, you can create a Settings.job file that contains the JSON data **{ "is_singleton": true }**.</span></span> <span data-ttu-id="5dcd7-498">这会强制 Azure 只运行 Web 作业的一个实例，即使关联的 Web 应用有多个实例。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-498">This forces Azure to only run one instance of the WebJob, even if there are multiple instances of the associated web app.</span></span> <span data-ttu-id="5dcd7-499">对于必须以单个实例运行的计划作业而言，这可能是有用的方法。</span><span class="sxs-lookup"><span data-stu-id="5dcd7-499">This can be a useful technique for scheduled jobs that must run as only a single instance.</span></span>

## <a name="related-patterns"></a><span data-ttu-id="5dcd7-500">相关模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-500">Related patterns</span></span>
* [<span data-ttu-id="5dcd7-501">异步消息传送入门</span><span class="sxs-lookup"><span data-stu-id="5dcd7-501">Asynchronous Messaging Primer</span></span>](https://msdn.microsoft.com/library/dn589781.aspx)
* [<span data-ttu-id="5dcd7-502">自动缩放指南</span><span class="sxs-lookup"><span data-stu-id="5dcd7-502">Autoscaling Guidance</span></span>](https://msdn.microsoft.com/library/dn589774.aspx)
* [<span data-ttu-id="5dcd7-503">补偿事务模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-503">Compensating Transaction Pattern</span></span>](../patterns/compensating-transaction.md)
* [<span data-ttu-id="5dcd7-504">使用者竞争模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-504">Competing Consumers Pattern</span></span>](../patterns/competing-consumers.md)
* [<span data-ttu-id="5dcd7-505">计算分区指南</span><span class="sxs-lookup"><span data-stu-id="5dcd7-505">Compute Partitioning Guidance</span></span>](https://msdn.microsoft.com/library/dn589773.aspx)
* [<span data-ttu-id="5dcd7-506">计算资源整合模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-506">Compute Resource Consolidation Pattern</span></span>](https://msdn.microsoft.com/library/dn589778.aspx)
* [<span data-ttu-id="5dcd7-507">守护程序模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-507">Gatekeeper Pattern</span></span>](../patterns/gatekeeper.md)
* [<span data-ttu-id="5dcd7-508">领导选拔模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-508">Leader Election Pattern</span></span>](../patterns/leader-election.md)
* [<span data-ttu-id="5dcd7-509">管道和筛选器模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-509">Pipes and Filters Pattern</span></span>](../patterns/pipes-and-filters.md)
* [<span data-ttu-id="5dcd7-510">优先级队列模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-510">Priority Queue Pattern</span></span>](../patterns/priority-queue.md)
* [<span data-ttu-id="5dcd7-511">基于队列的负载调节模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-511">Queue-based Load Leveling Pattern</span></span>](../patterns/queue-based-load-leveling.md)
* [<span data-ttu-id="5dcd7-512">计划程序代理监督程序模式</span><span class="sxs-lookup"><span data-stu-id="5dcd7-512">Scheduler Agent Supervisor Pattern</span></span>](../patterns/scheduler-agent-supervisor.md)

## <a name="more-information"></a><span data-ttu-id="5dcd7-513">详细信息</span><span class="sxs-lookup"><span data-stu-id="5dcd7-513">More information</span></span>
* [<span data-ttu-id="5dcd7-514">执行后台任务</span><span class="sxs-lookup"><span data-stu-id="5dcd7-514">Executing Background Tasks</span></span>](https://msdn.microsoft.com/library/ff803365.aspx)
* <span data-ttu-id="5dcd7-515">[Azure 云服务角色生命周期](https://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle)（视频）</span><span class="sxs-lookup"><span data-stu-id="5dcd7-515">[Azure Cloud Services Role Lifecycle](https://channel9.msdn.com/Series/Windows-Azure-Cloud-Services-Tutorials/Windows-Azure-Cloud-Services-Role-Lifecycle) (video)</span></span>
* [<span data-ttu-id="5dcd7-516">什么是 Azure WebJobs SDK</span><span class="sxs-lookup"><span data-stu-id="5dcd7-516">What is the Azure WebJobs SDK</span></span>](https://docs.microsoft.com/azure/app-service-web/websites-dotnet-webjobs-sdk)
* [<span data-ttu-id="5dcd7-517">使用 WebJobs 运行后台任务</span><span class="sxs-lookup"><span data-stu-id="5dcd7-517">Run Background tasks with WebJobs</span></span>](https://docs.microsoft.com/azure/app-service-web/web-sites-create-web-jobs)
* [<span data-ttu-id="5dcd7-518">Azure 队列和服务总线队列 - 比较与对照</span><span class="sxs-lookup"><span data-stu-id="5dcd7-518">Azure Queues and Service Bus Queues - Compared and Contrasted</span></span>](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-azure-and-service-bus-queues-compared-contrasted)
* [<span data-ttu-id="5dcd7-519">如何在云服务中启用诊断</span><span class="sxs-lookup"><span data-stu-id="5dcd7-519">How to Enable Diagnostics in a Cloud Service</span></span>](https://docs.microsoft.com/azure/cloud-services/cloud-services-dotnet-diagnostics)

