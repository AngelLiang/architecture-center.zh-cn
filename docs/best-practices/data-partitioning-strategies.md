---
title: 数据分区策略
titleSuffix: Best practices for cloud applications
description: 有关隔离数据分区以便对其进行单独管理和访问的指导。
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 4f973a6173e882d6ae839833bd3c5bf86f8d7fb6
ms.sourcegitcommit: 273e690c0cfabbc3822089c7d8bc743ef41d2b6e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/08/2019
ms.locfileid: "55898130"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="c11ef-103">数据分区策略</span><span class="sxs-lookup"><span data-stu-id="c11ef-103">Data partitioning strategies</span></span>

<span data-ttu-id="c11ef-104">本文介绍在各种 Azure 数据存储中进行数据分区的一些策略。</span><span class="sxs-lookup"><span data-stu-id="c11ef-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="c11ef-105">有关数据分区时间和最佳做法的常规指南，请参阅[数据分区](./data-partitioning.md)</span><span class="sxs-lookup"><span data-stu-id="c11ef-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="c11ef-106">Azure SQL 数据库分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="c11ef-107">单个 SQL 数据库对其包含的数据列施加了限制。</span><span class="sxs-lookup"><span data-stu-id="c11ef-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="c11ef-108">吞吐量受体系结构因素及数据库支持的并发连接数的约束。</span><span class="sxs-lookup"><span data-stu-id="c11ef-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="c11ef-109">[弹性池](/azure/sql-database/sql-database-elastic-pool)支持对 SQL 数据库进行水平缩放。</span><span class="sxs-lookup"><span data-stu-id="c11ef-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="c11ef-110">使用弹性池，可以将数据分区到分布于多个 SQL 数据库的分片中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="c11ef-111">此外，还可以随着需要处理的数据量的增长和缩减，增加或删除分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="c11ef-112">使用弹性池还有助于在数据库之间分散负载，减少争用。</span><span class="sxs-lookup"><span data-stu-id="c11ef-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="c11ef-113">每个分片将作为 SQL 数据库实施。</span><span class="sxs-lookup"><span data-stu-id="c11ef-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="c11ef-114">一个分片可以保存多个数据集（称为 *shardlet*）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="c11ef-115">每个数据库将维护描述其所包含的 shardlet 的元数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="c11ef-116">shardlet 可以是单个数据项，也可以是一组共享同一 shardlet 键的项。</span><span class="sxs-lookup"><span data-stu-id="c11ef-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="c11ef-117">例如，在多租户应用程序中，shardlet 键可以是租户 ID，一个租户的所有数据可以保存在同一 shardlet 中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="c11ef-118">客户端应用程序负责将数据集与 shardlet 键相关联。</span><span class="sxs-lookup"><span data-stu-id="c11ef-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="c11ef-119">独立的 SQL 数据库将充当全局分片映射管理器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="c11ef-120">此数据库有一个列表，其中包含系统中的所有分片和 shardlet。</span><span class="sxs-lookup"><span data-stu-id="c11ef-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="c11ef-121">应用程序在连接到分片映射管理器数据库后，可以获取分片映射的副本。</span><span class="sxs-lookup"><span data-stu-id="c11ef-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="c11ef-122">它在本地缓存分片映射，并使用该映射将数据请求路由到相应的分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="c11ef-123">此功能隐藏在[弹性数据库客户端库](/azure/sql-database/sql-database-elastic-database-client-library)（适用于 Java 和 .NET）中的一系列 API 之后。</span><span class="sxs-lookup"><span data-stu-id="c11ef-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="c11ef-124">有关弹性工具的详细信息，请参阅[使用 Azure SQL 数据库进行横向扩展](/azure/sql-database/sql-database-elastic-scale-introduction)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="c11ef-125">若要减少延迟并提高可用性，可以复制全局分片映射管理器数据库。</span><span class="sxs-lookup"><span data-stu-id="c11ef-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="c11ef-126">使用高级定价层时，可以配置活动异地复制，将数据持续复制到其他区域中的数据库。</span><span class="sxs-lookup"><span data-stu-id="c11ef-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="c11ef-127">也可使用 [Azure SQL 数据同步](/azure/sql-database/sql-database-sync-data)或 [Azure 数据工厂](/azure/data-factory/)，跨区域复制分片映射管理器数据库。</span><span class="sxs-lookup"><span data-stu-id="c11ef-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="c11ef-128">这种形式的复制将定期运行，更适合分片映射不经常更改的情况，且不需要高级层。</span><span class="sxs-lookup"><span data-stu-id="c11ef-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="c11ef-129">弹性数据库提供了两种方案用于将数据映射到 shardlet 并将 shardlet 存储在分片中：</span><span class="sxs-lookup"><span data-stu-id="c11ef-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="c11ef-130">**列表分片映射**将单个键关联到 shardlet。</span><span class="sxs-lookup"><span data-stu-id="c11ef-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="c11ef-131">例如，在多租户系统中，每个租户的数据可与唯一的键相关联，并存储在自身的 shardlet 中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="c11ef-132">为了保证隔离，可将每个 shardlet 都保存在自身的分片中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![使用列表分片映射将租户数据存储在独立分片中](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="c11ef-134">**范围分片映射**将一组连续键值关联到一个 shardlet。</span><span class="sxs-lookup"><span data-stu-id="c11ef-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="c11ef-135">例如，可以将一组租户（每个都有自己的键）的数据组合到同一 shardlet 中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="c11ef-136">此方案的开销低于第一种方案，因为租户共享数据存储，但隔离性较低。</span><span class="sxs-lookup"><span data-stu-id="c11ef-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![使用范围分片映射来存储分片中租户范围的数据](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="c11ef-138">单个分片可以包含多个 shardlet 的数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="c11ef-139">例如，可以使用列表 shardlet 将不同非连续租户的数据存储在同一分片中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="c11ef-140">还可以混合同一分片中的范围 shardlet 和列表 shardlet，虽然这些 shardlet 会通过不同映射来寻址。</span><span class="sxs-lookup"><span data-stu-id="c11ef-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="c11ef-141">下图显示了此方式：</span><span class="sxs-lookup"><span data-stu-id="c11ef-141">The following diagram shows this approach:</span></span>

![实施多个分片映射](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="c11ef-143">在数据量伸缩时，可以通过弹性池添加和删除分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="c11ef-144">客户端应用程序可以动态创建和删除分片，并以透明方式更新分片映射管理器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="c11ef-145">但删除分片是破坏性操作，还需要删除该分片中的所有数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="c11ef-146">如果应用程序需要将一个分片拆分成两个独立的分片或者将分片组合在一起，请使用[拆分/合并工具](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="c11ef-147">该工具作为 Azure Web 服务运行，可以在分片之间安全地迁移数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="c11ef-148">分区方案可能会显著影响系统的性能。</span><span class="sxs-lookup"><span data-stu-id="c11ef-148">The partitioning scheme can significantly impact the performance of your system.</span></span> <span data-ttu-id="c11ef-149">它还会影响添加或删除分片的速率，或者跨分片对数据重新分区的速率。</span><span class="sxs-lookup"><span data-stu-id="c11ef-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="c11ef-150">请考虑以下要点：</span><span class="sxs-lookup"><span data-stu-id="c11ef-150">Consider the following points:</span></span>

- <span data-ttu-id="c11ef-151">将一起使用的数据组合到同一分片中，避免从多个分片访问数据的操作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="c11ef-152">分片本身就是 SQL 数据库，跨数据库联接必须在客户端执行。</span><span class="sxs-lookup"><span data-stu-id="c11ef-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="c11ef-153">尽管 SQL 数据库不支持跨数据库联接，但你可以使用弹性数据库工具执行[多分片查询](/azure/sql-database/sql-database-elastic-scale-multishard-querying)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [mutli-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="c11ef-154">多分片查询会将单个查询发送到每个数据库，然后将结果合并在一起。</span><span class="sxs-lookup"><span data-stu-id="c11ef-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="c11ef-155">请不要设计在分片之间具有依赖性的系统。</span><span class="sxs-lookup"><span data-stu-id="c11ef-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="c11ef-156">一个数据库中的引用完整性约束、触发器和存储过程不能引用另一个数据库中的对象。</span><span class="sxs-lookup"><span data-stu-id="c11ef-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="c11ef-157">如果引用数据频繁地供查询使用，请考虑跨分片复制该数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="c11ef-158">此方法不需跨数据库联接数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="c11ef-159">在理想的情况下，此类数据应该是静态或不怎么变化的，以最大限度地减少复制工作量并减少数据变陈旧的可能性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="c11ef-160">属于同一分片映射的 shardlet 应该有相同的架构。</span><span class="sxs-lookup"><span data-stu-id="c11ef-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="c11ef-161">SQL 数据库不会强制实施此规则，但如果每个 shardlet 都有不同的架构，则数据管理和查询将变得非常复杂。</span><span class="sxs-lookup"><span data-stu-id="c11ef-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="c11ef-162">为了避免这种情况，请为每个架构创建单独的分配映射。</span><span class="sxs-lookup"><span data-stu-id="c11ef-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="c11ef-163">请记住，属于不同 shardlet 的数据可以存储在相同的分片中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="c11ef-164">只有分片中的数据支持事务操作，而跨分片的数据并不支持。</span><span class="sxs-lookup"><span data-stu-id="c11ef-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="c11ef-165">事务可以跨 shardlet，前提是它们属于同一分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="c11ef-166">因此，如果业务逻辑需要执行事务，请将数据存储在同一分片中，或者实施最终一致性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="c11ef-167">将分片放置在访问这些分片中的数据的用户的附近。</span><span class="sxs-lookup"><span data-stu-id="c11ef-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="c11ef-168">此策略有助于缩短延迟。</span><span class="sxs-lookup"><span data-stu-id="c11ef-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="c11ef-169">避免混合高度活跃和相对不活跃的分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="c11ef-170">尽量跨分片平均分散负载。</span><span class="sxs-lookup"><span data-stu-id="c11ef-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="c11ef-171">这可能需要对分片键进行哈希处理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="c11ef-172">如果要按地域查找分片，请确保哈希键映射到的 shardlet 保存在访问该数据的用户附近存储的分片中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="c11ef-173">将 Azure 表存储分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="c11ef-174">Azure 表存储是存储的键/值，专为分区而设计。</span><span class="sxs-lookup"><span data-stu-id="c11ef-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="c11ef-175">所有实体都存储在分区中，分区在内部由 Azure 表存储管理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="c11ef-176">存储在表中的每个实体需要提供一个包含两个部分的分键，其中包括：</span><span class="sxs-lookup"><span data-stu-id="c11ef-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="c11ef-177">**分区键**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-177">**The partition key**.</span></span> <span data-ttu-id="c11ef-178">这是一个字符串值，用于确定 Azure 表存储会在哪个分区中放置实体。</span><span class="sxs-lookup"><span data-stu-id="c11ef-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="c11ef-179">具有相同分区键的所有实体存储在同一分区中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="c11ef-180">**行键**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-180">**The row key**.</span></span> <span data-ttu-id="c11ef-181">这是一个字符串值，用于标识分区中的实体。</span><span class="sxs-lookup"><span data-stu-id="c11ef-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="c11ef-182">分区中的所有实体已按此键的词法升序排序。</span><span class="sxs-lookup"><span data-stu-id="c11ef-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="c11ef-183">每个实体的分区键/行键组合必须是唯一的，且长度不能超过 1 KB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="c11ef-184">如果将具有先前未用过的分区键的实体添加到表中，Azure 表存储将为此实体创建新的分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="c11ef-185">具有相同分区键的其他实体将存储在同一分区中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="c11ef-186">此机制将有效地实施自动向外扩展策略。</span><span class="sxs-lookup"><span data-stu-id="c11ef-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="c11ef-187">每个分区存储在 Azure 数据中心的同一服务器上，这样可以确保从单个分区检索数据的查询快速运行。</span><span class="sxs-lookup"><span data-stu-id="c11ef-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="c11ef-188">Microsoft 已发布 Azure 存储的[可伸缩性目标]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="c11ef-189">如果系统可能会超出这些限制，请考虑将实体拆分成多个表。</span><span class="sxs-lookup"><span data-stu-id="c11ef-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="c11ef-190">使用垂直分区，并将字段分割成很有可能一起访问的组。</span><span class="sxs-lookup"><span data-stu-id="c11ef-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="c11ef-191">下图显示了示例存储帐户的逻辑结构。</span><span class="sxs-lookup"><span data-stu-id="c11ef-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="c11ef-192">存储帐户包含三个表：“客户信息”、“产品信息”和“订单信息”。</span><span class="sxs-lookup"><span data-stu-id="c11ef-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![示例存储帐户中的表和分区](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="c11ef-194">每个表有多个分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="c11ef-195">在“客户信息”表中，数据已根据客户所在的城市分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="c11ef-196">行键包含客户 ID。</span><span class="sxs-lookup"><span data-stu-id="c11ef-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="c11ef-197">在“产品信息”表中，产品按产品类别分区，行键包含产品编号。</span><span class="sxs-lookup"><span data-stu-id="c11ef-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="c11ef-198">在“订单信息”表中，订单按订购日期分区，行键指定收到订单的时间。</span><span class="sxs-lookup"><span data-stu-id="c11ef-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="c11ef-199">请注意，所有数据都已按行键在每个分区中排序。</span><span class="sxs-lookup"><span data-stu-id="c11ef-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="c11ef-200">在设计 Azure 表存储的实体时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="c11ef-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="c11ef-201">按数据访问方式选择分区键和行键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="c11ef-202">选择支持大多数查询的分区键/行键组合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="c11ef-203">最有效的查询将通过指定分区键和行键来检索数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="c11ef-204">可以通过扫描单个分区来满足指定分区键和行键范围的查询。</span><span class="sxs-lookup"><span data-stu-id="c11ef-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="c11ef-205">这是相当快速的方法，因为数据以行键的顺序保存。</span><span class="sxs-lookup"><span data-stu-id="c11ef-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="c11ef-206">如果查询未指定要扫描的分区，则必须扫描每个分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="c11ef-207">如果实体有一个自然键，请使用它作为分区键，并指定空白字符串作为行键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="c11ef-208">如果实体的复合键包含两个属性，请选择最不容易变化的属性作为分区键，另一个属性作为行键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="c11ef-209">如果实体有两个以上的键属性，请使用属性的串联来提供分区键和行键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="c11ef-210">如果使用分区键和行键以外的字段定期执行查找数据的查询，请考虑实施[索引表模式](../patterns/index-table.md)，或者考虑使用另一个支持索引编制操作的数据存储，例如 Cosmos DB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="c11ef-211">如果使用单调序列（例如“0001”、“0002”、“0003”）生成分区键，而每个分区只包含有限的数据量，则 Azure 表存储可用物理方式将同一服务器上的这些分区分组合在一起。</span><span class="sxs-lookup"><span data-stu-id="c11ef-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="c11ef-212">Azure 存储假设应用程序很可能在连续范围的分区中执行查询（范围查询），并已针对此情况进行优化。</span><span class="sxs-lookup"><span data-stu-id="c11ef-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="c11ef-213">但是，这种方法可能会导致热点，因为新实体的所有插入可能集中在连续范围的一端。</span><span class="sxs-lookup"><span data-stu-id="c11ef-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="c11ef-214">这也会降低伸缩性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-214">It can also reduce scalability.</span></span> <span data-ttu-id="c11ef-215">若要更均衡地分散负载，请考虑对分区键进行哈希处理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="c11ef-216">Azure 表存储支持属于相同分区的实体的事务操作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="c11ef-217">应用程序可以原子单位的形式执行多次插入、更新、删除、替换或合并操作，前提是事务不包含 100 个以上的实体，且请求的有效负载不超过 4 MB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="c11ef-218">跨多个分区的操作不是事务式的，并且可能需要实施最终一致性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="c11ef-219">有关表存储和事务的详细信息，请参阅[执行实体组事务]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="c11ef-220">考虑分区键的粒度：</span><span class="sxs-lookup"><span data-stu-id="c11ef-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="c11ef-221">对每个实体使用相同的分区键会生成单个分区，该分区保存在一个服务器上。</span><span class="sxs-lookup"><span data-stu-id="c11ef-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="c11ef-222">这可以防止分区横向扩展，可以将负载集中在单个服务器上。</span><span class="sxs-lookup"><span data-stu-id="c11ef-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="c11ef-223">因此，这种方法只适合存储少量实体。</span><span class="sxs-lookup"><span data-stu-id="c11ef-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="c11ef-224">但是，它确实能确保所有实体都可以参与实体组事务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="c11ef-225">对每个实体使用唯一的分区键使表存储服务为每个实体创建不同的分区，可能会导致大量的小分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="c11ef-226">这种方法比使用单个分区键更具伸缩性，但是无法进行实体组事务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="c11ef-227">此外，检索多个实体的查询可能涉及到读取多台服务器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="c11ef-228">但是，如果应用程序执行范围查询，则对分区键使用单调序列可能有助于优化这些查询。</span><span class="sxs-lookup"><span data-stu-id="c11ef-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="c11ef-229">跨实体子集共享分区键可将相同分区中的相关实体分组。</span><span class="sxs-lookup"><span data-stu-id="c11ef-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="c11ef-230">涉及使用实体组事务执行的相关实体的操作，以及提取一组相关实体的查询，可能通过访问单个服务器即可满足。</span><span class="sxs-lookup"><span data-stu-id="c11ef-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="c11ef-231">有关详细信息，请参阅 [Azure 存储表设计指南]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="c11ef-232">将 Azure Blob 存储分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="c11ef-233">Azure Blob 存储可保存大型二进制对象。</span><span class="sxs-lookup"><span data-stu-id="c11ef-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="c11ef-234">在需要快速上传或下载大量数据的情况下，请使用块 Blob。</span><span class="sxs-lookup"><span data-stu-id="c11ef-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="c11ef-235">对需要随机而不是串行访问部分数据的应用程序使用页 Blob。</span><span class="sxs-lookup"><span data-stu-id="c11ef-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="c11ef-236">每个 Blob（块或页）保存在 Azure 存储帐户中的容器内。</span><span class="sxs-lookup"><span data-stu-id="c11ef-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="c11ef-237">可以使用容器将具有相同安全需求的相关 Blob 分组在一起。</span><span class="sxs-lookup"><span data-stu-id="c11ef-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="c11ef-238">这种分组是逻辑性的，而不是物理性的。</span><span class="sxs-lookup"><span data-stu-id="c11ef-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="c11ef-239">在容器中，每个 Blob 都有唯一的名称。</span><span class="sxs-lookup"><span data-stu-id="c11ef-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="c11ef-240">Blob 的分区键是帐户名称 + 容器名称 + Blob 名称。</span><span class="sxs-lookup"><span data-stu-id="c11ef-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="c11ef-241">分区键用于将数据分区成多个范围，会在整个系统上对这些范围进行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="c11ef-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="c11ef-242">尽管可以在众多服务器间分布 Blob 以便扩大对其的访问权限，但只能由单个服务器为单个 Blob 提供服务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="c11ef-243">如果命名方案使用时间戳或数字标识符，则可能导致过多的流量进入一个分区，限制系统进行有效的负载均衡。</span><span class="sxs-lookup"><span data-stu-id="c11ef-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="c11ef-244">例如，如果日常操作使用有时间戳（如 *yyyy-mm-dd*）的 Blob 对象，则该操作的所有流量都会进入单个分区服务器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="c11ef-245">为了避免这种情况，考虑在名称前加上 3 位数哈希。</span><span class="sxs-lookup"><span data-stu-id="c11ef-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="c11ef-246">有关详细信息，请参阅[分区命名约定](/azure/storage/common/storage-performance-checklist#subheading47)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="c11ef-247">写入单个块或页的操作是原子操作，但跨块、页或 Blob 的操作不是。</span><span class="sxs-lookup"><span data-stu-id="c11ef-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="c11ef-248">如果需要在跨块、页和 Blob 写入操作时确保一致性，需要使用 Blob 租约取消写入锁。</span><span class="sxs-lookup"><span data-stu-id="c11ef-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="c11ef-249">将 Azure 存储队列分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="c11ef-250">Azure 存储队列可让你在进程之间实施异步消息传送。</span><span class="sxs-lookup"><span data-stu-id="c11ef-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="c11ef-251">Azure 存储帐户可以包含任意数目的队列，而每个队列可以包含任意数目的消息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="c11ef-252">唯一的限制是存储帐户中的可用空间。</span><span class="sxs-lookup"><span data-stu-id="c11ef-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="c11ef-253">单个消息的大小上限是 64 KB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="c11ef-254">如果需要比这个限制更大的消息，请考虑改用 Azure 服务总线队列。</span><span class="sxs-lookup"><span data-stu-id="c11ef-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="c11ef-255">每个存储队列在其所属的存储帐户中都有唯一的名称。</span><span class="sxs-lookup"><span data-stu-id="c11ef-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="c11ef-256">Azure 根据名称将队列分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="c11ef-257">同一个队列的所有消息存储在同一分区中，由单个服务器所控制。</span><span class="sxs-lookup"><span data-stu-id="c11ef-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="c11ef-258">不同的队列可以由不同的服务器管理，以帮助平衡负载。</span><span class="sxs-lookup"><span data-stu-id="c11ef-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="c11ef-259">服务器的队列分配对于应用程序和用户而言是透明的。</span><span class="sxs-lookup"><span data-stu-id="c11ef-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="c11ef-260">在大型应用程序中，请勿将相同的存储队列用于应用程序的所有实例，因为这种方法可能使托管队列的服务器成为热点。</span><span class="sxs-lookup"><span data-stu-id="c11ef-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="c11ef-261">请将不同的队列用于应用程序的不同功能区域。</span><span class="sxs-lookup"><span data-stu-id="c11ef-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="c11ef-262">Azure 存储队列不支持事务，因此将消息定向到不同的队列对消息传送一致性的影响应该很小。</span><span class="sxs-lookup"><span data-stu-id="c11ef-262">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="c11ef-263">Azure 存储队列每秒最多可以处理 2,000 个消息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="c11ef-264">如果需要以更高的速率处理消息，请考虑创建多个队列。</span><span class="sxs-lookup"><span data-stu-id="c11ef-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="c11ef-265">例如，在全局应用程序中的独立存储帐户中创建独立的存储队列，以处理每个区域中运行的应用程序实例。</span><span class="sxs-lookup"><span data-stu-id="c11ef-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="c11ef-266">将 Azure 服务总线分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="c11ef-267">Azure 服务总线使用消息中转站处理发送到服务总线队列或主题的消息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="c11ef-268">默认情况下，所有发送到队列或主题的消息都由相同的消息中转站进程处理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="c11ef-269">这种体系结构可限制消息队列的总体吞吐量。</span><span class="sxs-lookup"><span data-stu-id="c11ef-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="c11ef-270">但是，还可以在创建队列或主题时，将队列或主题分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="c11ef-271">为此，可将队列或主题描述的 *EnablePartitioning* 属性设为 *true*。</span><span class="sxs-lookup"><span data-stu-id="c11ef-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="c11ef-272">分区的队列或主题将分割成多个段，每个段都受到独立消息存储和消息中转站的支持。</span><span class="sxs-lookup"><span data-stu-id="c11ef-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="c11ef-273">服务总线负责创建和管理这些段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="c11ef-274">当应用程序将消息发布到分区的队列或主题时，服务总线会将消息分配给该队列或主题的段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="c11ef-275">当应用程序收到队列或订阅的消息时，服务总线会检查每个段中的下一条可用消息，然后将其传递给应用程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="c11ef-276">这种结构有助于跨消息代理和消息存储分散负载，提高伸缩性并提高可用性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="c11ef-277">如果有一个段的消息中转站或消息存储暂时无法使用，服务总线可以从某一个剩余的可用段检索消息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="c11ef-278">服务总线将消息分配给段，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c11ef-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="c11ef-279">如果消息属于会话，则 *SessionId* 属性值相同的所有消息都会发送到相同的段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="c11ef-280">如果消息不属于会话，但发件人已指定 *PartitionKey* 属性的值，则具有相同 *PartitionKey* 值的所有消息都将发送到相同的段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="c11ef-281">如果同时指定 *SessionId* 和 *PartitionKey* 属性，则两者需要设置为相同的值，否则消息会被拒绝。</span><span class="sxs-lookup"><span data-stu-id="c11ef-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="c11ef-282">如果未指定消息的 *SessionId* 和 *PartitionKey* 属性，但已启用重复侦测，则将使用 *MessageId* 属性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="c11ef-283">具有相同 *MessageId* 的所有消息定向到相同的段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="c11ef-284">如果消息不包含 *SessionId、PartitionKey* 或 *MessageId* 属性，则服务总线以有序方式案将消息分配给段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="c11ef-285">如果某个段不可用，服务总线将移到下一个段。</span><span class="sxs-lookup"><span data-stu-id="c11ef-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="c11ef-286">这意味着，消息传送基础结构中的暂时故障不造成消息发送操作失败。</span><span class="sxs-lookup"><span data-stu-id="c11ef-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="c11ef-287">确定是否或者如何将服务总线消息队列或主题分区时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="c11ef-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="c11ef-288">服务总线队列和主题在服务总线命名空间的范围内创建。</span><span class="sxs-lookup"><span data-stu-id="c11ef-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="c11ef-289">服务总线当前允许为每个命名空间最多创建 100 个分区的队列或主题。</span><span class="sxs-lookup"><span data-stu-id="c11ef-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="c11ef-290">每个服务总线命名空间都会给可用资源规定配额，例如每个主题的订阅数、每秒的并发发送和接收请求数，以及可以建立的最大并发连接数。</span><span class="sxs-lookup"><span data-stu-id="c11ef-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="c11ef-291">[服务总线配额]中记录了这些配额。</span><span class="sxs-lookup"><span data-stu-id="c11ef-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="c11ef-292">如果预期会超过这些值，请创建更多包含自身队列和主题的命名空间，并跨这些命名空间分散工作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="c11ef-293">例如，在每个区域的全局应用程序中创建不同的命名空间，并将应用程序实例配置为使用最接近命名空间中的队列和主题。</span><span class="sxs-lookup"><span data-stu-id="c11ef-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="c11ef-294">作为事务一部分发送的消息必须指定分区键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="c11ef-295">这可能是 *SessionId*、*PartitionKey* 或 *MessageId* 属性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="c11ef-296">作为相同事务一部分发送的所有消息必须指定相同的分区键，因为它们需要由相同的消息代理进程进行处理。</span><span class="sxs-lookup"><span data-stu-id="c11ef-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="c11ef-297">无法将消息发送到同一事务中的不同队列或主题。</span><span class="sxs-lookup"><span data-stu-id="c11ef-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="c11ef-298">无法将分区的队列或主题配置为在空闲状态时自动删除。</span><span class="sxs-lookup"><span data-stu-id="c11ef-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="c11ef-299">如果要构建跨平台解决方案或混合解决方案，当前无法将分区的队列和主题与高级消息队列协议 (AMQP) 配合使用。</span><span class="sxs-lookup"><span data-stu-id="c11ef-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="c11ef-300">将 Cosmos DB 分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="c11ef-301">Azure Cosmos DB 是可以使用 [Azure Cosmos DB SQL API][cosmosdb-sql-api] 存储 JSON 文档的 NoSQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="c11ef-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="c11ef-302">Cosmos DB 数据库中的文档是对象或其他数据片段的 JSON 序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="c11ef-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="c11ef-303">没有强制实施固定的架构，但是每个文档必须包含唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="c11ef-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="c11ef-304">文档已组织成集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-304">Documents are organized into collections.</span></span> <span data-ttu-id="c11ef-305">可将相关的文档统一分组在集合中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="c11ef-306">例如，在维护博客文章的系统中，可以将每篇博客文章的内容存储为某个集合中的文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="c11ef-307">还可以为每个主题类型创建集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="c11ef-308">或者，在多租户应用程序（例如可让不同作者控制和管理自己的博客文章的系统）中，可以根据作者将博客分区，并为每位作者创建独立的集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="c11ef-309">分配给集合的存储空间有弹性，并且可以根据需要缩小或增大。</span><span class="sxs-lookup"><span data-stu-id="c11ef-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="c11ef-310">Cosmos DB 支持按应用程序定义的分区键对数据自动分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="c11ef-311">“逻辑分区”是指用于存储单个分区键值对应的所有数据的分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="c11ef-312">分区键值相同的所有文档放置在同一逻辑分区内。</span><span class="sxs-lookup"><span data-stu-id="c11ef-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="c11ef-313">Cosmos DB 根据分区键的哈希来分配值。</span><span class="sxs-lookup"><span data-stu-id="c11ef-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="c11ef-314">逻辑分区的最大大小为 10 GB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="c11ef-315">因此，选择分区键是设计时的重要决定。</span><span class="sxs-lookup"><span data-stu-id="c11ef-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="c11ef-316">请选择值甚至访问模式的范围广的属性。</span><span class="sxs-lookup"><span data-stu-id="c11ef-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="c11ef-317">有关详细信息，请参阅 [Azure Cosmos DB 中的分区和规模](/azure/cosmos-db/partition-data)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="c11ef-318">每个 Cosmos DB 数据库都有一个性能级别用于确定它所获取的资源量。</span><span class="sxs-lookup"><span data-stu-id="c11ef-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="c11ef-319">性能级别与*请求单位* (RU) 比率限制关联。</span><span class="sxs-lookup"><span data-stu-id="c11ef-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="c11ef-320">RU 比率限制指定要保留的并可供该集合独占使用的资源量。</span><span class="sxs-lookup"><span data-stu-id="c11ef-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="c11ef-321">集合的成本取决于为该集合选择的性能级别。</span><span class="sxs-lookup"><span data-stu-id="c11ef-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="c11ef-322">性能级别（以及 RU 比率限制）越高，则费用就越高。</span><span class="sxs-lookup"><span data-stu-id="c11ef-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="c11ef-323">可以使用 Azure 门户来调整集合的性能级别。</span><span class="sxs-lookup"><span data-stu-id="c11ef-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="c11ef-324">有关详细信息，请参阅 [Azure Cosmos DB 中的请求单位][cosmos-db-ru]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="c11ef-325">如果 Cosmos DB 提供的分区机制不够用，则可能需要在应用程序级别进行数据分片。</span><span class="sxs-lookup"><span data-stu-id="c11ef-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="c11ef-326">文档集合提供一个自然机制用于在单一数据库中将数据分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="c11ef-327">实施分片的最简单方法是为每个分片创建一个集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="c11ef-328">容器是逻辑资源，可以跨一个或多个服务器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="c11ef-329">固定大小的容器最大限制为 10 GB，10,000 RU/s 吞吐量。</span><span class="sxs-lookup"><span data-stu-id="c11ef-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="c11ef-330">不限大小的容器没有最大存储大小，但必须指定分区键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="c11ef-331">使用应用程序分片时，客户端应用程序必须将请求定向到适当的分片，这通常是根据定义分片键的某些数据属性，通过实施自身的映射机制来实现的。</span><span class="sxs-lookup"><span data-stu-id="c11ef-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="c11ef-332">所有数据库在 Cosmos DB 数据库帐户的上下文中创建。</span><span class="sxs-lookup"><span data-stu-id="c11ef-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="c11ef-333">单个帐户可以包含多个数据库，并指定要在其中创建数据库的区域。</span><span class="sxs-lookup"><span data-stu-id="c11ef-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="c11ef-334">每个帐户还强制实施自身访问控制。</span><span class="sxs-lookup"><span data-stu-id="c11ef-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="c11ef-335">可以使用 Cosmos DB 帐户异地查找靠近需要访问帐户的用户的分片（数据库中的集合），并强制实施限制，以便只有这些用户才能连接到这些帐户。</span><span class="sxs-lookup"><span data-stu-id="c11ef-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="c11ef-336">确定如何使用 Cosmos DB SQL API 将数据分区时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="c11ef-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="c11ef-337">**Cosmos DB 数据库的可用资源受限于帐户的配额限制**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="c11ef-338">每个数据库可以保存许多集合，每个集合都与控制该集合 RU 比率限制（保留吞吐量）的性能级别相关联。</span><span class="sxs-lookup"><span data-stu-id="c11ef-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="c11ef-339">有关详细信息，请参阅 [Azure 订阅和服务限制、配额与约束][azure-limits]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="c11ef-340">**每个文档必须有一个可用于在保存该文档的集合中唯一标识该文档的属性**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="c11ef-341">此属性与分片键不同，后者定义文档要保存在哪个集合中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="c11ef-342">一个集合可以包含大量的文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="c11ef-343">理论上只受限于文档 ID 的最大长度。</span><span class="sxs-lookup"><span data-stu-id="c11ef-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="c11ef-344">文档 ID 最多可包含 255 个字符。</span><span class="sxs-lookup"><span data-stu-id="c11ef-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="c11ef-345">**针对文档的所有操作都在事务的上下文中执行。事务的范围包含该文档的集合。**</span><span class="sxs-lookup"><span data-stu-id="c11ef-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="c11ef-346">如果操作失败，已执行的工作会回滚。</span><span class="sxs-lookup"><span data-stu-id="c11ef-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="c11ef-347">当文档正在接受某项操作时，所做的任何更改将受限于快照级隔离。</span><span class="sxs-lookup"><span data-stu-id="c11ef-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="c11ef-348">例如，如果创建新文档的请求失败，此机制将保证另一个同时查询数据库的用户不会看到当时删除的部分文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="c11ef-349">**数据库查询的范围也限于集合级别**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="c11ef-350">单个查询只能从一个集合检索数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="c11ef-351">如果需要从多个集合检索数据，则必须分别查询每个集合，并将结果合并到应用程序代码中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="c11ef-352">**Cosmos DB 支持可与文档一起全部存储在集合中的可编程项**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="c11ef-353">这包括存储过程、用户定义的函数和触发器（以 JavaScript 编写）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="c11ef-354">这些项可以访问同一集合中的任何文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="c11ef-355">此外，这些项在环境事务的范围内运行（如果是由于针对文档执行了创建、删除或替换操作而激发了触发器），或者通过启动新的事务执行（如果是由于显式客户端请求结果而运行的存储过程）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="c11ef-356">如果可编程项中的代码引发异常，事务会回滚。</span><span class="sxs-lookup"><span data-stu-id="c11ef-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="c11ef-357">可以使用存储过程和触发器来维护文档之间的完整性和一致性，但这些文档必须属于同一集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="c11ef-358">**要在数据库中保存的集合应该不太可能会超过由集合的性能级别定义的吞吐量限制**。</span><span class="sxs-lookup"><span data-stu-id="c11ef-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="c11ef-359">有关详细信息，请参阅 [Azure Cosmos DB 中的请求单位][cosmos-db-ru]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="c11ef-360">如果预计会达到这些限制，请考虑在不同的帐户中跨数据库拆分集合，以减少每个集合的负载。</span><span class="sxs-lookup"><span data-stu-id="c11ef-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="c11ef-361">将 Azure 搜索分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-361">Partitioning Azure Search</span></span>

<span data-ttu-id="c11ef-362">搜索数据的功能通常是许多 web 应用程序提供的主要导航和浏览方法。</span><span class="sxs-lookup"><span data-stu-id="c11ef-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="c11ef-363">它可以帮助用户根据搜索条件的组合快速查找资源（例如，电子商务应用程序中的产品）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="c11ef-364">Azure 搜索服务针对 Web 内容提供全文搜索功能，并包括自动提示、根据近似的匹配内容建议查询，以及分面导航等功能。</span><span class="sxs-lookup"><span data-stu-id="c11ef-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="c11ef-365">有关详细信息，请参阅[什么是 Azure 搜索？]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="c11ef-366">Azure 搜索将可搜索的内容存储为数据库中的 JSON 文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="c11ef-367">可以定义一些索引，用于在这些文档中指定可搜索的字段，并将这些定义提供给 Azure 搜索。</span><span class="sxs-lookup"><span data-stu-id="c11ef-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="c11ef-368">当用户提交搜索请求时，Azure 搜索将使用适当的索引来查找匹配项。</span><span class="sxs-lookup"><span data-stu-id="c11ef-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="c11ef-369">为了减少争用，Azure 搜索使用的存储可以分割为 1、2、3、4、6 或 12 个分区，并且每个分区最多可以复制 6 次。</span><span class="sxs-lookup"><span data-stu-id="c11ef-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="c11ef-370">分区数目乘以副本数目的乘积称为*搜索单位* (SU)。</span><span class="sxs-lookup"><span data-stu-id="c11ef-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="c11ef-371">Azure 搜索的单个实例最多可以包含 36 个 SU（具有 12 个分区的数据库最多只支持 3 个副本）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="c11ef-372">需要支付分配给服务的每个 SU 的费用。</span><span class="sxs-lookup"><span data-stu-id="c11ef-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="c11ef-373">当可搜索内容的数量增加或搜索请求的比率增大时，可以将 SU 添加到 Azure 搜索的现有实例以处理额外的负载。</span><span class="sxs-lookup"><span data-stu-id="c11ef-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="c11ef-374">Azure 搜索本身可以跨分区平均分配文档。</span><span class="sxs-lookup"><span data-stu-id="c11ef-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="c11ef-375">目前不支持任何手动分区策略。</span><span class="sxs-lookup"><span data-stu-id="c11ef-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="c11ef-376">每个分区最多可以包含 1500 万个文档或占用 300 GB 存储空间（取两者中较小者）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="c11ef-377">最多可以创建 50 个索引。</span><span class="sxs-lookup"><span data-stu-id="c11ef-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="c11ef-378">服务的性能因文档的复杂性、可用索引以及网络延迟的影响而有所不同。</span><span class="sxs-lookup"><span data-stu-id="c11ef-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="c11ef-379">一般而言，单个副本 (1 SU) 每秒应该可以处理 15 个查询 (QPS)，不过，我们建议使用自己的数据执行基准计算，以获取更精确的吞吐量测量值。</span><span class="sxs-lookup"><span data-stu-id="c11ef-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="c11ef-380">有关详细信息，请参阅 [Azure 搜索中的服务限制]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="c11ef-381">可以将有限的一组数据类型存储在可搜索文档中，这些类型包括字符串、布尔值、数字数据、日期时间数据和一些地理数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="c11ef-382">有关详细信息，请参阅 Microsoft 网站上的 [支持的数据类型（Azure 搜索）]页。</span><span class="sxs-lookup"><span data-stu-id="c11ef-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="c11ef-383">只能有限地控制 Azure 搜索如何对每个服务实例的数据分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="c11ef-384">但是，在全局环境中，可以通过使用以下任一策略将服务本身分区，以进一步提高性能并减少延迟和争用：</span><span class="sxs-lookup"><span data-stu-id="c11ef-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="c11ef-385">在每个地理区域中创建 Azure 搜索的实例，并确保客户端应用程序定向到最靠近的可用实例。</span><span class="sxs-lookup"><span data-stu-id="c11ef-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="c11ef-386">此策略要求跨服务的所有实例及时复制对可搜索内容所做的任何更新。</span><span class="sxs-lookup"><span data-stu-id="c11ef-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="c11ef-387">创建双层 Azure 搜索：</span><span class="sxs-lookup"><span data-stu-id="c11ef-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="c11ef-388">每个区域中一个本地服务，其中包含用户在该区域中最常访问的数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="c11ef-389">用户可将请求定向到此处以加快查询速度，但返回的结果有限。</span><span class="sxs-lookup"><span data-stu-id="c11ef-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="c11ef-390">一个包含所有数据的全局服务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="c11ef-391">用户可将请求定向到此处以返回更完整的结果，但查询速度会变慢。</span><span class="sxs-lookup"><span data-stu-id="c11ef-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="c11ef-392">当搜索的数据存在明显的区域性差异时，最适合使用此方法。</span><span class="sxs-lookup"><span data-stu-id="c11ef-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="c11ef-393">将 Azure Redis 缓存分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="c11ef-394">Azure Redis 缓存在云中提供基于 Redis 键-值数据存储的共享缓存服务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="c11ef-395">顾名思义，Azure Redis 缓存旨在用作缓存解决方案。</span><span class="sxs-lookup"><span data-stu-id="c11ef-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="c11ef-396">它只用于保存暂时性数据，而不是用作永久性的数据存储。</span><span class="sxs-lookup"><span data-stu-id="c11ef-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="c11ef-397">如果缓存不可用，使用 Azure Redis 缓存的应用程序应能够继续工作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-397">Applications that use Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="c11ef-398">Azure Redis 缓存支持主要/辅助复制，可提供高可用性，但目前缓存大小上限为 53 GB。</span><span class="sxs-lookup"><span data-stu-id="c11ef-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="c11ef-399">如果需要更多的空间，则必须创建更多缓存。</span><span class="sxs-lookup"><span data-stu-id="c11ef-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="c11ef-400">有关详细信息，请参阅 [Azure Redis 缓存]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="c11ef-401">将 Redis 数据存储分区涉及到跨 Redis 服务的实例拆分数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="c11ef-402">每个实例构成单个分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="c11ef-403">Azure Redis 缓存将抽象化幕后的 Redis 服务，而不直接公开它们。</span><span class="sxs-lookup"><span data-stu-id="c11ef-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="c11ef-404">实施分区的最简单方法是创建多个 Azure Redis 缓存实例，并在其中分散数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="c11ef-405">可以将每个数据项与指定要在哪个缓存中存储该数据项的标识符（分区键）相关联。</span><span class="sxs-lookup"><span data-stu-id="c11ef-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="c11ef-406">然后，客户端应用程序逻辑可以使用此标识符将请求路由到相应的分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="c11ef-407">此方案非常简单，但如果分区方案发生更改（例如，如果已创建其他 Azure Redis 缓存实例），则可能需要重新配置客户端应用程序。</span><span class="sxs-lookup"><span data-stu-id="c11ef-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="c11ef-408">本机 Redis（非 Azure Redis 缓存）支持基于 Redis 群集的服务器端分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="c11ef-409">使用此方法时，可以使用哈希机制跨服务器平均分割数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="c11ef-410">每个 Redis 服务器将存储用于描述分区保存的哈希键范围的元数据，同时还包含有关哪些哈希键位于其他服务器上的分区中的信息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="c11ef-411">客户端应用程序只需将请求发送到任何参与方 Redis 服务器（可能是最靠近的服务器）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="c11ef-412">Redis 服务器检查客户端请求。</span><span class="sxs-lookup"><span data-stu-id="c11ef-412">The Redis server examines the client request.</span></span> <span data-ttu-id="c11ef-413">如果可以在本地解决，则执行请求的操作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="c11ef-414">否则将请求转发到相应的服务器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="c11ef-415">此模型是使用 Redis 群集实施的，Redis 网站上的 [Redis 群集教程]页上提供了更详细的说明。</span><span class="sxs-lookup"><span data-stu-id="c11ef-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="c11ef-416">Redis 群集对客户端应用程序而言是透明的。</span><span class="sxs-lookup"><span data-stu-id="c11ef-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="c11ef-417">其他 Redis 服务器可以添加到群集（数据将重新分区），而无需重新配置客户端。</span><span class="sxs-lookup"><span data-stu-id="c11ef-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c11ef-418">Azure Redis 缓存目前仅在[高级](/azure/azure-cache-for-redis/cache-how-to-premium-clustering)层中支持 Redis 群集功能。</span><span class="sxs-lookup"><span data-stu-id="c11ef-418">Azure Redis Cache currently supports Redis clustering in [premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) tier only.</span></span>

<span data-ttu-id="c11ef-419">Redis 网站上的 [Partitioning: how to split data among multiple Redis instances]（分区：如何在多个 Redis 实例之间拆分数据）页提供了有关使用 Redis 实施分区的更多信息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-419">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="c11ef-420">本部分的余下内容假设要实施客户端分区或代理辅助分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-420">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="c11ef-421">在确定如何使用 Azure Redis 缓存将数据分区时，请注意以下几点：</span><span class="sxs-lookup"><span data-stu-id="c11ef-421">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="c11ef-422">Azure Redis 缓存并非旨在用作永久性的数据存储，因此无论实施哪种分区方案，应用程序代码都必须能够从非缓存中位置检索数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-422">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="c11ef-423">应该将经常访问的数据一起保存在同一分区中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-423">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="c11ef-424">Redis 是一个功能强大的键-值存储，提供多种高度优化的机制用于建构数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-424">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="c11ef-425">这些机制可能是下列其中一种：</span><span class="sxs-lookup"><span data-stu-id="c11ef-425">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="c11ef-426">简单字符串（长度最大为 512 MB 的二进制数据）</span><span class="sxs-lookup"><span data-stu-id="c11ef-426">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="c11ef-427">列表等聚合类型（可充当队列和堆栈）</span><span class="sxs-lookup"><span data-stu-id="c11ef-427">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="c11ef-428">集（已排序和未排序）</span><span class="sxs-lookup"><span data-stu-id="c11ef-428">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="c11ef-429">哈希（可将相关的字段分组在一起，例如表示对象中字段的项）</span><span class="sxs-lookup"><span data-stu-id="c11ef-429">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="c11ef-430">聚合类型可让你将许多相关值与同一个键相关联。</span><span class="sxs-lookup"><span data-stu-id="c11ef-430">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="c11ef-431">Redis 键标识列表、集或哈希，而不是它包含的数据项。</span><span class="sxs-lookup"><span data-stu-id="c11ef-431">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="c11ef-432">可以在 Azure Redis 缓存中使用这些类型，Redis 网站上的 [数据类型]页已提供了说明。</span><span class="sxs-lookup"><span data-stu-id="c11ef-432">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="c11ef-433">例如，跟踪客户所下订单的电子商务系统部件中，每位客户的详细信息可能存储在 Redis 哈希中，使用客户 ID 键控。</span><span class="sxs-lookup"><span data-stu-id="c11ef-433">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="c11ef-434">每个哈希可以保存该客户的订单 ID 集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-434">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="c11ef-435">一个独立的 Redis 集可以保存订单（同样已结构化为哈希），使用订单 ID 键控。</span><span class="sxs-lookup"><span data-stu-id="c11ef-435">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="c11ef-436">图 8 显示了此结构。</span><span class="sxs-lookup"><span data-stu-id="c11ef-436">Figure 8 shows this structure.</span></span> <span data-ttu-id="c11ef-437">请注意，Redis 不实施任何形式的引用完整性，因此开发人员需要负责维护客户与订单之间的关系。</span><span class="sxs-lookup"><span data-stu-id="c11ef-437">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![记录客户订单及其详细信息的 Redis 存储中的建议结构](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="c11ef-439">*图 8.* 记录客户订单及其详细信息的 Redis 存储中的建议结构。</span><span class="sxs-lookup"><span data-stu-id="c11ef-439">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="c11ef-440">在 Redis 中，所有键都是二进制数据值（例如 Redis 字符串），最多可包含 512 MB 的数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-440">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="c11ef-441">在理论上，键几乎可以包含任何信息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-441">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="c11ef-442">但是，我们建议为键采用可以描述数据类型并标识实体的一致命名约定，但是该约定不可过长。</span><span class="sxs-lookup"><span data-stu-id="c11ef-442">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="c11ef-443">常见的做法是使用“entity_type:ID”形式的键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-443">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="c11ef-444">例如，可以使用“customer:99”来表示客户 ID 99 的键。</span><span class="sxs-lookup"><span data-stu-id="c11ef-444">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="c11ef-445">可以通过将相关信息存储在同一数据库的不同聚合中来实施垂直分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-445">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="c11ef-446">例如，在电子商务应用程序中，可以将经常访问的产品相关信息存储在一个 Redis 哈希中，将较少使用的详细信息存储在另一个 Redis 哈希中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-446">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="c11ef-447">这两个哈希可以使用同一产品 ID 作为键的一部分。</span><span class="sxs-lookup"><span data-stu-id="c11ef-447">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="c11ef-448">例如，可以使用“product: *nn*”（其中 *nn* 是产品 ID）来表示产品信息，使用“product_details: *nn*”来表示详细数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-448">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="c11ef-449">此策略可以帮助减少大多数查询可能检索的数据量。</span><span class="sxs-lookup"><span data-stu-id="c11ef-449">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="c11ef-450">可以重新分区 Redis 数据存储，但请记住，这是一项复杂且耗时的任务。</span><span class="sxs-lookup"><span data-stu-id="c11ef-450">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="c11ef-451">Redis 群集可以自动将数据重新分区，但是此功能无法在 Azure Redis 缓存中使用。</span><span class="sxs-lookup"><span data-stu-id="c11ef-451">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="c11ef-452">因此，在设计分区方案时，应该尽量在每个分区中保留足够的可用空间，以适应一段时间后数据预期增长。</span><span class="sxs-lookup"><span data-stu-id="c11ef-452">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="c11ef-453">但请记住，Azure Redis 缓存旨在暂时缓存数据，而保存在缓存中的数据具有有限的生存期（以生存时间 (TTL) 值指定）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-453">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="c11ef-454">对于相对容易变化的数据而言，TTL 可以短一点，但对于静态数据而言，TTL 可以更长一些。</span><span class="sxs-lookup"><span data-stu-id="c11ef-454">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="c11ef-455">如果此数据量可能会填满缓存，则应避免在缓存中存储大量长时间留存的数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-455">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="c11ef-456">如果空间价格不菲，可以指定一个逐出策略，让 Azure Redis 缓存删除数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-456">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="c11ef-457">使用 Azure Redis 缓存时，可以通过选择适当的定价层来指定缓存的最大大小（从 250 MB 到 53 GB）。</span><span class="sxs-lookup"><span data-stu-id="c11ef-457">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="c11ef-458">但是，创建 Azure Redis 缓存后，无法增大（或减小）其大小。</span><span class="sxs-lookup"><span data-stu-id="c11ef-458">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="c11ef-459">Redis 批处理与事务不能跨多个连接，因此受批处理或事务影响的所有数据应保存在同一数据库（分片）中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-459">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="c11ef-460">Redis 事务中的操作序列不一定是原子性的。</span><span class="sxs-lookup"><span data-stu-id="c11ef-460">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="c11ef-461">构成事务的命令已经过验证，并在执行之前已排入队列。</span><span class="sxs-lookup"><span data-stu-id="c11ef-461">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="c11ef-462">如果在此阶段期间发生错误，会丢弃整个队列。</span><span class="sxs-lookup"><span data-stu-id="c11ef-462">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="c11ef-463">但是，成功提交事务后，排入队列的命令就会按顺序运行。</span><span class="sxs-lookup"><span data-stu-id="c11ef-463">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="c11ef-464">如果任一命令失败，只有该命令停止运行。</span><span class="sxs-lookup"><span data-stu-id="c11ef-464">If any command fails, only that command stops running.</span></span> <span data-ttu-id="c11ef-465">队列中所有前面与后面的命令都将执行。</span><span class="sxs-lookup"><span data-stu-id="c11ef-465">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="c11ef-466">有关详细信息，请转到 Redis 网站上的 [Transactions]（事务）页。</span><span class="sxs-lookup"><span data-stu-id="c11ef-466">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="c11ef-467">Redis 支持有限数量的原子操作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-467">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="c11ef-468">这种类型的、支持多个键和值的操作只有 MGET 和 MSET 操作。</span><span class="sxs-lookup"><span data-stu-id="c11ef-468">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="c11ef-469">MGET 操作返回指定键列表的值集合，MSET 操作可以存储指定键列表的值集合。</span><span class="sxs-lookup"><span data-stu-id="c11ef-469">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="c11ef-470">如果需要使用这些操作，必须将 MSET 和 MGET 命令引用的键-值对存储在同一数据库中。</span><span class="sxs-lookup"><span data-stu-id="c11ef-470">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="c11ef-471">将 Azure Service Fabric 分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-471">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="c11ef-472">Azure Service Fabric 是在云中提供分布式应用程序的运行时的微服务平台。</span><span class="sxs-lookup"><span data-stu-id="c11ef-472">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="c11ef-473">Service Fabric 支持 .Net guest 可执行文件、有状态和无状态服务以及容器。</span><span class="sxs-lookup"><span data-stu-id="c11ef-473">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="c11ef-474">有状态服务提供[可靠集合][service-fabric-reliable-collections]以永久存储 Service Fabric 群集内的键值集合中的数据。</span><span class="sxs-lookup"><span data-stu-id="c11ef-474">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="c11ef-475">若要详细了解可靠集合中分区键的策略，请参阅 [Azure Service Fabric 中的可靠集合的相关指导原则和建议]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-475">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="c11ef-476">详细信息</span><span class="sxs-lookup"><span data-stu-id="c11ef-476">More information</span></span>

- <span data-ttu-id="c11ef-477">[Azure Service Fabric 概述]是有关 Azure Service Fabric 的简介。</span><span class="sxs-lookup"><span data-stu-id="c11ef-477">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="c11ef-478">[分区 Service Fabric 可靠服务]提供有关 Azure Service Fabric 中的可靠服务的详细信息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-478">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="c11ef-479">将 Azure 事件中心分区</span><span class="sxs-lookup"><span data-stu-id="c11ef-479">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="c11ef-480">[Azure 事件中心][event-hubs]可用于大规模数据流，并且分区内置于服务中以启用水平缩放。</span><span class="sxs-lookup"><span data-stu-id="c11ef-480">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="c11ef-481">每个使用者只读取消息流的的特定分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-481">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="c11ef-482">事件发布者只知道其分区密钥，而不知道事件要发布到的分区。</span><span class="sxs-lookup"><span data-stu-id="c11ef-482">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="c11ef-483">键与分区的这种分离使发送者无需了解有关下游处理的过多信息。</span><span class="sxs-lookup"><span data-stu-id="c11ef-483">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="c11ef-484">（它也可能将事件直接发送到给定的分区，但通常不建议这样做。）</span><span class="sxs-lookup"><span data-stu-id="c11ef-484">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="c11ef-485">选择分区计数时，请考虑长期规模。</span><span class="sxs-lookup"><span data-stu-id="c11ef-485">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="c11ef-486">创建事件中心后，将无法更改分区数。</span><span class="sxs-lookup"><span data-stu-id="c11ef-486">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="c11ef-487">有关在事件中心使用分区的详细信息，请参阅[什么是事件中心？]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-487">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="c11ef-488">有关可用性和一致性之间的权衡，请参阅[事件中心中的可用性和一致性]。</span><span class="sxs-lookup"><span data-stu-id="c11ef-488">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[事件中心中的可用性和一致性]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis 缓存]: https://azure.microsoft.com/services/cache/
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure 存储表设计指南]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[数据类型]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Azure Service Fabric 中的可靠集合的相关指导原则和建议]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric 概述]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[分区 Service Fabric 可靠服务]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[执行实体组事务]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Redis 群集教程]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[服务总线配额]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Azure 搜索中的服务限制]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[支持的数据类型（Azure 搜索）]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Transactions]: https://redis.io/topics/transactions
[什么是事件中心？]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[什么是 Azure 搜索？]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[可伸缩性目标]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
