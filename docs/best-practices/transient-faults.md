---
title: 有关重试的一般性指南
titleSuffix: Best practices for cloud applications
description: 有关暂时性故障重试处理的指南。
author: dragon119
ms.date: 07/13/2016
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 43356f4e94c3f35fcb419338a41eb53025ce63b6
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54482578"
---
# <a name="transient-fault-handling"></a><span data-ttu-id="7e575-103">暂时性故障处理</span><span class="sxs-lookup"><span data-stu-id="7e575-103">Transient fault handling</span></span>

<span data-ttu-id="7e575-104">与远程服务和资源通信的所有应用程序必须对暂时性故障敏感。</span><span class="sxs-lookup"><span data-stu-id="7e575-104">All applications that communicate with remote services and resources must be sensitive to transient faults.</span></span> <span data-ttu-id="7e575-105">对于云中运行的应用程序尤其如此，因为其环境的性质与通过 Internet 建立连接的特点，意味着更容易遇到这种类型的故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-105">This is especially the case for applications that run in the cloud, where the nature of the environment and connectivity over the Internet means these types of faults are likely to be encountered more often.</span></span> <span data-ttu-id="7e575-106">暂时性故障包括组件和服务瞬间断开网络连接、服务暂时不可用，或者当服务繁忙时出现超时。</span><span class="sxs-lookup"><span data-stu-id="7e575-106">Transient faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that arise when a service is busy.</span></span> <span data-ttu-id="7e575-107">这些故障通常可自我纠正，如果在适当的延迟后重复操作，则操作可能会成功。</span><span class="sxs-lookup"><span data-stu-id="7e575-107">These faults are often self-correcting, and if the action is repeated after a suitable delay it is likely succeed.</span></span>

<span data-ttu-id="7e575-108">本文档提供有关处理暂时性故障的一般指导。</span><span class="sxs-lookup"><span data-stu-id="7e575-108">This document covers general guidance for transient fault handling.</span></span> <span data-ttu-id="7e575-109">有关处理使用 Microsoft Azure 服务时发生的暂时性故障的信息，请参阅[特定于 Azure 服务的重试指南](./retry-service-specific.md)。</span><span class="sxs-lookup"><span data-stu-id="7e575-109">For information about handling transient faults when using Microsoft Azure services, see [Azure service-specific retry guidelines](./retry-service-specific.md).</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-do-transient-faults-occur-in-the-cloud"></a><span data-ttu-id="7e575-110">为什么云中会出现暂时性故障？</span><span class="sxs-lookup"><span data-stu-id="7e575-110">Why do transient faults occur in the cloud?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="7e575-111">任何环境、任何平台或操作系统以及任何类型的应用程序都会发生暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-111">Transient faults can occur in any environment, on any platform or operating system, and in any kind of application.</span></span> <span data-ttu-id="7e575-112">在内部部署的本地基础结构上运行的解决方案中，应用程序及其组件的性能与可用性通常是通过昂贵但通常很少使用的硬件冗余来维持的，并且组件与资源的位置互相靠近。</span><span class="sxs-lookup"><span data-stu-id="7e575-112">In solutions that run on local, on-premises infrastructure, performance and availability of the application and its components is typically maintained through expensive and often under-used hardware redundancy, and components and resources are located close to each another.</span></span> <span data-ttu-id="7e575-113">尽管这样可以大大减少故障，但可能仍会导致暂时性故障 - 甚至不可预见的事件（例如外部电源或网络问题或其他灾难性的状况）可能会造成中断。</span><span class="sxs-lookup"><span data-stu-id="7e575-113">While this makes a failure less likely, it can still result in transient faults - and even an outage through unforeseen events such as external power supply or network issues, or other disaster scenarios.</span></span>

<span data-ttu-id="7e575-114">云托管（包括专用云系统）可以通过使用共享资源、冗余、自动故障转移以及在大量商用计算节点之间动态分配资源，来提高整体可用性。</span><span class="sxs-lookup"><span data-stu-id="7e575-114">Cloud hosting, including private cloud systems, can offer a higher overall availability by using shared resources, redundancy, automatic failover, and dynamic resource allocation across a huge number of commodity compute nodes.</span></span> <span data-ttu-id="7e575-115">但是，这些环境的性质意味着更可能发生暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-115">However, the nature of these environments can mean that transient faults are more likely to occur.</span></span> <span data-ttu-id="7e575-116">原因包括：</span><span class="sxs-lookup"><span data-stu-id="7e575-116">There are several reasons for this:</span></span>

- <span data-ttu-id="7e575-117">云环境中的许多资源是共享的，为了保护这些资源，会限制对这些资源的访问。</span><span class="sxs-lookup"><span data-stu-id="7e575-117">Many resources in a cloud environment are shared, and access to these resources is subject to throttling in order to protect the resource.</span></span> <span data-ttu-id="7e575-118">某些服务在负载上升到特定级别时，或到达吞吐量比率的上限时，会拒绝连接以便处理现有的请求，并为所有用户维持服务性能。</span><span class="sxs-lookup"><span data-stu-id="7e575-118">Some services will refuse connections when the load rises to a specific level, or a maximum throughput rate is reached, in order to allow processing of existing requests and to maintain performance of the service for all users.</span></span> <span data-ttu-id="7e575-119">限制有助于为共享资源的邻居与其他租户维持服务质量。</span><span class="sxs-lookup"><span data-stu-id="7e575-119">Throttling helps to maintain the quality of service for neighbors and other tenants using the shared resource.</span></span>

- <span data-ttu-id="7e575-120">云环境是使用大量商用硬件单元构建而成的。</span><span class="sxs-lookup"><span data-stu-id="7e575-120">Cloud environments are built using vast numbers of commodity hardware units.</span></span> <span data-ttu-id="7e575-121">云环境将负载动态分散到多个计算单元和基础结构组件上以提供性能，并通过自动回收或更换故障单元来提供可靠性。</span><span class="sxs-lookup"><span data-stu-id="7e575-121">They deliver performance by dynamically distributing the load across multiple computing units and infrastructure components, and deliver reliability by automatically recycling or replacing failed units.</span></span> <span data-ttu-id="7e575-122">这种动态性意味着可能偶尔会发生暂时性故障和暂时连接失败。</span><span class="sxs-lookup"><span data-stu-id="7e575-122">This dynamic nature means that transient faults and temporary connection failures may occasionally occur.</span></span>

- <span data-ttu-id="7e575-123">在应用程序与资源及其使用的服务之间，通常有多个硬件组件，包括网络基础结构，例如路由器和负载均衡器。</span><span class="sxs-lookup"><span data-stu-id="7e575-123">There are often more hardware components, including network infrastructure such as routers and load balancers, between the application and the resources and services it uses.</span></span> <span data-ttu-id="7e575-124">这个附加的基础结构偶尔会导致额外的连接延迟与暂时性连接故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-124">This additional infrastructure can occasionally introduce additional connection latency and transient connection faults.</span></span>

- <span data-ttu-id="7e575-125">客户端与服务器之间的网络状况会不时改变，尤其是通过 Internet 通信时。</span><span class="sxs-lookup"><span data-stu-id="7e575-125">Network conditions between the client and the server may be variable, especially when communication crosses the Internet.</span></span> <span data-ttu-id="7e575-126">即使在本地位置，非常繁重的流量负载也可能会导致通信变慢，造成间歇性的连接失败。</span><span class="sxs-lookup"><span data-stu-id="7e575-126">Even in on-premises locations, very heavy traffic loads may slow communication and cause intermittent connection failures.</span></span>

## <a name="challenges"></a><span data-ttu-id="7e575-127">挑战</span><span class="sxs-lookup"><span data-stu-id="7e575-127">Challenges</span></span>

<span data-ttu-id="7e575-128">暂时性故障会对应用程序的实际可用性造成重大影响，即使应用程序已在所有可预测的条件下经过全面的测试。</span><span class="sxs-lookup"><span data-stu-id="7e575-128">Transient faults can have a huge impact on the perceived availability of an application, even if it has been thoroughly tested under all foreseeable circumstances.</span></span> <span data-ttu-id="7e575-129">若要确保云托管的应用程序可靠运行，应用程序必须能够应对以下挑战：</span><span class="sxs-lookup"><span data-stu-id="7e575-129">To ensure that cloud-hosted applications operate reliably, they must be able to respond to the following challenges:</span></span>

- <span data-ttu-id="7e575-130">应用程序必须能够检测到故障的发生，并确定这些故障可能是暂时性的、持久性的还是终端故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-130">The application must be able to detect faults when they occur, and determine if these faults are likely to be transient, more long-lasting, or are terminal failures.</span></span> <span data-ttu-id="7e575-131">发生故障时，不同的资源可能返回不同的响应，这些响应可能会根据操作上下文而有所不同，例如，针对从存储读取时所发生错误返回的响应，与针对写入存储时所发生错误返回的响应不同。</span><span class="sxs-lookup"><span data-stu-id="7e575-131">Different resources are likely to return different responses when a fault occurs, and these responses may also vary depending on the context of the operation; for example, the response for an error when reading from storage may be different from response for an error when writing to storage.</span></span> <span data-ttu-id="7e575-132">许多资源和服务都妥善制定了暂时性故障的合约。</span><span class="sxs-lookup"><span data-stu-id="7e575-132">Many resources and services have well-documented transient failure contracts.</span></span> <span data-ttu-id="7e575-133">但是，若不提供此类信息，则很难发现故障的性质，以及故障是否是暂时性的。</span><span class="sxs-lookup"><span data-stu-id="7e575-133">However, where such information is not available, it may be difficult to discover the nature of the fault and whether it is likely to be transient.</span></span>

- <span data-ttu-id="7e575-134">如果确定故障可能是暂时性的，应用程序必须能够重试操作，并跟踪操作重试的次数。</span><span class="sxs-lookup"><span data-stu-id="7e575-134">The application must be able to retry the operation if it determines that the fault is likely to be transient and keep track of the number of times the operation was retried.</span></span>

- <span data-ttu-id="7e575-135">应用程序必须使用适当的重试策略。</span><span class="sxs-lookup"><span data-stu-id="7e575-135">The application must use an appropriate strategy for the retries.</span></span> <span data-ttu-id="7e575-136">此策略指定应用程序应该重试的次数、每两次尝试的延迟时间，以及尝试失败后执行的操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-136">This strategy specifies the number of times it should retry, the delay between each attempt, and the actions to take after a failed attempt.</span></span> <span data-ttu-id="7e575-137">适当的尝试次数以及每两次尝试的延迟时间通常难以确定，会根据资源类型以及应用程序本身的当前操作条件而有所不同。</span><span class="sxs-lookup"><span data-stu-id="7e575-137">The appropriate number of attempts and the delay between each one are often difficult to determine, and vary based on the type of resource as well as the current operating conditions of the resource and the application itself.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="7e575-138">一般性指导</span><span class="sxs-lookup"><span data-stu-id="7e575-138">General guidelines</span></span>

<span data-ttu-id="7e575-139">以下准则有助于为应用程序设计合适的暂时性故障处理机制：</span><span class="sxs-lookup"><span data-stu-id="7e575-139">The following guidelines will help you to design a suitable transient fault handing mechanism for your applications:</span></span>

- <span data-ttu-id="7e575-140">**确定是否存在内置的重试机制：**</span><span class="sxs-lookup"><span data-stu-id="7e575-140">**Determine if there is a built-in retry mechanism:**</span></span>

  - <span data-ttu-id="7e575-141">许多服务提供 SDK 或包含暂时性故障处理机制的客户端库。</span><span class="sxs-lookup"><span data-stu-id="7e575-141">Many services provide an SDK or client library that contains a transient fault handling mechanism.</span></span> <span data-ttu-id="7e575-142">服务使用的重试策略通常是根据目标服务的性质和要求定制的。</span><span class="sxs-lookup"><span data-stu-id="7e575-142">The retry policy it uses is typically tailored to the nature and requirements of the target service.</span></span> <span data-ttu-id="7e575-143">或者，对于确定重试是否适当，以及在下一次尝试重试之前要等待多长时间方面，服务的 REST 接口可能会返回有用的信息。</span><span class="sxs-lookup"><span data-stu-id="7e575-143">Alternatively, REST interfaces for services may return information that is useful in determining whether a retry is appropriate, and how long to wait before the next retry attempt.</span></span>

  - <span data-ttu-id="7e575-144">除非有具体且明确的要求需要其他更适当的重试行为，否则请使用提供的内置重试机制。</span><span class="sxs-lookup"><span data-stu-id="7e575-144">Use the built-in retry mechanism where one is available unless you have specific and well-understood requirements that mean a different retry behavior is more appropriate.</span></span>

- <span data-ttu-id="7e575-145">**确定操作是否适合重试**：</span><span class="sxs-lookup"><span data-stu-id="7e575-145">**Determine if the operation is suitable for retrying**:</span></span>

  - <span data-ttu-id="7e575-146">只在故障是暂时性（通常可由故障的性质来判断），以及在重新尝试后操作至少有一些成功的可能性时，才应重试操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-146">You should only retry operations where the faults are transient (typically indicated by the nature of the error), and if there is at least some likelihood that the operation will succeed when reattempted.</span></span> <span data-ttu-id="7e575-147">如果操作是无效的操作，例如数据库所更新的项不存在，或者请求的服务或资源发生严重错误，则重新尝试没有意义。</span><span class="sxs-lookup"><span data-stu-id="7e575-147">There is no point in reattempting operations that indicate an invalid operation such as a database update to an item that does not exist, or requests to a service or resource that has suffered a fatal error</span></span>

  - <span data-ttu-id="7e575-148">一般而言，只有在能够确定操作的整个影响，且状况已获得充分了解并可验证时，才实施重试。</span><span class="sxs-lookup"><span data-stu-id="7e575-148">In general, you should implement retries only where the full impact of this can be determined, and the conditions are well understood and can be validated.</span></span> <span data-ttu-id="7e575-149">否则，应该由调用代码来实施重试。</span><span class="sxs-lookup"><span data-stu-id="7e575-149">If not, leave it to the calling code to implement retries.</span></span> <span data-ttu-id="7e575-150">请记住，从无法控制的资源与服务返回的错误可能会随着时间而演进，可能需要重新访问暂时性故障检测逻辑。</span><span class="sxs-lookup"><span data-stu-id="7e575-150">Remember that the errors returned from resources and services outside your control may evolve over time, and you may need to revisit your transient fault detection logic.</span></span>

  - <span data-ttu-id="7e575-151">创建服务或组件时，请考虑实施错误代码和消息，以帮助客户端确定是否应重试失败的操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-151">When you create services or components, consider implementing error codes and messages that will help clients determine whether they should retry failed operations.</span></span> <span data-ttu-id="7e575-152">具体而言，指明客户端是否应重试操作（也许是通过返回 **isTransient** 值），并建议下一次重试之前的适当延迟。</span><span class="sxs-lookup"><span data-stu-id="7e575-152">In particular, indicate if the client should retry the operation (perhaps by returning an **isTransient** value) and suggest a suitable delay before the next retry attempt.</span></span> <span data-ttu-id="7e575-153">如果要构建 Web 服务，请考虑返回服务合约中定义的自定义错误。</span><span class="sxs-lookup"><span data-stu-id="7e575-153">If you build a web service, consider returning custom errors defined within your service contracts.</span></span> <span data-ttu-id="7e575-154">即使一般的客户端可能无法读取这些错误，但在构建自定义客户端时，自定义错误很有帮助。</span><span class="sxs-lookup"><span data-stu-id="7e575-154">Even though generic clients may not be able to read these, they will be useful when building custom clients.</span></span>

- <span data-ttu-id="7e575-155">**确定适当的重试计数与间隔：**</span><span class="sxs-lookup"><span data-stu-id="7e575-155">**Determine an appropriate retry count and interval:**</span></span>

  - <span data-ttu-id="7e575-156">请务必优化重试计数和用例类型的间隔。</span><span class="sxs-lookup"><span data-stu-id="7e575-156">It is vital to optimize the retry count and the interval to the type of use case.</span></span> <span data-ttu-id="7e575-157">如果重试次数不足，应用程序将无法完成操作，并且可能会失败。</span><span class="sxs-lookup"><span data-stu-id="7e575-157">If you do not retry a sufficient number of times, the application will be unable to complete the operation and is likely to experience a failure.</span></span> <span data-ttu-id="7e575-158">如果重试次数太多或间隔太短，应用程序可能会长期保留资源（例如线程、连接和内存），这会对应用程序的运行状况造成不利影响。</span><span class="sxs-lookup"><span data-stu-id="7e575-158">If you retry too many times, or with too short an interval between tries, the application can potentially hold resources such as threads, connections, and memory for long periods, which will adversely affect the health of the application.</span></span>

  - <span data-ttu-id="7e575-159">适当的时间间隔与重试次数值取决于正在尝试的操作类型。</span><span class="sxs-lookup"><span data-stu-id="7e575-159">The appropriate values for the time interval and the number of retry attempts depend on the type of operation being attempted.</span></span> <span data-ttu-id="7e575-160">例如，如果操作是用户交互的一部分，则间隔应该较短，且只需重试几次，以避免让用户等待响应（这会让连接保持打开，并可能会降低其他用户的可用性）。</span><span class="sxs-lookup"><span data-stu-id="7e575-160">For example, if the operation is part of a user interaction, the interval should be short and only a few retries attempted to avoid making users wait for a response (which holds open connections and can reduce availability for other users).</span></span> <span data-ttu-id="7e575-161">如果操作是长时间运行或重要工作流的一部分，取消并重新启动工作流的过程代价高昂或耗时，则每次尝试后等待的时间应较长，并且应重试更多次。</span><span class="sxs-lookup"><span data-stu-id="7e575-161">If the operation is part of a long running or critical workflow, where cancelling and restarting the process is expensive or time-consuming, it is appropriate to wait longer between attempts and retry more times.</span></span>

  - <span data-ttu-id="7e575-162">确定适当的重试间隔是设计一个成功的策略时最困难的部分。</span><span class="sxs-lookup"><span data-stu-id="7e575-162">Determining the appropriate intervals between retries is the most difficult part of designing a successful strategy.</span></span> <span data-ttu-id="7e575-163">典型的策略会使用以下类型的重试间隔：</span><span class="sxs-lookup"><span data-stu-id="7e575-163">Typical strategies use the following types of retry interval:</span></span>

    - <span data-ttu-id="7e575-164">**指数退让**。</span><span class="sxs-lookup"><span data-stu-id="7e575-164">**Exponential back-off**.</span></span> <span data-ttu-id="7e575-165">应用程序在第一次重试之前短暂地等待，每个后续重试的间隔时间呈指数增加。</span><span class="sxs-lookup"><span data-stu-id="7e575-165">The application waits a short time before the first retry, and then exponentially increasing times between each subsequent retry.</span></span> <span data-ttu-id="7e575-166">例如，在 3 秒、12 秒、30 秒后重试操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-166">For example, it may retry the operation after 3 seconds, 12 seconds, 30 seconds, and so on.</span></span>

    - <span data-ttu-id="7e575-167">**增量间隔**。</span><span class="sxs-lookup"><span data-stu-id="7e575-167">**Incremental intervals**.</span></span> <span data-ttu-id="7e575-168">应用程序在第一次重试之前短暂地等待，每个后续重试的间隔时间增量递增。</span><span class="sxs-lookup"><span data-stu-id="7e575-168">The application waits a short time before the first retry, and then incrementally increasing times between each subsequent retry.</span></span> <span data-ttu-id="7e575-169">例如，在 3 秒、7 秒、13 秒后重试操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-169">For example, it may retry the operation after 3 seconds, 7 seconds, 13 seconds, and so on.</span></span>

    - <span data-ttu-id="7e575-170">**固定间隔**。</span><span class="sxs-lookup"><span data-stu-id="7e575-170">**Regular intervals**.</span></span> <span data-ttu-id="7e575-171">应用程序每次尝试的间隔时间相同。</span><span class="sxs-lookup"><span data-stu-id="7e575-171">The application waits for the same period of time between each attempt.</span></span> <span data-ttu-id="7e575-172">例如，固定每 3 秒重试操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-172">For example, it may retry the operation every 3 seconds.</span></span>

    - <span data-ttu-id="7e575-173">**立即重试**。</span><span class="sxs-lookup"><span data-stu-id="7e575-173">**Immediate retry**.</span></span> <span data-ttu-id="7e575-174">有时候暂时性故障极短，可能是因网络数据包冲突或硬件组件流量高峰等事件造成的。</span><span class="sxs-lookup"><span data-stu-id="7e575-174">Sometimes a transient fault is extremely short, perhaps caused by an event such as a network packet collision or a spike in a hardware component.</span></span> <span data-ttu-id="7e575-175">在此情况下，适合立即重试操作，因为如果故障在操作让应用程序组合并发送下一个请求时已清除，则操作可能会成功。</span><span class="sxs-lookup"><span data-stu-id="7e575-175">In this case, retrying the operation immediately is appropriate because it may succeed if the fault has cleared in the time it takes the application to assemble and send the next request.</span></span> <span data-ttu-id="7e575-176">不过，立即重试次数不得超过一次，如果立即重试失败，应改用备用策略，例如指数退让或故障回复操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-176">However, there should never be more than one immediate retry attempt, and you should switch to alternative strategies, such as such as exponential back-off or fallback actions, if the immediate retry fails.</span></span>

    - <span data-ttu-id="7e575-177">**随机化**。</span><span class="sxs-lookup"><span data-stu-id="7e575-177">**Randomization**.</span></span> <span data-ttu-id="7e575-178">任何上述重试策略都可包含随机化，以防止客户端的多个实例同时发送后续重试请求。</span><span class="sxs-lookup"><span data-stu-id="7e575-178">Any of the retry strategies listed above may include a randomization to prevent multiple instances of the client sending subsequent retry attempts at the same time.</span></span> <span data-ttu-id="7e575-179">例如，一个实例可能会在 3 秒、11 秒、28 秒后重试操作，而另一个实例则在 4 秒、12 秒、26 秒后重试操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-179">For example, one instance may retry the operation after 3 seconds, 11 seconds, 28 seconds, and so on while another instance may retry the operation after 4 seconds, 12 seconds, 26 seconds, and so on.</span></span> <span data-ttu-id="7e575-180">随机化是有用的技术，可配合其他策略使用。</span><span class="sxs-lookup"><span data-stu-id="7e575-180">Randomization is a useful technique that may be combined with other strategies.</span></span>

  - <span data-ttu-id="7e575-181">一般指导原则是，为后台操作使用指数退让策略，为交互式操作使用立即或固定间隔重试策略。</span><span class="sxs-lookup"><span data-stu-id="7e575-181">As a general guideline, use an exponential back-off strategy for background operations, and immediate or regular interval retry strategies for interactive operations.</span></span> <span data-ttu-id="7e575-182">在上述两种情况下，应该选择延迟与重试计数，使所有重试的延迟上限都在所需的端到端延迟要求范围内。</span><span class="sxs-lookup"><span data-stu-id="7e575-182">In both cases, you should choose the delay and the retry count so that the maximum latency for all retry attempts is within the required end-to-end latency requirement.</span></span>

  - <span data-ttu-id="7e575-183">请考虑到所有会对重试操作的整体超时上限造成影响的因素组合。</span><span class="sxs-lookup"><span data-stu-id="7e575-183">Take into account the combination of all the factors that contribute to the overall maximum timeout for a retried operation.</span></span> <span data-ttu-id="7e575-184">这些因素包括失败连接生成响应所花费的时间（通常根据客户端的超时值设置），以及重试之间的延迟和重试次数上限。</span><span class="sxs-lookup"><span data-stu-id="7e575-184">These factors include the time taken for a failed connection to produce a response (typically set by a timeout value in the client) as well as the delay between retry attempts and the maximum number of retries.</span></span> <span data-ttu-id="7e575-185">所有这些时间的总和会导致整体操作时间变得漫长，尤其是在使用指数退让策略时，因为每次故障后重试的间隔会快速增加。</span><span class="sxs-lookup"><span data-stu-id="7e575-185">The total of all these times can result in very large overall operation times, especially when using an exponential delay strategy where the interval between retries grows rapidly after each failure.</span></span> <span data-ttu-id="7e575-186">如果某个过程必须符合特定的服务级别协议 (SLA)，则整体操作时间（包括所有的超时和延迟）必须在 SLA 定义的范围之内。</span><span class="sxs-lookup"><span data-stu-id="7e575-186">If a process must meet a specific service level agreement (SLA), the overall operation time, including all timeouts and delays, must be within that defined in the SLA.</span></span>

  - <span data-ttu-id="7e575-187">过度积极的重试策略（间隔太短或重试次数过多）可能会对目标资源或服务造成不利影响。</span><span class="sxs-lookup"><span data-stu-id="7e575-187">Over-aggressive retry strategies, which have too short intervals or too many retries, can have an adverse effect on the target resource or service.</span></span> <span data-ttu-id="7e575-188">这可能会造成资源或服务无法从过载状态恢复，并且会继续阻止或拒绝请求。</span><span class="sxs-lookup"><span data-stu-id="7e575-188">This may prevent the resource or service from recovering from its overloaded state, and it will continue to block or refuse requests.</span></span> <span data-ttu-id="7e575-189">这会造成恶性循环，越来越多的请求将发送到资源或服务，因而造成其恢复能力进一步降低。</span><span class="sxs-lookup"><span data-stu-id="7e575-189">This results in a vicious circle where more and more requests are sent to the resource or service, and consequently its ability to recover is further reduced.</span></span>

  - <span data-ttu-id="7e575-190">选择重试间隔时请考虑操作的超时，以避免立即启动后续尝试（例如当超时期间与重试间隔类似时）。</span><span class="sxs-lookup"><span data-stu-id="7e575-190">Take into account the timeout of the operations when choosing the retry intervals to avoid launching a subsequent attempt immediately (for example, if the timeout period is similar to the retry interval).</span></span> <span data-ttu-id="7e575-191">还应考虑是否需要让可能期间的总和（超时值加重试间隔）短于特定的时间总和。</span><span class="sxs-lookup"><span data-stu-id="7e575-191">Also consider if you need to keep the total possible period (the timeout plus the retry intervals) to below a specific total time.</span></span> <span data-ttu-id="7e575-192">超时设置非常短或非常长的的操作可能会影响等待时间，以及重试操作的频率。</span><span class="sxs-lookup"><span data-stu-id="7e575-192">Operations that have unusually short or very long timeouts may influence how long to wait, and how often to retry the operation.</span></span>

  - <span data-ttu-id="7e575-193">使用异常类型及其包含的任何数据，或者使用从服务返回的错误代码与消息，来优化重试的间隔和次数。</span><span class="sxs-lookup"><span data-stu-id="7e575-193">Use the type of the exception and any data it contains, or the error codes and messages returned from the service, to optimize the interval and the number of retries.</span></span> <span data-ttu-id="7e575-194">例如，某些异常或错误代码（如 HTTP 代码 503 - 服务不可用，以及响应中的 Retry-After 标头）会指示错误可能持续的时间，或服务失败且不会响应任何后续尝试。</span><span class="sxs-lookup"><span data-stu-id="7e575-194">For example, some exceptions or error codes (such as the HTTP code 503 Service Unavailable with a Retry-After header in the response) may indicate how long the error might last, or that the service has failed and will not respond to any subsequent attempt.</span></span>

- <span data-ttu-id="7e575-195">**避免反模式**：</span><span class="sxs-lookup"><span data-stu-id="7e575-195">**Avoid anti-patterns**:</span></span>

  - <span data-ttu-id="7e575-196">在绝大多数情况下，应该避免使用包含重复重试代码层的实现。</span><span class="sxs-lookup"><span data-stu-id="7e575-196">In the vast majority of cases, you should avoid implementations that include duplicated layers of retry code.</span></span> <span data-ttu-id="7e575-197">避免使用包括级联重试机制的设计，或避免使用在涉及请求层次结构的操作的每个阶段实施重试的设计，除非有特定的要求。</span><span class="sxs-lookup"><span data-stu-id="7e575-197">Avoid designs that include cascading retry mechanisms, or that implement retry at every stage of an operation that involves a hierarchy of requests, unless you have specific requirements that demand this.</span></span> <span data-ttu-id="7e575-198">在这些例外的情况下下，请使用策略避免过多的重试次数和延迟期间过长，并确保了解后果。</span><span class="sxs-lookup"><span data-stu-id="7e575-198">In these exceptional circumstances, use policies that prevent excessive numbers of retries and delay periods, and make sure you understand the consequences.</span></span> <span data-ttu-id="7e575-199">例如，如果某个组件对另一个组件发出请求，后者再访问目标服务，并且要对这两个调用各实施重试三次，则总共会对该服务重试九次。</span><span class="sxs-lookup"><span data-stu-id="7e575-199">For example, if one component makes a request to another, which then accesses the target service, and you implement retry with a count of three on both calls there will be nine retry attempts in total against the service.</span></span> <span data-ttu-id="7e575-200">许多服务和资源实施内置重试机制，如果需要在较高级别实施重试，应调查如何禁用或修改此设置。</span><span class="sxs-lookup"><span data-stu-id="7e575-200">Many services and resources implement a built-in retry mechanism and you should investigate how you can disable or modify this if you need to implement retries at a higher level.</span></span>

  - <span data-ttu-id="7e575-201">切勿实施永不结束的重试机制。</span><span class="sxs-lookup"><span data-stu-id="7e575-201">Never implement an endless retry mechanism.</span></span> <span data-ttu-id="7e575-202">这很可能会导致资源或服务无法从过载情况下恢复，并造成限制与遭到拒绝的连接持续更长时间。</span><span class="sxs-lookup"><span data-stu-id="7e575-202">This is likely to prevent the resource or service recovering from overload situations, and cause throttling and refused connections to continue for a longer period.</span></span> <span data-ttu-id="7e575-203">使用有限的重试次数或使用[断路器](../patterns/circuit-breaker.md)等模式，使服务可以恢复。</span><span class="sxs-lookup"><span data-stu-id="7e575-203">Use a finite number or retries, or implement a pattern such as [Circuit Breaker](../patterns/circuit-breaker.md) to allow the service to recover.</span></span>

  - <span data-ttu-id="7e575-204">切勿多次执行立即重试。</span><span class="sxs-lookup"><span data-stu-id="7e575-204">Never perform an immediate retry more than once.</span></span>

  - <span data-ttu-id="7e575-205">避免使用固定重试间隔，尤其是在访问 Azure 中的服务与资源期间要重试很多次时。</span><span class="sxs-lookup"><span data-stu-id="7e575-205">Avoid using a regular retry interval, especially when you have a large number of retry attempts, when accessing services and resources in Azure.</span></span> <span data-ttu-id="7e575-206">此情况下的最佳方法是指数退让策略以及断路功能。</span><span class="sxs-lookup"><span data-stu-id="7e575-206">The optimum approach is this scenario is an exponential back-off strategy with a circuit-breaking capability.</span></span>

  - <span data-ttu-id="7e575-207">防止同一个客户端有多个实例，或不同客户端有多个实例同时发送重试请求。</span><span class="sxs-lookup"><span data-stu-id="7e575-207">Prevent multiple instances of the same client, or multiple instances of different clients, from sending retries at the same times.</span></span> <span data-ttu-id="7e575-208">如果这有可能发生，请在重试间隔中引入随机化。</span><span class="sxs-lookup"><span data-stu-id="7e575-208">If this is likely to occur, introduce randomization into the retry intervals.</span></span>

- <span data-ttu-id="7e575-209">**测试重试策略与实施：**</span><span class="sxs-lookup"><span data-stu-id="7e575-209">**Test your retry strategy and implementation:**</span></span>

  - <span data-ttu-id="7e575-210">确保在尽可能广泛的条件下全面测试重试策略实施，尤其是当实施使用的应用程序与目标资源或服务要承受极端负载时。</span><span class="sxs-lookup"><span data-stu-id="7e575-210">Ensure you fully test your retry strategy implementation under as wide a set of circumstances as possible, especially when both the application and the target resources or services it uses are under extreme load.</span></span> <span data-ttu-id="7e575-211">要检查测试期间的行为，可以：</span><span class="sxs-lookup"><span data-stu-id="7e575-211">To check behavior during testing, you can:</span></span>

    - <span data-ttu-id="7e575-212">将暂时性与非暂时性故障注入服务中。</span><span class="sxs-lookup"><span data-stu-id="7e575-212">Inject transient and non-transient faults into the service.</span></span> <span data-ttu-id="7e575-213">例如，发送无效请求或添加代码用于检测包含不同错误类型的测试请求与响应。</span><span class="sxs-lookup"><span data-stu-id="7e575-213">For example, send invalid requests or add code that detects test requests and responds with different types of errors.</span></span> <span data-ttu-id="7e575-214">有关使用 TestApi 的示例，请参阅[使用 TestApi 进行故障注入测试](https://msdn.microsoft.com/magazine/ff898404.aspx)和 [TestApi 简介 - 第 5 部分：托管的代码故障注入 API](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/)。</span><span class="sxs-lookup"><span data-stu-id="7e575-214">For an example using TestApi, see [Fault Injection Testing with TestApi](https://msdn.microsoft.com/magazine/ff898404.aspx) and [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/).</span></span>

    - <span data-ttu-id="7e575-215">创建资源或服务模型，用于返回真实服务可能返回的错误范围。</span><span class="sxs-lookup"><span data-stu-id="7e575-215">Create a mock of the resource or service that returns a range of errors that the real service may return.</span></span> <span data-ttu-id="7e575-216">确保覆盖重试策略旨在检测的所有错误类型。</span><span class="sxs-lookup"><span data-stu-id="7e575-216">Ensure you cover all the types of error that your retry strategy is designed to detect.</span></span>

    - <span data-ttu-id="7e575-217">如果服务是你创建及部署的自定义服务，则通过暂时禁用或过载该服务，来强制发生暂时性错误（当然，不应尝试使 Azure 中的任何共享资源或共享服务过载）。</span><span class="sxs-lookup"><span data-stu-id="7e575-217">Force transient errors to occur by temporarily disabling or overloading the service if it is a custom service that you created and deployed (you should not, of course, attempt to overload any shared resources or shared services within Azure).</span></span>

    - <span data-ttu-id="7e575-218">对于基于 HTTP 的 API，请考虑在自动化测试中使用 FiddlerCore 库来更改 HTTP 请求的结果，方法是增加额外的往返时间或更改响应（例如 HTTP 状态代码、标头、正文或其他因素）。</span><span class="sxs-lookup"><span data-stu-id="7e575-218">For HTTP-based APIs, consider using the FiddlerCore library in your automated tests to change the outcome of HTTP requests, either by adding extra roundtrip times or by changing the response (such as the HTTP status code, headers, body, or other factors).</span></span> <span data-ttu-id="7e575-219">这样，便可以确定性地测试一部分故障状况，无论是暂时性故障还是其他类型的故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-219">This enables deterministic testing of a subset of the failure conditions, whether transient faults or other types of failure.</span></span> <span data-ttu-id="7e575-220">有关详细信息，请参阅 [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore)。</span><span class="sxs-lookup"><span data-stu-id="7e575-220">For more information, see [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore).</span></span> <span data-ttu-id="7e575-221">有关如何使用该库（特别是 **HttpMangler** 类）的示例，请查看 [Azure 存储 SDK 的源代码](https://github.com/Azure/azure-storage-net/tree/master/Test)。</span><span class="sxs-lookup"><span data-stu-id="7e575-221">For examples of how to use the library, particularly the **HttpMangler** class, examine the [source code for the Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span></span>

    - <span data-ttu-id="7e575-222">执行高负载因子和并发测试，确保重试机制与策略在这些条件下能正常工作，且不会对客户端操作造成不良的影响或导致请求之间交叉污染。</span><span class="sxs-lookup"><span data-stu-id="7e575-222">Perform high load factor and concurrent tests to ensure that the retry mechanism and strategy works correctly under these conditions, and does not have an adverse effect on the operation of the client or cause cross-contamination between requests.</span></span>

- <span data-ttu-id="7e575-223">**管理重试策略配置：**</span><span class="sxs-lookup"><span data-stu-id="7e575-223">**Manage retry policy configurations:**</span></span>

  - <span data-ttu-id="7e575-224">*重试策略*是所有重试策略元素的组合。</span><span class="sxs-lookup"><span data-stu-id="7e575-224">A *retry policy* is a combination of all of the elements of your retry strategy.</span></span> <span data-ttu-id="7e575-225">它定义了能确定故障是否可能是暂时性的检测机制、使用的间隔类型（例如固定、指数退让及随机化）、实际间隔值，以及重试次数。</span><span class="sxs-lookup"><span data-stu-id="7e575-225">It defines the detection mechanism that determines whether a fault is likely to be transient, the type of interval to use (such as regular, exponential back-off, and randomization), the actual interval value(s), and the number of times to retry.</span></span>

  - <span data-ttu-id="7e575-226">必须在应用程序中的多个位置实施重试，即使是最简单的应用程序也是如此，至于较复杂的应用程序，则必须每一层都实施。</span><span class="sxs-lookup"><span data-stu-id="7e575-226">Retries must be implemented in many places within even the simplest application, and in every layer of more complex applications.</span></span> <span data-ttu-id="7e575-227">考虑使用集中点存储所有策略，而不是将每个策略的元素硬编码在多个位置。</span><span class="sxs-lookup"><span data-stu-id="7e575-227">Rather than hard-coding the elements of each policy at multiple locations, consider using a central point for storing all the policies.</span></span> <span data-ttu-id="7e575-228">例如，在应用程序配置文件中存储间隔和重试计数等值、在运行时读取这些值，并以编程方式构建重试策略。</span><span class="sxs-lookup"><span data-stu-id="7e575-228">For example, store the values such as the interval and retry count in application configuration files, read them at runtime, and programmatically build the retry policies.</span></span> <span data-ttu-id="7e575-229">这可以更轻松地管理设置，以及修改和优化值，以应对不断变化的要求和方案。</span><span class="sxs-lookup"><span data-stu-id="7e575-229">This makes it easier to manage the settings, and to modify and fine tune the values in order to respond to changing requirements and scenarios.</span></span> <span data-ttu-id="7e575-230">但是，请将系统设计为存储值而不是每次都要重新读取配置文件，并确保在无法从配置中获取值时使用适当的默认值。</span><span class="sxs-lookup"><span data-stu-id="7e575-230">However, design the system to store the values rather than rereading a configuration file every time, and ensure suitable defaults are used if the values cannot be obtained from configuration.</span></span>

  - <span data-ttu-id="7e575-231">考虑在 Azure 云服务应用程序中存储值，用于在服务配置文件中构建运行时的重试策略，使这些值不需要重新启动应用程序即可更改。</span><span class="sxs-lookup"><span data-stu-id="7e575-231">In an Azure Cloud Services application, consider storing the values that are used to build the retry policies at runtime in the service configuration file so that they can be changed without needing to restart the application.</span></span>

  - <span data-ttu-id="7e575-232">利用所用客户端 API 中的内置或默认重试策略，但前提是这些策略适合方案。</span><span class="sxs-lookup"><span data-stu-id="7e575-232">Take advantage of built-in or default retry strategies available in the client APIs you use, but only where they are appropriate for your scenario.</span></span> <span data-ttu-id="7e575-233">这些策略往往是通用的。</span><span class="sxs-lookup"><span data-stu-id="7e575-233">These strategies are typically general-purpose.</span></span> <span data-ttu-id="7e575-234">在某些状况下，这些策略可能都是必需的，但在某些状况下，它们可能无法提供完整的选项范围来满足特定的要求。</span><span class="sxs-lookup"><span data-stu-id="7e575-234">In some scenarios they may be all that is required, but in other scenarios they may not offer the full range of options to suit your specific requirements.</span></span> <span data-ttu-id="7e575-235">必须通过测试来了解设置如何影响应用程序，以确定最合适的值。</span><span class="sxs-lookup"><span data-stu-id="7e575-235">You must understand how the settings will affect your application through testing to determine the most appropriate values.</span></span>

- <span data-ttu-id="7e575-236">**记录和跟踪暂时性与非暂时性故障：**</span><span class="sxs-lookup"><span data-stu-id="7e575-236">**Log and track transient and non-transient faults:**</span></span>

  - <span data-ttu-id="7e575-237">在重试策略中包含异常处理，以及其他用于记录重试时间的工具。</span><span class="sxs-lookup"><span data-stu-id="7e575-237">As part of your retry strategy, include exception handling and other instrumentation that logs when retry attempts are made.</span></span> <span data-ttu-id="7e575-238">尽管偶发的暂时性故障及重试在意料之中而不代表出现问题，但固定与递增的重试次数通常表示出现了可能会造成故障或者当前正在影响应用程序性能与可用性的问题。</span><span class="sxs-lookup"><span data-stu-id="7e575-238">While an occasional transient failure and retry are to be expected, and do not indicate a problem, regular and increasing numbers of retries are often an indicator of an issue that may cause a failure, or is currently impacting application performance and availability.</span></span>

  - <span data-ttu-id="7e575-239">将暂时性故障记录为“警告”项，而不是“错误”项，以便监视系统不会将其检测为应用程序错误而触发误报。</span><span class="sxs-lookup"><span data-stu-id="7e575-239">Log transient faults as Warning entries rather than Error entries so that monitoring systems do not detect them as application errors that may trigger false alerts.</span></span>

  - <span data-ttu-id="7e575-240">考虑将值存储在日志项中，用于指示重试是由服务中的限制所造成，或是由其他类型的故障（例如连接失败）造成，使你能够在分析数据期间进行区分。</span><span class="sxs-lookup"><span data-stu-id="7e575-240">Consider storing a value in your log entries that indicates if the retries were caused by throttling in the service, or by other types of faults such as connection failures, so that you can differentiate them during analysis of the data.</span></span> <span data-ttu-id="7e575-241">限制错误数目的增加通常表示应用程序的设计有瑕疵，或者需要改用可提供专用硬件的高级服务。</span><span class="sxs-lookup"><span data-stu-id="7e575-241">An increase in the number of throttling errors is often an indicator of a design flaw in the application or the need to switch to a premium service that offers dedicated hardware.</span></span>

  - <span data-ttu-id="7e575-242">考虑测量和记录包含重试机制的操作所需的总体时间。</span><span class="sxs-lookup"><span data-stu-id="7e575-242">Consider measuring and logging the overall time taken for operations that include a retry mechanism.</span></span> <span data-ttu-id="7e575-243">这是暂时性故障对用户响应时间、进程延迟以及应用程序用例效率造成的整体影响的良好指标。</span><span class="sxs-lookup"><span data-stu-id="7e575-243">This is a good indicator of the overall effect of transient faults on user response times, process latency, and the efficiency of the application use cases.</span></span> <span data-ttu-id="7e575-244">此外，还要记录发生重试的次数，以了解影响响应时间的因素。</span><span class="sxs-lookup"><span data-stu-id="7e575-244">Also log the number of retries occurred in order to understand the factors that contributed to the response time.</span></span>

  - <span data-ttu-id="7e575-245">考虑实施遥测和监视系统，当故障次数与比率、重试平均次数或操作成功所需的整体时间增加时，该系统会引发警报。</span><span class="sxs-lookup"><span data-stu-id="7e575-245">Consider implementing a telemetry and monitoring system that can raise alerts when the number and rate of failures, the average number of retries, or the overall times taken for operations to succeed, is increasing.</span></span>

- <span data-ttu-id="7e575-246">**管理不断失败的操作：**</span><span class="sxs-lookup"><span data-stu-id="7e575-246">**Manage operations that continually fail:**</span></span>
  
  - <span data-ttu-id="7e575-247">如果每次尝试后操作仍然失败，则必须考虑如何处理这种情况：</span><span class="sxs-lookup"><span data-stu-id="7e575-247">There will be circumstances where the operation continues to fail at every attempt, and it is vital to consider how you will handle this situation:</span></span>

    - <span data-ttu-id="7e575-248">尽管重试策略会定义操作应重试次数的上限，但它不会防止应用程序使用与重试次数相同的次数一再重复操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-248">Although a retry strategy will define the maximum number of times that an operation should be retried, it does not prevent the application repeating the operation again, with the same number of retries.</span></span> <span data-ttu-id="7e575-249">例如，如果订单处理服务因为严重错误而失败且永久失效，则重试策略会检测连接超时，并将它视为暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-249">For example, if an order processing service fails with a fatal error that puts it out of action permanently, the retry strategy may detect a connection timeout and consider it to be a transient fault.</span></span> <span data-ttu-id="7e575-250">代码将按指定的次数重试操作，然后放弃。</span><span class="sxs-lookup"><span data-stu-id="7e575-250">The code will retry the operation a specified number of times and then give up.</span></span> <span data-ttu-id="7e575-251">但是，当另一位客户下单时，会再次尝试该操作，即使该操作每次肯定都会失败。</span><span class="sxs-lookup"><span data-stu-id="7e575-251">However, when another customer places an order, the operation will be attempted again - even though it is sure to fail every time.</span></span>

    - <span data-ttu-id="7e575-252">为防止不断重试连续失败的操作，请考虑实施[断路器模式](../patterns/circuit-breaker.md)。</span><span class="sxs-lookup"><span data-stu-id="7e575-252">To prevent continual retries for operations that continually fail, consider implementing the [Circuit Breaker pattern](../patterns/circuit-breaker.md).</span></span> <span data-ttu-id="7e575-253">在此模式中，如果在指定的时段内失败次数超过阈值，则会立即将请求返回给调用方，并将失败视为故障，而不会尝试访问失败的资源或服务。</span><span class="sxs-lookup"><span data-stu-id="7e575-253">In this pattern, if the number of failures within a specified time window exceeds the threshold, requests are returned to the caller immediately as errors, without attempting to access the failed resource or service.</span></span>

    - <span data-ttu-id="7e575-254">应用程序将定期测试服务，并间歇性地（请求之间的间隔非常长）检测服务何时可供使用。</span><span class="sxs-lookup"><span data-stu-id="7e575-254">The application can periodically test the service, on an intermittent basis and with very long intervals between requests, to detect when it becomes available.</span></span> <span data-ttu-id="7e575-255">适当的间隔取决于方案，例如操作的重要性和服务的性质，可能是数分钟到数个小时。</span><span class="sxs-lookup"><span data-stu-id="7e575-255">An appropriate interval will depend on the scenario, such as the criticality of the operation and the nature of the service, and might be anything between a few minutes and several hours.</span></span> <span data-ttu-id="7e575-256">测试成功时，应用程序将恢复正常操作，并将请求传递给刚刚恢复的服务。</span><span class="sxs-lookup"><span data-stu-id="7e575-256">At the point where the test succeeds, the application can resume normal operations and pass requests to the newly recovered service.</span></span>

    - <span data-ttu-id="7e575-257">同时，可以故障回复到服务的另一个实例（也许在不同的数据中心或应用程序中）、使用提供兼容（也许是更简单）功能的类似服务，或执行某些替代操作，以期该服务很快可供使用。</span><span class="sxs-lookup"><span data-stu-id="7e575-257">In the meantime, it may be possible to fall back to another instance of the service (perhaps in a different datacenter or application), use a similar service that offers compatible (perhaps simpler) functionality, or perform some alternative operations in the hope that the service will become available soon.</span></span> <span data-ttu-id="7e575-258">例如，有时适合将服务的请求存储在队列或数据存储中，供以后重复使用。</span><span class="sxs-lookup"><span data-stu-id="7e575-258">For example, it may be appropriate to store requests for the service in a queue or data store and replay them later.</span></span> <span data-ttu-id="7e575-259">也可以将用户重定向到应用程序的其他实例、使应用程序性能降级但仍可提供可接受的功能，或者只是将消息返回给用户，指出应用程序暂时不可用。</span><span class="sxs-lookup"><span data-stu-id="7e575-259">Otherwise you might be able to redirect the user to an alternative instance of the application, degrade the performance of the application but still offer acceptable functionality, or just return a message to the user indicating that the application is not available at present.</span></span>

- <span data-ttu-id="7e575-260">**其他注意事项**</span><span class="sxs-lookup"><span data-stu-id="7e575-260">**Other considerations**</span></span>
  
  - <span data-ttu-id="7e575-261">确定重试次数的值和策略的重试间隔时，请考虑服务或资源的操作是否是长时间运行的或多步骤操作的一部分。</span><span class="sxs-lookup"><span data-stu-id="7e575-261">When deciding on the values for the number of retries and the retry intervals for a policy, consider if the operation on the service or resource is part of a long-running or multi-step operation.</span></span> <span data-ttu-id="7e575-262">当某个操作步骤失败时，补偿其他所有操作步骤可能会很困难或代价非凡。</span><span class="sxs-lookup"><span data-stu-id="7e575-262">It may be difficult or expensive to compensate all the other operational steps that have already succeeded when one fails.</span></span> <span data-ttu-id="7e575-263">在此情况下，可以接受很长的间隔及大量的重试次数，前提是不会因为保留或锁定稀缺资源而阻止其他操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-263">In this case, a very long interval and a large number of retries may be acceptable as long as it does not block other operations by holding or locking scarce resources.</span></span>

  - <span data-ttu-id="7e575-264">考虑重试相同的操作是否会导致数据不一致。</span><span class="sxs-lookup"><span data-stu-id="7e575-264">Consider if retrying the same operation may cause inconsistencies in data.</span></span> <span data-ttu-id="7e575-265">如果多步骤过程中的某些部分是重复的，并且操作不是幂等的，则可能会导致不一致情况。</span><span class="sxs-lookup"><span data-stu-id="7e575-265">If some parts of a multi-step process are repeated, and the operations are not idempotent, it may result in an inconsistency.</span></span> <span data-ttu-id="7e575-266">例如，递增值的操作如果重复，则会生成无效的结果。</span><span class="sxs-lookup"><span data-stu-id="7e575-266">For example, an operation that increments a value, if repeated, will produce an invalid result.</span></span> <span data-ttu-id="7e575-267">重复执行将消息发送到队列的操作如果无法检测到重复消息，则可能会对消息使用者造成不一致情况。</span><span class="sxs-lookup"><span data-stu-id="7e575-267">Repeating an operation that sends a message to a queue may cause an inconsistency in the message consumer if it cannot detect duplicate messages.</span></span> <span data-ttu-id="7e575-268">要避免此问题，请确保将每个步骤设计成幂等操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-268">To prevent this, ensure that you design each step as an idempotent operation.</span></span> <span data-ttu-id="7e575-269">有关幂等性的详细信息，请参阅[幂等模式][idempotency-patterns]。</span><span class="sxs-lookup"><span data-stu-id="7e575-269">For more information about idempotency, see [Idempotency patterns][idempotency-patterns].</span></span>

  - <span data-ttu-id="7e575-270">考虑重试操作的范围。</span><span class="sxs-lookup"><span data-stu-id="7e575-270">Consider the scope of the operations that will be retried.</span></span> <span data-ttu-id="7e575-271">例如，可以更轻松地在包含数个操作的级别实施重试代码，如果其中一个操作失败，则重试所有操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-271">For example, it may be easier to implement retry code at a level that encompasses several operations, and retry them all if one fails.</span></span> <span data-ttu-id="7e575-272">但是，这可能会导致幂等性问题或不必要的回滚操作。</span><span class="sxs-lookup"><span data-stu-id="7e575-272">However, doing this may result in idempotency issues or unnecessary rollback operations.</span></span>

  - <span data-ttu-id="7e575-273">如果选择的重试范围包含多个操作，在确定重试间隔时、监视花费时间时，以及因失败而引发警报之前，请考虑所有操作的延迟总和。</span><span class="sxs-lookup"><span data-stu-id="7e575-273">If you choose a retry scope that encompasses several operations, take into account the total latency of all of them when determining the retry intervals, when monitoring the time taken, and before raising alerts for failures.</span></span>

  - <span data-ttu-id="7e575-274">考虑重试策略如何影响共享应用程序中的邻居或其他租户，以及何时使用共享资源与服务。</span><span class="sxs-lookup"><span data-stu-id="7e575-274">Consider how your retry strategy may affect neighbors and other tenants in a shared application, or when using shared resources and services.</span></span> <span data-ttu-id="7e575-275">积极重试策略会导致其他用户以及共享资源与服务的应用程序发生越来越多的暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="7e575-275">Aggressive retry policies can cause an increasing number of transient faults to occur for these other users and for applications that share the resources and services.</span></span> <span data-ttu-id="7e575-276">同样地，应用程序可能会受到资源与服务的其他用户所实施的重试策略的影响。</span><span class="sxs-lookup"><span data-stu-id="7e575-276">Likewise, your application may be affected by the retry policies implemented by other users of the resources and services.</span></span> <span data-ttu-id="7e575-277">对于任务关键型应用程序，可以决定使用非共享的高级服务。</span><span class="sxs-lookup"><span data-stu-id="7e575-277">For mission-critical applications, you may decide to use premium services that are not shared.</span></span> <span data-ttu-id="7e575-278">这样就可以更好地控制这些资源与服务的负载与后续限制，从而找到提高成本的理由。</span><span class="sxs-lookup"><span data-stu-id="7e575-278">This provides you with much more control over the load and consequent throttling of these resources and services, which can help to justify the additional cost.</span></span>

## <a name="more-information"></a><span data-ttu-id="7e575-279">详细信息</span><span class="sxs-lookup"><span data-stu-id="7e575-279">More information</span></span>

- [<span data-ttu-id="7e575-280">特定于 Azure 服务的重试指导原则</span><span class="sxs-lookup"><span data-stu-id="7e575-280">Azure service-specific retry guidelines</span></span>](./retry-service-specific.md)
- [<span data-ttu-id="7e575-281">断路器模式</span><span class="sxs-lookup"><span data-stu-id="7e575-281">Circuit Breaker pattern</span></span>](../patterns/circuit-breaker.md)
- [<span data-ttu-id="7e575-282">补偿事务模式</span><span class="sxs-lookup"><span data-stu-id="7e575-282">Compensating Transaction pattern</span></span>](../patterns/compensating-transaction.md)
- <span data-ttu-id="7e575-283">[幂等模式][idempotency-patterns]</span><span class="sxs-lookup"><span data-stu-id="7e575-283">[Idempotency patterns][idempotency-patterns]</span></span>

<!-- links -->

[idempotency-patterns]: https://blog.jonathanoliver.com/idempotency-patterns/
