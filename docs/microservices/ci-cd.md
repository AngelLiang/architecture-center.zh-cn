---
title: 微服务的 CI/CD
description: 微服务的持续集成和持续交付。
author: MikeWasson
ms.date: 03/27/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: f7f3f3d48087db51c40f134e3e4cf11ec58501bb
ms.sourcegitcommit: d58e6b2b891c9c99e951c59f15fce71addcb96b1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/12/2019
ms.locfileid: "59533084"
---
# <a name="cicd-for-microservices-architectures"></a><span data-ttu-id="7a5a3-103">微服务体系结构的 CI/CD</span><span class="sxs-lookup"><span data-stu-id="7a5a3-103">CI/CD for microservices architectures</span></span>

<span data-ttu-id="7a5a3-104">加速发布周期是微服务体系结构的主要优点之一。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-104">Faster release cycles are one of the major advantages of microservices architectures.</span></span> <span data-ttu-id="7a5a3-105">但不会不正确的 CI/CD 过程，实现微服务的灵活性。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-105">But without a good CI/CD process, you won't achieve the agility that microservices promise.</span></span> <span data-ttu-id="7a5a3-106">本文介绍具体的难题，并建议解决问题的一些方法。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-106">This article describes the challenges and recommends some approaches to the problem.</span></span>

## <a name="what-is-cicd"></a><span data-ttu-id="7a5a3-107">什么是 CI/CD？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-107">What is CI/CD?</span></span>

<span data-ttu-id="7a5a3-108">当我们谈及 CI/CD 时，我们真正谈论的多个相关过程：持续集成、持续交付和持续部署。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-108">When we talk about CI/CD, we're really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="7a5a3-109">**持续集成**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-109">**Continuous integration**.</span></span> <span data-ttu-id="7a5a3-110">代码更改经常被合并到主分支。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-110">Code changes are frequently merged into the main branch.</span></span> <span data-ttu-id="7a5a3-111">自动生成和测试过程确保主分支中的代码始终是生产质量。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-111">Automated build and test processes ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="7a5a3-112">**持续交付**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-112">**Continuous delivery**.</span></span> <span data-ttu-id="7a5a3-113">将 CI 过程的任何代码更改自动发布到类似生产的环境。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-113">Any code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="7a5a3-114">部署到实时生产环境可能需要人工批准，否则可自动进行。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-114">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="7a5a3-115">目标是让代码始终做好部署到生产环境的准备。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-115">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="7a5a3-116">**连续部署**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-116">**Continuous deployment**.</span></span> <span data-ttu-id="7a5a3-117">代码更改前两个步骤会自动部署的阶段*到生产环境*。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-117">Code changes that pass the previous two steps are automatically deployed *into production*.</span></span>

<span data-ttu-id="7a5a3-118">下面是微服务体系结构的可靠 CI/CD 过程的一些目标：</span><span class="sxs-lookup"><span data-stu-id="7a5a3-118">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="7a5a3-119">每个团队可以独立生成并部署自有的服务，而不影响或干扰其他团队。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-119">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="7a5a3-120">新服务版本在部署到生产环境之前，会先部署到开发/测试/QA 环境进行验证。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-120">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="7a5a3-121">在每个阶段强制实施质量控制。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-121">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="7a5a3-122">可以与以前的版本并行部署服务的新版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-122">A new version of a service can be deployed side by side with the previous version.</span></span>

- <span data-ttu-id="7a5a3-123">实施足够的访问控制策略。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-123">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="7a5a3-124">适用于容器化工作负荷，可以信任的容器映像部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-124">For containerized workloads, you can trust the container images that are deployed to production.</span></span>

## <a name="why-a-robust-cicd-pipeline-matters"></a><span data-ttu-id="7a5a3-125">为什么很重要的功能强大的 CI/CD 管道</span><span class="sxs-lookup"><span data-stu-id="7a5a3-125">Why a robust CI/CD pipeline matters</span></span>

<span data-ttu-id="7a5a3-126">在传统的整体应用程序是一个生成管道的输出就是可执行应用程序。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-126">In a traditional monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="7a5a3-127">所有开发工作都会馈送到此管道中。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-127">All development work feeds into this pipeline.</span></span> <span data-ttu-id="7a5a3-128">如果发现了高优先级 bug，则必须集成、测试然后发布修复程序，这可能会延缓新功能的发布。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-128">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="7a5a3-129">通过拥有良好分解模块和使用功能分支代码更改的影响降至最低，可以缓解这些问题。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-129">You can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="7a5a3-130">但是，随着应用程序变得越来越复杂和更多功能的添加，整体应用程序的发布过程往往会变得更加脆弱且可能中断。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-130">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="7a5a3-131">根据微服务的理念，永远不应出现一个要让每个团队遵守的冗长发布周期。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-131">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="7a5a3-132">生成服务“A”的团队随时可以发布更新，而无需等到已合并、测试并部署服务“B”中的更改。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-132">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span>

![CI/CD 单体架构图](./images/cicd-monolith.png)

<span data-ttu-id="7a5a3-134">若要实现较高发布速度，发布管道必须自动化且高度可靠，风险降至最低。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-134">To achieve a high release velocity, your release pipeline must be automated and highly reliable, to minimize risk.</span></span> <span data-ttu-id="7a5a3-135">如果您发布到生产环境每天或一天内多次，回归或服务中断必须是非常少见。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-135">If you release to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="7a5a3-136">同时，如果部署了错误的更新，则必须通过可靠的方式快速回滚或者前滚到以前的服务版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-136">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

## <a name="challenges"></a><span data-ttu-id="7a5a3-137">挑战</span><span class="sxs-lookup"><span data-stu-id="7a5a3-137">Challenges</span></span>

- <span data-ttu-id="7a5a3-138">**许多小型的独立代码库**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-138">**Many small independent code bases**.</span></span> <span data-ttu-id="7a5a3-139">每个团队负责使用自己的生成管道生成自己的服务。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-139">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="7a5a3-140">在某些组织中，团队可能会使用单独的代码存储库。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-140">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="7a5a3-141">了解如何构建系统的各个团队，且在组织中没有人知道如何部署整个应用程序可能会导致单独存储库。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-141">Separate repositories can lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="7a5a3-142">例如，在灾难恢复方案中，如果需要快速部署到新群集，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-142">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

    <span data-ttu-id="7a5a3-143">**缓解措施**：具有统一的自动化管道，以便生成和部署服务，以使这一知识不会"隐藏"每个团队中。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-143">**Mitigation**: Have a unified and automated pipeline to build and deploy services, so that this knowledge is not "hidden" within each team.</span></span>

- <span data-ttu-id="7a5a3-144">**多种语言和框架**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-144">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="7a5a3-145">如果每个团队混合使用其自身的技术，则可能难以创建一套可在整个组织中运用的单一生成过程。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-145">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="7a5a3-146">生成过程必须足够灵活，使每个团队能够根据所选的语言或框架来改编它。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-146">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

    <span data-ttu-id="7a5a3-147">**缓解措施**：容器化每个服务的生成过程。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-147">**Mitigation**: Containerize the build process for each service.</span></span> <span data-ttu-id="7a5a3-148">这样一来，生成系统只需将无法运行容器。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-148">That way, the build system just needs to be able to run the containers.</span></span>

- <span data-ttu-id="7a5a3-149">**集成和负载测试**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-149">**Integration and load testing**.</span></span> <span data-ttu-id="7a5a3-150">如果团队根据自己的步调发布更新，则可能难以设计可靠的端到端测试，尤其是当服务彼此依赖时。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-150">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="7a5a3-151">此外，运行整个生产群集可能成本高昂，所以不太可能每个团队将以生产规模，仅用于测试运行整个群集。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-151">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="7a5a3-152">**发布管理**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-152">**Release management**.</span></span> <span data-ttu-id="7a5a3-153">每个团队应能够将更新部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-153">Every team should be able to deploy an update to production.</span></span> <span data-ttu-id="7a5a3-154">这并不意味着每个团队成员都有权这样做。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-154">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="7a5a3-155">但是，设置集中式“发布管理员”角色可能降低部署速度。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-155">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span>

    <span data-ttu-id="7a5a3-156">**Migitation**:CI/CD 过程的自动化程度和可靠性越高，对集中授权的需求就越少。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-156">**Migitation**: The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="7a5a3-157">也就是说，可以对主要功能更新与次要 bug 修复的发布采用不同的策略。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-157">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="7a5a3-158">分散化并不意味着任何监管。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-158">Being decentralized doesn't mean zero governance.</span></span>

- <span data-ttu-id="7a5a3-159">**服务更新**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-159">**Service updates**.</span></span> <span data-ttu-id="7a5a3-160">将某个服务更新到新版本时，更新过程不应中断依赖于该服务的其他服务。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-160">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span>

    <span data-ttu-id="7a5a3-161">**缓解措施**：部署技术，如蓝绿或金丝雀发布用于非重大更改。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-161">**Mitigation**: Use deployment techniques such as blue-green or canary release for non-breaking changes.</span></span> <span data-ttu-id="7a5a3-162">重大 API 更改，将部署与以前的版本并行的新版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-162">For breaking API changes, deploy the new version side by side with the previous version.</span></span> <span data-ttu-id="7a5a3-163">这样一来，使用以前的 API 的服务可以更新和测试新的 api。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-163">That way, services that consume the previous API can be updated and tested for the new API.</span></span> <span data-ttu-id="7a5a3-164">请参阅[更新服务](#updating-services)下文。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-164">See [Updating services](#updating-services), below.</span></span>

## <a name="monorepo-vs-multi-repo"></a><span data-ttu-id="7a5a3-165">Monorepo vs 多个存储库</span><span class="sxs-lookup"><span data-stu-id="7a5a3-165">Monorepo vs multi-repo</span></span>

<span data-ttu-id="7a5a3-166">在创建 CI/CD 工作流之前，必须了解如何对代码库进行结构设计和管理。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-166">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="7a5a3-167">团队是在多个单独的存储库中工作，还是在一个 monorepo（单存储库）中工作？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-167">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="7a5a3-168">什么是分库策略？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-168">What is your branching strategy?</span></span>
- <span data-ttu-id="7a5a3-169">谁可以将代码推送到生产环境中？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-169">Who can push code to production?</span></span> <span data-ttu-id="7a5a3-170">是否有发布经理角色？</span><span class="sxs-lookup"><span data-stu-id="7a5a3-170">Is there a release manager role?</span></span>

<span data-ttu-id="7a5a3-171">首选单存储库方法，但二者各有优缺点。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-171">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="7a5a3-172">单存储库</span><span class="sxs-lookup"><span data-stu-id="7a5a3-172">Monorepo</span></span> | <span data-ttu-id="7a5a3-173">多存储库</span><span class="sxs-lookup"><span data-stu-id="7a5a3-173">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="7a5a3-174">**优点**</span><span class="sxs-lookup"><span data-stu-id="7a5a3-174">**Advantages**</span></span> | <span data-ttu-id="7a5a3-175">代码共享</span><span class="sxs-lookup"><span data-stu-id="7a5a3-175">Code sharing</span></span><br/><span data-ttu-id="7a5a3-176">更易于实现代码和工具的标准化</span><span class="sxs-lookup"><span data-stu-id="7a5a3-176">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="7a5a3-177">更易于重构代码</span><span class="sxs-lookup"><span data-stu-id="7a5a3-177">Easier to refactor code</span></span><br/><span data-ttu-id="7a5a3-178">可发现性 - 代码的单一视图</span><span class="sxs-lookup"><span data-stu-id="7a5a3-178">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="7a5a3-179">按团队清除所有权</span><span class="sxs-lookup"><span data-stu-id="7a5a3-179">Clear ownership per team</span></span><br/><span data-ttu-id="7a5a3-180">合并冲突可能会更少</span><span class="sxs-lookup"><span data-stu-id="7a5a3-180">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="7a5a3-181">有助于强制分离微服务</span><span class="sxs-lookup"><span data-stu-id="7a5a3-181">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="7a5a3-182">**挑战**</span><span class="sxs-lookup"><span data-stu-id="7a5a3-182">**Challenges**</span></span> | <span data-ttu-id="7a5a3-183">对共享代码进行的更改可能影响多个微服务</span><span class="sxs-lookup"><span data-stu-id="7a5a3-183">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="7a5a3-184">合并冲突可能会更多</span><span class="sxs-lookup"><span data-stu-id="7a5a3-184">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="7a5a3-185">工具必须缩放成大型代码库</span><span class="sxs-lookup"><span data-stu-id="7a5a3-185">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="7a5a3-186">访问控制</span><span class="sxs-lookup"><span data-stu-id="7a5a3-186">Access control</span></span><br/><span data-ttu-id="7a5a3-187">部署过程更复杂</span><span class="sxs-lookup"><span data-stu-id="7a5a3-187">More complex deployment process</span></span> | <span data-ttu-id="7a5a3-188">更难以共享代码</span><span class="sxs-lookup"><span data-stu-id="7a5a3-188">Harder to share code</span></span><br/><span data-ttu-id="7a5a3-189">更难以强制实施编码标准</span><span class="sxs-lookup"><span data-stu-id="7a5a3-189">Harder to enforce coding standards</span></span><br/><span data-ttu-id="7a5a3-190">依赖项管理</span><span class="sxs-lookup"><span data-stu-id="7a5a3-190">Dependency management</span></span><br/><span data-ttu-id="7a5a3-191">代码库分散，可发现性低</span><span class="sxs-lookup"><span data-stu-id="7a5a3-191">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="7a5a3-192">缺少共享的基础架构</span><span class="sxs-lookup"><span data-stu-id="7a5a3-192">Lack of shared infrastructure</span></span>

## <a name="updating-services"></a><span data-ttu-id="7a5a3-193">更新服务</span><span class="sxs-lookup"><span data-stu-id="7a5a3-193">Updating services</span></span>

<span data-ttu-id="7a5a3-194">可通过多种策略来更新已部署到生产环境的服务。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-194">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="7a5a3-195">下面介绍三个常用选项：滚动更新、蓝绿部署和 Canary 发布。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-195">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-updates"></a><span data-ttu-id="7a5a3-196">滚动更新</span><span class="sxs-lookup"><span data-stu-id="7a5a3-196">Rolling updates</span></span>

<span data-ttu-id="7a5a3-197">在滚动更新中部署服务的新实例，然后，新实例可开始立即接收请求。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-197">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="7a5a3-198">启动新实例后，以前的实例将被删除。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-198">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="7a5a3-199">**示例。**</span><span class="sxs-lookup"><span data-stu-id="7a5a3-199">**Example.**</span></span> <span data-ttu-id="7a5a3-200">在 Kubernetes 中，滚动更新，更新部署的 pod 规范时是默认行为。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-200">In Kubernetes, rolling updates are the default behavior when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="7a5a3-201">部署控制器为更新的 pod 创建新的副本集。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-201">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="7a5a3-202">然后，它会纵向扩展新的副本集并纵向缩减旧的副本集，以保持所需的副本计数。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-202">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="7a5a3-203">在新 pod 准备就绪之前，它不会删除旧 pod。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-203">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="7a5a3-204">Kubernetes 保留更新的历史记录，因此可以回滚更新必要。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-204">Kubernetes keeps a history of the update, so you can roll back an update if needed.</span></span>

<span data-ttu-id="7a5a3-205">滚动更新的一个难题在于，在更新过程中，旧版本和新版本将混合运行并接收流量。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-205">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="7a5a3-206">在此期间，任何请求都可能路由到两个版本中的一个。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-206">During this period, any request could get routed to either of the two versions.</span></span>

<span data-ttu-id="7a5a3-207">对于重大 API 更改，较好的做法是支持并排显示，这两个版本，直到更新以前版本的所有客户端。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-207">For breaking API changes, a good practice is to support both versions side by side, until all clients of the previous version are updated.</span></span> <span data-ttu-id="7a5a3-208">请参阅[API 版本控制](./design/api-design.md#api-versioning)。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-208">See [API versioning](./design/api-design.md#api-versioning).</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="7a5a3-209">蓝绿部署</span><span class="sxs-lookup"><span data-stu-id="7a5a3-209">Blue-green deployment</span></span>

<span data-ttu-id="7a5a3-210">在蓝绿部署中，需要连同以前的版本一起部署新版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-210">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="7a5a3-211">验证新版本之后，可以一次性地将所有流量从以前的版本切换到新版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-211">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="7a5a3-212">切换后，可以监视应用程序中的任何问题。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-212">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="7a5a3-213">如果出现问题，可以切换回到旧版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-213">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="7a5a3-214">如果没有任何问题，则可以删除旧版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-214">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="7a5a3-215">对于较传统的整体或 N 层应用程序而言，蓝绿部署通常要预配两个相同的环境。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-215">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="7a5a3-216">需将新版本部署到过渡环境，然后将客户端流量重定向到过渡环境 &mdash; 例如，通过交换 VIP 地址。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-216">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span> <span data-ttu-id="7a5a3-217">在微服务体系结构中，更新将发生在微服务级别，因此通常会将更新部署到同一个环境，并使用服务发现机制来交换。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-217">In a microservices architecture, updates happen at the microservice level, so you would typically deploy the update into the same environment and use a service discovery mechanism to swap.</span></span>

<span data-ttu-id="7a5a3-218">**示例**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-218">**Example**.</span></span> <span data-ttu-id="7a5a3-219">在 Kubernetes 中，不需要预配单独的群集即可执行蓝绿部署。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-219">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="7a5a3-220">可以利用选择器。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-220">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="7a5a3-221">使用新的 pod 规范和一组不同的标签创建新的部署资源。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-221">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="7a5a3-222">无需删除以前的部署或修改指向该部署的服务，即可创建此部署。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-222">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="7a5a3-223">运行新 pod 后，可以更新服务的选择器，以匹配新部署。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-223">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="7a5a3-224">蓝绿部署的一个缺点是在更新期间运行数两倍的服务的 pod （当前和下一步）。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-224">One drawback of blue-green deployment is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="7a5a3-225">如果 pod 需要大量的 CPU 或内存资源，则可能需要暂时横向扩展群集以处理资源消耗。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-225">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="7a5a3-226">Canary 发布</span><span class="sxs-lookup"><span data-stu-id="7a5a3-226">Canary release</span></span>

<span data-ttu-id="7a5a3-227">在 Canary 发布中，可将更新的版本推出到少量的客户端。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-227">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="7a5a3-228">然后，可以监视新服务的行为，再将它推出到所有客户端。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-228">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="7a5a3-229">这样，便可以通过受控的方式慢速推出，观察真实数据并发现问题，避免对所有客户造成影响。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-229">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="7a5a3-230">Canary 发布比蓝绿部署或滚动更新更难于管理，因为必须动态将请求路由到服务的不同版本。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-230">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span>

<span data-ttu-id="7a5a3-231">**示例**。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-231">**Example**.</span></span> <span data-ttu-id="7a5a3-232">在 Kubernetes 中，可将服务配置为跨越两个副本集（每个版本各有一个），并手动调整副本计数。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-232">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="7a5a3-233">但是，由于 Kubernetes 跨 pod 进行负载均衡的方式，这种方法不够精确。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-233">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="7a5a3-234">例如，如果总共 10 个副本，你可以只上移以 10%的增量的流量。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-234">For example, if you have a total of 10 replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="7a5a3-235">如果使用服务网格，则可以使用服务网格路由规则来实现更复杂的 Canary 发布策略。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-235">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span>

## <a name="next-steps"></a><span data-ttu-id="7a5a3-236">后续步骤</span><span class="sxs-lookup"><span data-stu-id="7a5a3-236">Next steps</span></span>

<span data-ttu-id="7a5a3-237">了解微服务在 Kubernetes 上运行的特定 CI/CD 实践。</span><span class="sxs-lookup"><span data-stu-id="7a5a3-237">Learn specific CI/CD practices for microservices running on Kubernetes.</span></span>

- [<span data-ttu-id="7a5a3-238">在 Kubernetes 上的微服务的 CI/CD</span><span class="sxs-lookup"><span data-stu-id="7a5a3-238">CI/CD for microservices on Kubernetes</span></span>](./ci-cd-kubernetes.md)