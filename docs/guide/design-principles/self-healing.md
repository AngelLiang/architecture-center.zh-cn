---
title: 自我修复型设计
titleSuffix: Azure Application Architecture Guide
description: 可复原应用程序可从故障中恢复，而无需人工干预。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 5e5af0be41fa892e490d556ef4286d5367144fd9
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/20/2019
ms.locfileid: "58249502"
---
# <a name="design-for-self-healing"></a><span data-ttu-id="296be-103">自我修复型设计</span><span class="sxs-lookup"><span data-stu-id="296be-103">Design for self healing</span></span>

## <a name="design-your-application-to-be-self-healing-when-failures-occur"></a><span data-ttu-id="296be-104">设计应用程序以在故障发生时进行自我修复</span><span class="sxs-lookup"><span data-stu-id="296be-104">Design your application to be self healing when failures occur</span></span>

<span data-ttu-id="296be-105">分布式系统中会发生故障。</span><span class="sxs-lookup"><span data-stu-id="296be-105">In a distributed system, failures happen.</span></span> <span data-ttu-id="296be-106">硬件会故障。</span><span class="sxs-lookup"><span data-stu-id="296be-106">Hardware can fail.</span></span> <span data-ttu-id="296be-107">网络也有可能发生暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="296be-107">The network can have transient failures.</span></span> <span data-ttu-id="296be-108">极少数情况下，整个服务或区域可能会遇到中断，但这些故障必须在计划之内。</span><span class="sxs-lookup"><span data-stu-id="296be-108">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="296be-109">因此，设计的应用程序在故障发生时可进行自我修复。</span><span class="sxs-lookup"><span data-stu-id="296be-109">Therefore, design an application to be self healing when failures occur.</span></span> <span data-ttu-id="296be-110">这需要从三个方面入手：</span><span class="sxs-lookup"><span data-stu-id="296be-110">This requires a three-pronged approach:</span></span>

- <span data-ttu-id="296be-111">检测故障。</span><span class="sxs-lookup"><span data-stu-id="296be-111">Detect failures.</span></span>
- <span data-ttu-id="296be-112">从容应对故障。</span><span class="sxs-lookup"><span data-stu-id="296be-112">Respond to failures gracefully.</span></span>
- <span data-ttu-id="296be-113">记录和监视故障，获取操作见解。</span><span class="sxs-lookup"><span data-stu-id="296be-113">Log and monitor failures, to give operational insight.</span></span>

<span data-ttu-id="296be-114">如何应对特定类型的故障可能取决于应用程序的可用性需求。</span><span class="sxs-lookup"><span data-stu-id="296be-114">How you respond to a particular type of failure may depend on your application's availability requirements.</span></span> <span data-ttu-id="296be-115">例如，如果需要非常高的可用性，则可能在区域中断期间自动故障转移到次要区域。</span><span class="sxs-lookup"><span data-stu-id="296be-115">For example, if you require very high availability, you might automatically fail over to a secondary region during a regional outage.</span></span> <span data-ttu-id="296be-116">然而，这将使成本高于单区域部署。</span><span class="sxs-lookup"><span data-stu-id="296be-116">However, that will incur a higher cost than a single-region deployment.</span></span>

<span data-ttu-id="296be-117">此外，不要只考虑像区域中断这类大事件，因为这种情况通常鲜有发生。</span><span class="sxs-lookup"><span data-stu-id="296be-117">Also, don't just consider big events like regional outages, which are generally rare.</span></span> <span data-ttu-id="296be-118">应该尽可能将注意力集中在处理本地短期的故障上，例如网络连接故障或数据库连接失败等。</span><span class="sxs-lookup"><span data-stu-id="296be-118">You should focus as much, if not more, on handling local, short-lived failures, such as network connectivity failures or failed database connections.</span></span>

## <a name="recommendations"></a><span data-ttu-id="296be-119">建议</span><span class="sxs-lookup"><span data-stu-id="296be-119">Recommendations</span></span>

<span data-ttu-id="296be-120">**重试失败的操作**。</span><span class="sxs-lookup"><span data-stu-id="296be-120">**Retry failed operations**.</span></span> <span data-ttu-id="296be-121">发生暂时性故障的原因可能有：短暂的网络连接中断、删除了数据库连接或服务因繁忙而超时。</span><span class="sxs-lookup"><span data-stu-id="296be-121">Transient failures may occur due to momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="296be-122">在应用程序中构建重试逻辑来处理暂时性故障。</span><span class="sxs-lookup"><span data-stu-id="296be-122">Build retry logic into your application to handle transient failures.</span></span> <span data-ttu-id="296be-123">对于许多 Azure 服务，客户端 SDK 可实施自动重试。</span><span class="sxs-lookup"><span data-stu-id="296be-123">For many Azure services, the client SDK implements automatic retries.</span></span> <span data-ttu-id="296be-124">有关详细信息，请参阅[暂时性故障处理][transient-fault-handling]和[重试模式][retry]。</span><span class="sxs-lookup"><span data-stu-id="296be-124">For more information, see [Transient fault handling][transient-fault-handling] and the [Retry pattern][retry].</span></span>

<span data-ttu-id="296be-125">**保护故障远程服务（断路器）**。</span><span class="sxs-lookup"><span data-stu-id="296be-125">**Protect failing remote services (Circuit Breaker)**.</span></span> <span data-ttu-id="296be-126">在暂时性故障后最好进行重试，但如果故障仍然存在，最终可能会有非常多的调用方攻击故障服务。</span><span class="sxs-lookup"><span data-stu-id="296be-126">It's good to retry after a transient failure, but if the failure persists, you can end up with too many callers hammering a failing service.</span></span> <span data-ttu-id="296be-127">因为请求进行了备份，这可能导致级联故障。</span><span class="sxs-lookup"><span data-stu-id="296be-127">This can lead to cascading failures, as requests back up.</span></span> <span data-ttu-id="296be-128">当操作可能失败时，使用[断路器模式][circuit-breaker]进行快速失败（不进行远程调用）。</span><span class="sxs-lookup"><span data-stu-id="296be-128">Use the [Circuit Breaker pattern][circuit-breaker] to fail fast (without making the remote call) when an operation is likely to fail.</span></span>

<span data-ttu-id="296be-129">**隔离关键资源（隔层）**。</span><span class="sxs-lookup"><span data-stu-id="296be-129">**Isolate critical resources (Bulkhead)**.</span></span> <span data-ttu-id="296be-130">子系统中的故障有时会发生级联。</span><span class="sxs-lookup"><span data-stu-id="296be-130">Failures in one subsystem can sometimes cascade.</span></span> <span data-ttu-id="296be-131">如果某个故障导致某些资源（例如线程或套接字）无法及时释放，导致资源耗尽，则可能就会发生这种连锁反应。</span><span class="sxs-lookup"><span data-stu-id="296be-131">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> <span data-ttu-id="296be-132">为了避免此问题，请将系统分区为独立的组，使一个分区中的故障不会导致整个系统瘫痪。</span><span class="sxs-lookup"><span data-stu-id="296be-132">To avoid this, partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span>

<span data-ttu-id="296be-133">**执行负载分级**。</span><span class="sxs-lookup"><span data-stu-id="296be-133">**Perform load leveling**.</span></span> <span data-ttu-id="296be-134">应用程序可能会遇到突发流量高峰，导致后端上的服务瘫痪。</span><span class="sxs-lookup"><span data-stu-id="296be-134">Applications may experience sudden spikes in traffic that can overwhelm services on the backend.</span></span> <span data-ttu-id="296be-135">为了避免此问题，请使用[基于队列的负载调节模式][load-level]使工作项排队进行异步运行。</span><span class="sxs-lookup"><span data-stu-id="296be-135">To avoid this, use the [Queue-Based Load Leveling pattern][load-level] to queue work items to run asynchronously.</span></span> <span data-ttu-id="296be-136">队列充当可平缓负载高峰的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="296be-136">The queue acts as a buffer that smooths out peaks in the load.</span></span>

<span data-ttu-id="296be-137">**故障转移**。</span><span class="sxs-lookup"><span data-stu-id="296be-137">**Fail over**.</span></span> <span data-ttu-id="296be-138">如果无法访问某个实例，请故障转移到另一个实例。</span><span class="sxs-lookup"><span data-stu-id="296be-138">If an instance can't be reached, fail over to another instance.</span></span> <span data-ttu-id="296be-139">对于 Web 服务器之类的无状态对象，请在负载均衡器或流量管理器后放置一些实例。</span><span class="sxs-lookup"><span data-stu-id="296be-139">For things that are stateless, like a web server, put several instances behind a load balancer or traffic manager.</span></span> <span data-ttu-id="296be-140">对于数据库之类的存储状态的对象，请使用副本和故障转移。</span><span class="sxs-lookup"><span data-stu-id="296be-140">For things that store state, like a database, use replicas and fail over.</span></span> <span data-ttu-id="296be-141">根据数据存储和复制方式，可能需要应用程序处理最终的一致性。</span><span class="sxs-lookup"><span data-stu-id="296be-141">Depending on the data store and how it replicates, this may require the application to deal with eventual consistency.</span></span>

<span data-ttu-id="296be-142">**补偿失败的事务**。</span><span class="sxs-lookup"><span data-stu-id="296be-142">**Compensate failed transactions**.</span></span> <span data-ttu-id="296be-143">一般情况下，需避免分布式事务，因为它们需要协调服务和资源。</span><span class="sxs-lookup"><span data-stu-id="296be-143">In general, avoid distributed transactions, as they require coordination across services and resources.</span></span> <span data-ttu-id="296be-144">相反，应该用较小的单个事务组成操作。</span><span class="sxs-lookup"><span data-stu-id="296be-144">Instead, compose an operation from smaller individual transactions.</span></span> <span data-ttu-id="296be-145">如果在中途操作失败，请使用[补偿事务][compensating-transactions]撤销已完成的所有步骤。</span><span class="sxs-lookup"><span data-stu-id="296be-145">If the operation fails midway through, use [Compensating Transactions][compensating-transactions] to undo any step that already completed.</span></span>

<span data-ttu-id="296be-146">**检查点长时间运行的事务**。</span><span class="sxs-lookup"><span data-stu-id="296be-146">**Checkpoint long-running transactions**.</span></span> <span data-ttu-id="296be-147">如果长时间运行的操作失败，检查点可以提供复原能力。</span><span class="sxs-lookup"><span data-stu-id="296be-147">Checkpoints can provide resiliency if a long-running operation fails.</span></span> <span data-ttu-id="296be-148">当操作重新启动时（例如，它被另一个 VM 选中），它可以从上一个检查点恢复。</span><span class="sxs-lookup"><span data-stu-id="296be-148">When the operation restarts (for example, it is picked up by another VM), it can be resumed from the last checkpoint.</span></span>

<span data-ttu-id="296be-149">**正常降级**。</span><span class="sxs-lookup"><span data-stu-id="296be-149">**Degrade gracefully**.</span></span> <span data-ttu-id="296be-150">有时某个问题无法解决，但可以提供仍然有用的缩减版功能。</span><span class="sxs-lookup"><span data-stu-id="296be-150">Sometimes you can't work around a problem, but you can provide reduced functionality that is still useful.</span></span> <span data-ttu-id="296be-151">假设某个应用程序显示图书目录。</span><span class="sxs-lookup"><span data-stu-id="296be-151">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="296be-152">如果该应用程序无法检索封面的缩略图图像，它可能显示占位符图像。</span><span class="sxs-lookup"><span data-stu-id="296be-152">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="296be-153">整个子系统可能对应用程序不重要。</span><span class="sxs-lookup"><span data-stu-id="296be-153">Entire subsystems might be noncritical for the application.</span></span> <span data-ttu-id="296be-154">例如，在电子商务网站，显示产品建议可能没有处理订单重要。</span><span class="sxs-lookup"><span data-stu-id="296be-154">For example, in an e-commerce site, showing product recommendations is probably less critical than processing orders.</span></span>

<span data-ttu-id="296be-155">**限制客户端**。</span><span class="sxs-lookup"><span data-stu-id="296be-155">**Throttle clients**.</span></span> <span data-ttu-id="296be-156">有时，少量的用户会产生过多的负载，降低了应用程序对其他用户的可用性。</span><span class="sxs-lookup"><span data-stu-id="296be-156">Sometimes a small number of users create excessive load, which can reduce your application's availability for other users.</span></span> <span data-ttu-id="296be-157">在这种情况下，可以在一段时间内限制客户端。</span><span class="sxs-lookup"><span data-stu-id="296be-157">In this situation, throttle the client for a certain period of time.</span></span> <span data-ttu-id="296be-158">请参阅[限制模式][throttle]。</span><span class="sxs-lookup"><span data-stu-id="296be-158">See the [Throttling pattern][throttle].</span></span>

<span data-ttu-id="296be-159">**阻止错误执行组件**。</span><span class="sxs-lookup"><span data-stu-id="296be-159">**Block bad actors**.</span></span> <span data-ttu-id="296be-160">仅仅限制客户端并不意味着客户端的行为是恶意的。</span><span class="sxs-lookup"><span data-stu-id="296be-160">Just because you throttle a client, it doesn't mean client was acting maliciously.</span></span> <span data-ttu-id="296be-161">它只意味着客户端超出其服务配额。</span><span class="sxs-lookup"><span data-stu-id="296be-161">It just means the client exceeded their service quota.</span></span> <span data-ttu-id="296be-162">但如果客户端持续超出其配额或在其他方面具有不良行为，则可能需要进行阻止。</span><span class="sxs-lookup"><span data-stu-id="296be-162">But if a client consistently exceeds their quota or otherwise behaves badly, you might block them.</span></span> <span data-ttu-id="296be-163">定义一个带外进程，供用户请求解除阻止。</span><span class="sxs-lookup"><span data-stu-id="296be-163">Define an out-of-band process for user to request getting unblocked.</span></span>

<span data-ttu-id="296be-164">**使用领导选拔**。</span><span class="sxs-lookup"><span data-stu-id="296be-164">**Use leader election**.</span></span> <span data-ttu-id="296be-165">当需要协调任务时，请使用[领导选拔][leader-election]选择协调器。</span><span class="sxs-lookup"><span data-stu-id="296be-165">When you need to coordinate a task, use [Leader Election][leader-election] to select a coordinator.</span></span> <span data-ttu-id="296be-166">这样，协调器不是单一故障点。</span><span class="sxs-lookup"><span data-stu-id="296be-166">That way, the coordinator is not a single point of failure.</span></span> <span data-ttu-id="296be-167">如果协调器失败，则选择一个新的协调器。</span><span class="sxs-lookup"><span data-stu-id="296be-167">If the coordinator fails, a new one is selected.</span></span> <span data-ttu-id="296be-168">与其从头开始实施领导选举算法，不如考虑现成的解决方案，比如 Zookeeper。</span><span class="sxs-lookup"><span data-stu-id="296be-168">Rather than implement a leader election algorithm from scratch, consider an off-the-shelf solution such as Zookeeper.</span></span>

<span data-ttu-id="296be-169">**使用故障注入进行测试**。</span><span class="sxs-lookup"><span data-stu-id="296be-169">**Test with fault injection**.</span></span> <span data-ttu-id="296be-170">通常，成功的路径会得到精心的测试，而失败的路径却不会。</span><span class="sxs-lookup"><span data-stu-id="296be-170">All too often, the success path is well tested but not the failure path.</span></span> <span data-ttu-id="296be-171">系统在生产中长时间运行后，才会执行失败路径。</span><span class="sxs-lookup"><span data-stu-id="296be-171">A system could run in production for a long time before a failure path is exercised.</span></span> <span data-ttu-id="296be-172">通过触发实际故障或模拟故障，使用故障注入来测试系统对故障的复原能力。</span><span class="sxs-lookup"><span data-stu-id="296be-172">Use fault injection to test the resiliency of the system to failures, either by triggering actual failures or by simulating them.</span></span>

<span data-ttu-id="296be-173">**采用混沌工程**。</span><span class="sxs-lookup"><span data-stu-id="296be-173">**Embrace chaos engineering**.</span></span> <span data-ttu-id="296be-174">混沌工程通过将故障或异常情况随机注入到生产实例中，扩展了故障注入的概念。</span><span class="sxs-lookup"><span data-stu-id="296be-174">Chaos engineering extends the notion of fault injection, by randomly injecting failures or abnormal conditions into production instances.</span></span>

<span data-ttu-id="296be-175">关于使应用程序自我修复的结构化方法，请参阅[设计适用于 Azure 的可复原应用程序][resiliency-overview]。</span><span class="sxs-lookup"><span data-stu-id="296be-175">For a structured approach to making your applications self healing, see [Design resilient applications for Azure][resiliency-overview].</span></span>

<!-- links -->

[circuit-breaker]: ../../patterns/circuit-breaker.md
[compensating-transactions]: ../../patterns/compensating-transaction.md
[leader-election]: ../../patterns/leader-election.md
[load-level]: ../../patterns/queue-based-load-leveling.md
[resiliency-overview]: ../../resiliency/index.md
[retry]: ../../patterns/retry.md
[throttle]: ../../patterns/throttling.md
[transient-fault-handling]: ../../best-practices/transient-faults.md
