---
title: 最大程度减少协调
titleSuffix: Azure Application Architecture Guide
description: 最大程度地减少应用程序服务之间的协调以实现可伸缩性。
author: MikeWasson
ms.date: 08/30/2018
ms.custom: seojan19
ms.openlocfilehash: ec1a7a3de2be4954b07a87b774f8ae7c2bd1f736
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/08/2019
ms.locfileid: "54113087"
---
# <a name="minimize-coordination"></a><span data-ttu-id="4a32c-103">最大程度减少协调</span><span class="sxs-lookup"><span data-stu-id="4a32c-103">Minimize coordination</span></span>

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="4a32c-104">最大程度减少应用程序服务之间的协调以获得可伸缩性</span><span class="sxs-lookup"><span data-stu-id="4a32c-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="4a32c-105">大多数云应用程序包含多个应用程序服务 &mdash; web 前端、数据库、业务流程、报告和分析等。</span><span class="sxs-lookup"><span data-stu-id="4a32c-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="4a32c-106">若要实现可伸缩性和可靠性，其中每一个服务都应在多个实例上运行。</span><span class="sxs-lookup"><span data-stu-id="4a32c-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span>

<span data-ttu-id="4a32c-107">当两个实例尝试执行影响某种共享状态的并发操作时会发生什么？</span><span class="sxs-lookup"><span data-stu-id="4a32c-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="4a32c-108">在某些情况下，须跨节点进行协调，例如保留 ACID 保证。</span><span class="sxs-lookup"><span data-stu-id="4a32c-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="4a32c-109">此图中，`Node2` 正在等待 `Node1` 释放数据库锁定：</span><span class="sxs-lookup"><span data-stu-id="4a32c-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![数据库锁定图](./images/database-lock.svg)

<span data-ttu-id="4a32c-111">协调限制了水平缩放的优点，且会形成瓶颈。</span><span class="sxs-lookup"><span data-stu-id="4a32c-111">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="4a32c-112">在此示例中，当横向扩展应用程序并添加更多实例时，锁定争用会增加。</span><span class="sxs-lookup"><span data-stu-id="4a32c-112">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="4a32c-113">而最糟的情况是前端实例将花费大部分时间等待锁定。</span><span class="sxs-lookup"><span data-stu-id="4a32c-113">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="4a32c-114">“仅一次”语义是发生协调的另一个常见原因。</span><span class="sxs-lookup"><span data-stu-id="4a32c-114">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="4a32c-115">例如，一个顺序必须仅处理一次。</span><span class="sxs-lookup"><span data-stu-id="4a32c-115">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="4a32c-116">两个辅助角色正在侦听新顺序。</span><span class="sxs-lookup"><span data-stu-id="4a32c-116">Two workers are listening for new orders.</span></span> <span data-ttu-id="4a32c-117">`Worker1` 选取一个顺序进行处理。</span><span class="sxs-lookup"><span data-stu-id="4a32c-117">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="4a32c-118">应用程序须确保 `Worker2` 不会重复工作，并且如果 `Worker1` 崩溃，不会删除顺序。</span><span class="sxs-lookup"><span data-stu-id="4a32c-118">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![协调关系图](./images/coordination.svg)

<span data-ttu-id="4a32c-120">可使用[计划程序代理监督程序][sas-pattern]等模式在辅助角色之间进行协调，但在这种情况下，采用对工作进行分区的方法可能更好。</span><span class="sxs-lookup"><span data-stu-id="4a32c-120">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="4a32c-121">每个辅助角色都分配有某范围的顺序（比如按照计费区域）。</span><span class="sxs-lookup"><span data-stu-id="4a32c-121">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="4a32c-122">如果某辅助角色故障，新的实例会在前一个实例停止的位置启用，但不会出现多个实例争用的情况。</span><span class="sxs-lookup"><span data-stu-id="4a32c-122">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="4a32c-123">建议</span><span class="sxs-lookup"><span data-stu-id="4a32c-123">Recommendations</span></span>

<span data-ttu-id="4a32c-124">**实现最终一致性**。</span><span class="sxs-lookup"><span data-stu-id="4a32c-124">**Embrace eventual consistency**.</span></span> <span data-ttu-id="4a32c-125">分布数据时，需要协调来强制执行可靠的一致性保证。</span><span class="sxs-lookup"><span data-stu-id="4a32c-125">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="4a32c-126">例如，假设通过一项操作更新两个数据库。</span><span class="sxs-lookup"><span data-stu-id="4a32c-126">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="4a32c-127">最好系统能调节最终一致性（方法是在发生故障后，使用[补偿事务][compensating-transaction]模式进行逻辑回滚），而不是将其置于单个事务范围。</span><span class="sxs-lookup"><span data-stu-id="4a32c-127">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="4a32c-128">**使用域事件同步状态**。</span><span class="sxs-lookup"><span data-stu-id="4a32c-128">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="4a32c-129">[域事件][domain-event]是一种事件，可记录域中发生的重要事情。</span><span class="sxs-lookup"><span data-stu-id="4a32c-129">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="4a32c-130">关注的服务会侦听事件，而不是使用全局事务来协调多个服务。</span><span class="sxs-lookup"><span data-stu-id="4a32c-130">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="4a32c-131">如果使用此方法，系统必须允许最终一致性（请参阅上一项）。</span><span class="sxs-lookup"><span data-stu-id="4a32c-131">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span>

<span data-ttu-id="4a32c-132">请考虑使用 CQRS 和事件源等模式。</span><span class="sxs-lookup"><span data-stu-id="4a32c-132">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="4a32c-133">这两种模式有助于减少读取工作负载和写入工作负载之间的争用。</span><span class="sxs-lookup"><span data-stu-id="4a32c-133">These two patterns can help to reduce contention between read workloads and write workloads.</span></span>

- <span data-ttu-id="4a32c-134">[CQRS 模式][cqrs-pattern]将读取操作从写入操作中分离。</span><span class="sxs-lookup"><span data-stu-id="4a32c-134">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="4a32c-135">在某些实现中，读取数据通过物理方式从写入数据中分离。</span><span class="sxs-lookup"><span data-stu-id="4a32c-135">In some implementations, the read data is physically separated from the write data.</span></span>

- <span data-ttu-id="4a32c-136">在[事件源模式][event-sourcing]中，状态更改作为一系列事件被记录到仅追加数据存储中。</span><span class="sxs-lookup"><span data-stu-id="4a32c-136">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="4a32c-137">将事件追加到流是一种原子操作，需要最小锁定。</span><span class="sxs-lookup"><span data-stu-id="4a32c-137">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span>

<span data-ttu-id="4a32c-138">这两种模式互为补充。</span><span class="sxs-lookup"><span data-stu-id="4a32c-138">These two patterns complement each other.</span></span> <span data-ttu-id="4a32c-139">如果 CQRS 中的只写存储使用事件源，则只读存储可以侦听相同的事件，以创建当前状态的可读快照（已针对查询进行优化）。</span><span class="sxs-lookup"><span data-stu-id="4a32c-139">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="4a32c-140">但是，在采用 CQRS 或事件源之前，请先了解此方法的难题。</span><span class="sxs-lookup"><span data-stu-id="4a32c-140">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="4a32c-141">有关详细信息，请参阅 [CQRS 体系结构样式][cqrs-style]。</span><span class="sxs-lookup"><span data-stu-id="4a32c-141">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="4a32c-142">**将数据分区**。</span><span class="sxs-lookup"><span data-stu-id="4a32c-142">**Partition data**.</span></span>  <span data-ttu-id="4a32c-143">避免将所有数据放入一个由多个应用程序服务共享的数据架构中。</span><span class="sxs-lookup"><span data-stu-id="4a32c-143">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="4a32c-144">微服务体系结构通过使每个服务对自己的数据存储负责来强制执行这一原则。</span><span class="sxs-lookup"><span data-stu-id="4a32c-144">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="4a32c-145">在单个数据库中，将数据分区到不同分片可以提高并发性，因为写入到一个分片的服务不会影响写入其他分片的服务。</span><span class="sxs-lookup"><span data-stu-id="4a32c-145">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="4a32c-146">设计幂等操作。</span><span class="sxs-lookup"><span data-stu-id="4a32c-146">**Design idempotent operations**.</span></span> <span data-ttu-id="4a32c-147">如果可能，请将操作设计为幂等操作。</span><span class="sxs-lookup"><span data-stu-id="4a32c-147">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="4a32c-148">这样一来，可使用“至少一次”语义处理这些操作。</span><span class="sxs-lookup"><span data-stu-id="4a32c-148">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="4a32c-149">例如，可将工作项放入队列。</span><span class="sxs-lookup"><span data-stu-id="4a32c-149">For example, you can put work items on a queue.</span></span> <span data-ttu-id="4a32c-150">如果某辅助角色在操作期间故障，另一个辅助角色会选取此工作项。</span><span class="sxs-lookup"><span data-stu-id="4a32c-150">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="4a32c-151">使用异步并行处理。</span><span class="sxs-lookup"><span data-stu-id="4a32c-151">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="4a32c-152">如果某项操作需要多个异步执行的步骤（例如远程服务调用），可并行调用，然后聚合结果。</span><span class="sxs-lookup"><span data-stu-id="4a32c-152">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="4a32c-153">此方法假定每个步骤不依赖上一步的结果。</span><span class="sxs-lookup"><span data-stu-id="4a32c-153">This approach assumes that each step does not depend on the results of the previous step.</span></span>

<span data-ttu-id="4a32c-154">如果可能，请使用乐观并发。</span><span class="sxs-lookup"><span data-stu-id="4a32c-154">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="4a32c-155">悲观并发控件使用数据库锁定来防止冲突。</span><span class="sxs-lookup"><span data-stu-id="4a32c-155">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="4a32c-156">这可能会导致性能不佳，可用性降低。</span><span class="sxs-lookup"><span data-stu-id="4a32c-156">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="4a32c-157">对于乐观并发控件，每个事务修改数据的副本或快照。</span><span class="sxs-lookup"><span data-stu-id="4a32c-157">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="4a32c-158">提交事务时，数据库引擎会验证事务并拒绝会影响数据库一致性的任何事务。</span><span class="sxs-lookup"><span data-stu-id="4a32c-158">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span>

<span data-ttu-id="4a32c-159">通过[快照隔离][sql-snapshot-isolation]，Azure SQL 数据库和 SQL Server 支持乐观并发。</span><span class="sxs-lookup"><span data-stu-id="4a32c-159">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="4a32c-160">通过使用 [Azure Cosmos DB][cosmosdb-faq] 和 [Azure 存储][storage-concurrency]等 Etag，一些 Azure 存储服务支持乐观并发。</span><span class="sxs-lookup"><span data-stu-id="4a32c-160">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="4a32c-161">请考虑使用 MapReduce、其他并行或分布式算法。</span><span class="sxs-lookup"><span data-stu-id="4a32c-161">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="4a32c-162">根据要执行的工作的数据和类型，可将工作拆分为独立的任务，这些任务可以由并行工作的多个节点执行。</span><span class="sxs-lookup"><span data-stu-id="4a32c-162">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="4a32c-163">请参阅[大计算的体系结构样式][big-compute]。</span><span class="sxs-lookup"><span data-stu-id="4a32c-163">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="4a32c-164">使用领导选择进行协调。</span><span class="sxs-lookup"><span data-stu-id="4a32c-164">**Use leader election for coordination**.</span></span> <span data-ttu-id="4a32c-165">如果需要协调操作，请确保协调器不会成为应用程序中的单一故障点。</span><span class="sxs-lookup"><span data-stu-id="4a32c-165">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="4a32c-166">使用[领导选择模式][leader-election]，一个实例始终是领导并充当协调器。</span><span class="sxs-lookup"><span data-stu-id="4a32c-166">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="4a32c-167">如果该领导失败，会选择新的实例作为领导。</span><span class="sxs-lookup"><span data-stu-id="4a32c-167">If the leader fails, a new instance is elected to be the leader.</span></span>

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/