---
title: 变化型设计
titleSuffix: Azure Application Architecture Guide
description: 进化型设计是持续创新的关键。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 4a1ed92f70660f16c07b4b472c3ef358af4319c9
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54481739"
---
# <a name="design-for-evolution"></a><span data-ttu-id="e9549-103">进化型设计</span><span class="sxs-lookup"><span data-stu-id="e9549-103">Design for evolution</span></span>

## <a name="an-evolutionary-design-is-key-for-continuous-innovation"></a><span data-ttu-id="e9549-104">进化型设计是持续创新的关键</span><span class="sxs-lookup"><span data-stu-id="e9549-104">An evolutionary design is key for continuous innovation</span></span>

<span data-ttu-id="e9549-105">无论是修复 bug、添加新功能、引入新技术，还是使现有系统更具伸缩性和弹性，所有成功的应用程序都在随着时间而不断变化。</span><span class="sxs-lookup"><span data-stu-id="e9549-105">All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient.</span></span> <span data-ttu-id="e9549-106">如果应用程序的所有部分都紧密耦合，则很难将更改引入系统。</span><span class="sxs-lookup"><span data-stu-id="e9549-106">If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system.</span></span> <span data-ttu-id="e9549-107">应用程序中一个部分的更改可能会破坏另一部分，或者改变整个代码库。</span><span class="sxs-lookup"><span data-stu-id="e9549-107">A change in one part of the application may break another part, or cause changes to ripple through the entire codebase.</span></span>

<span data-ttu-id="e9549-108">这个问题并不局限于单片应用程序。</span><span class="sxs-lookup"><span data-stu-id="e9549-108">This problem is not limited to monolithic applications.</span></span> <span data-ttu-id="e9549-109">应用程序可分解为服务，但仍会表现出那种紧密耦合性，使系统变得刚性和脆弱。</span><span class="sxs-lookup"><span data-stu-id="e9549-109">An application can be decomposed into services, but still exhibit the sort of tight coupling that leaves the system rigid and brittle.</span></span> <span data-ttu-id="e9549-110">但当服务设计为可以改进时，团队可以创新并不断提供新功能。</span><span class="sxs-lookup"><span data-stu-id="e9549-110">But when services are designed to evolve, teams can innovate and continuously deliver new features.</span></span>

<span data-ttu-id="e9549-111">微服务正在成为实现进化设计的一种热门方式，因为它们可以解决此处列出的许多值得注意的问题。</span><span class="sxs-lookup"><span data-stu-id="e9549-111">Microservices are becoming a popular way to achieve an evolutionary design, because they address many of the considerations listed here.</span></span>

## <a name="recommendations"></a><span data-ttu-id="e9549-112">建议</span><span class="sxs-lookup"><span data-stu-id="e9549-112">Recommendations</span></span>

<span data-ttu-id="e9549-113">**强制执行高度内聚和松散耦合**。</span><span class="sxs-lookup"><span data-stu-id="e9549-113">**Enforce high cohesion and loose coupling**.</span></span> <span data-ttu-id="e9549-114">如果服务提供逻辑上具有共同所属的功能，则该服务具有内聚性。</span><span class="sxs-lookup"><span data-stu-id="e9549-114">A service is *cohesive* if it provides functionality that logically belongs together.</span></span> <span data-ttu-id="e9549-115">如果可以在更改一个服务的同时不会更改另一个服务，则服务具有松散耦合性。</span><span class="sxs-lookup"><span data-stu-id="e9549-115">Services are *loosely coupled* if you can change one service without changing the other.</span></span> <span data-ttu-id="e9549-116">高度内聚通常意味着更改一个函数时还需更改其他相关函数。</span><span class="sxs-lookup"><span data-stu-id="e9549-116">High cohesion generally means that changes in one function will require changes in other related functions.</span></span> <span data-ttu-id="e9549-117">如果发现更新某个服务时需要对其他服务进行协调更新，则可能表示该服务不具有内聚性。</span><span class="sxs-lookup"><span data-stu-id="e9549-117">If you find that updating a service requires coordinated updates to other services, it may be a sign that your services are not cohesive.</span></span> <span data-ttu-id="e9549-118">域驱动设计 (DDD) 的目标之一就是标识这些边界。</span><span class="sxs-lookup"><span data-stu-id="e9549-118">One of the goals of domain-driven design (DDD) is to identify those boundaries.</span></span>

<span data-ttu-id="e9549-119">**封装域知识**。</span><span class="sxs-lookup"><span data-stu-id="e9549-119">**Encapsulate domain knowledge**.</span></span> <span data-ttu-id="e9549-120">客户端使用服务时，强制执行域的业务规则的责任不应落在客户端上。</span><span class="sxs-lookup"><span data-stu-id="e9549-120">When a client consumes a service, the responsibility for enforcing the business rules of the domain should not fall on the client.</span></span> <span data-ttu-id="e9549-121">相反，服务应封装属于其责任范围内的所有域知识。</span><span class="sxs-lookup"><span data-stu-id="e9549-121">Instead, the service should encapsulate all of the domain knowledge that falls under its responsibility.</span></span> <span data-ttu-id="e9549-122">否则，每个客户端都必须强制执行业务规则，最终域知识会分散在应用程序的不同部分。</span><span class="sxs-lookup"><span data-stu-id="e9549-122">Otherwise, every client has to enforce the business rules, and you end up with domain knowledge spread across different parts of the application.</span></span>

<span data-ttu-id="e9549-123">**使用异步消息传递**。</span><span class="sxs-lookup"><span data-stu-id="e9549-123">**Use asynchronous messaging**.</span></span> <span data-ttu-id="e9549-124">异步消息传递是一种将消息创建者与使用者分离的方法。</span><span class="sxs-lookup"><span data-stu-id="e9549-124">Asynchronous messaging is a way to decouple the message producer from the consumer.</span></span> <span data-ttu-id="e9549-125">创建者不依赖于使用者回复消息或采取任何特定操作。</span><span class="sxs-lookup"><span data-stu-id="e9549-125">The producer does not depend on the consumer responding to the message or taking any particular action.</span></span> <span data-ttu-id="e9549-126">有了 pub/sub 体系结构，创建者甚至可能不知道谁在使用消息。</span><span class="sxs-lookup"><span data-stu-id="e9549-126">With a pub/sub architecture, the producer may not even know who is consuming the message.</span></span> <span data-ttu-id="e9549-127">新服务可以轻松地使用消息，而不需要对创建者进行任何修改。</span><span class="sxs-lookup"><span data-stu-id="e9549-127">New services can easily consume the messages without any modifications to the producer.</span></span>

<span data-ttu-id="e9549-128">**不要将域知识构建到网关中**。</span><span class="sxs-lookup"><span data-stu-id="e9549-128">**Don't build domain knowledge into a gateway**.</span></span> <span data-ttu-id="e9549-129">在微服务体系结构中，网关对于请求路由、协议转换、负载均衡或身份验证等操作非常有用。</span><span class="sxs-lookup"><span data-stu-id="e9549-129">Gateways can be useful in a microservices architecture, for things like request routing, protocol translation, load balancing, or authentication.</span></span> <span data-ttu-id="e9549-130">但网关应该仅限于这种基础结构功能。</span><span class="sxs-lookup"><span data-stu-id="e9549-130">However, the gateway should be restricted to this sort of infrastructure functionality.</span></span> <span data-ttu-id="e9549-131">它不应实施任何域知识，以避免成为严重的依赖项。</span><span class="sxs-lookup"><span data-stu-id="e9549-131">It should not implement any domain knowledge, to avoid becoming a heavy dependency.</span></span>

<span data-ttu-id="e9549-132">**公开开放接口**。</span><span class="sxs-lookup"><span data-stu-id="e9549-132">**Expose open interfaces**.</span></span> <span data-ttu-id="e9549-133">避免在服务之间创建自定义转换层。</span><span class="sxs-lookup"><span data-stu-id="e9549-133">Avoid creating custom translation layers that sit between services.</span></span> <span data-ttu-id="e9549-134">相反，服务应该公开具有明确定义的 API 协定的 API。</span><span class="sxs-lookup"><span data-stu-id="e9549-134">Instead, a service should expose an API with a well-defined API contract.</span></span> <span data-ttu-id="e9549-135">API 应拥有版本控制，以便在保持向后兼容性的同时改进 API。</span><span class="sxs-lookup"><span data-stu-id="e9549-135">The API should be versioned, so that you can evolve the API while maintaining backward compatibility.</span></span> <span data-ttu-id="e9549-136">这样就可以更新服务，而无需对依赖它的所有上游服务进行协调更新。</span><span class="sxs-lookup"><span data-stu-id="e9549-136">That way, you can update a service without coordinating updates to all of the upstream services that depend on it.</span></span> <span data-ttu-id="e9549-137">面向公众的服务应通过 HTTP 公开一个 RESTful API。</span><span class="sxs-lookup"><span data-stu-id="e9549-137">Public facing services should expose a RESTful API over HTTP.</span></span> <span data-ttu-id="e9549-138">因性能原因，后端服务可能会使用 RPC 样式的消息传递协议。</span><span class="sxs-lookup"><span data-stu-id="e9549-138">Backend services might use an RPC-style messaging protocol for performance reasons.</span></span>

<span data-ttu-id="e9549-139">**针对服务协定进行设计和测试**。</span><span class="sxs-lookup"><span data-stu-id="e9549-139">**Design and test against service contracts**.</span></span> <span data-ttu-id="e9549-140">在服务公开了明确定义的 API 后，可以针对这些 API 进行开发和测试。</span><span class="sxs-lookup"><span data-stu-id="e9549-140">When services expose well-defined APIs, you can develop and test against those APIs.</span></span> <span data-ttu-id="e9549-141">这样可以开发和测试单个服务，而无需启动所有的依赖服务。</span><span class="sxs-lookup"><span data-stu-id="e9549-141">That way, you can develop and test an individual service without spinning up all of its dependent services.</span></span> <span data-ttu-id="e9549-142">（当然，仍然可以针对实际服务执行集成和负载测试。）</span><span class="sxs-lookup"><span data-stu-id="e9549-142">(Of course, you would still perform integration and load testing against the real services.)</span></span>

<span data-ttu-id="e9549-143">**分清基础结构与域逻辑**。</span><span class="sxs-lookup"><span data-stu-id="e9549-143">**Abstract infrastructure away from domain logic**.</span></span> <span data-ttu-id="e9549-144">不要将域逻辑与基础结构相关的功能（如消息传递或暂留）混在一起。</span><span class="sxs-lookup"><span data-stu-id="e9549-144">Don't let domain logic get mixed up with infrastructure-related functionality, such as messaging or persistence.</span></span> <span data-ttu-id="e9549-145">否则，更改域逻辑时需要对基础结构层进行更新，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="e9549-145">Otherwise, changes in the domain logic will require updates to the infrastructure layers and vice versa.</span></span>

<span data-ttu-id="e9549-146">**将跨领域问题转移到单独服务上**。</span><span class="sxs-lookup"><span data-stu-id="e9549-146">**Offload cross-cutting concerns to a separate service**.</span></span> <span data-ttu-id="e9549-147">例如，如果多个服务需要对请求进行身份验证，可将此功能移到各自的服务中。</span><span class="sxs-lookup"><span data-stu-id="e9549-147">For example, if several services need to authenticate requests, you could move this functionality into its own service.</span></span> <span data-ttu-id="e9549-148">然后便可改进身份验证服务（例如，通过添加新的身份验证流），而无需涉及使用它的任何服务。</span><span class="sxs-lookup"><span data-stu-id="e9549-148">Then you could evolve the authentication service &mdash; for example, by adding a new authentication flow &mdash; without touching any of the services that use it.</span></span>

<span data-ttu-id="e9549-149">**独立部署服务**。</span><span class="sxs-lookup"><span data-stu-id="e9549-149">**Deploy services independently**.</span></span> <span data-ttu-id="e9549-150">DevOps 团队可以独立地为应用程序中的其他服务部署单个服务时，更新就会更快，更安全。</span><span class="sxs-lookup"><span data-stu-id="e9549-150">When the DevOps team can deploy a single service independently of other services in the application, updates can happen more quickly and safely.</span></span> <span data-ttu-id="e9549-151">Bug 修复和新功能便能按更常规的节奏推出。</span><span class="sxs-lookup"><span data-stu-id="e9549-151">Bug fixes and new features can be rolled out at a more regular cadence.</span></span> <span data-ttu-id="e9549-152">同时设计应用程序和发布过程以支持独立更新。</span><span class="sxs-lookup"><span data-stu-id="e9549-152">Design both the application and the release process to support independent updates.</span></span>
