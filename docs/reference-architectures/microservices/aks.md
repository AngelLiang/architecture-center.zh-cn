---
title: Azure Kubernetes 服务 (AKS) 中的微服务体系结构
description: 在 Azure Kubernetes 服务 (AKS) 中部署微服务体系结构
author: MikeWasson
ms.date: 12/10/2018
ms.topic: reference-architecture
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: f3b637d61c929e5523ea5409426f3d7a72096dfa
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/23/2019
ms.locfileid: "54484119"
---
# <a name="microservices-architecture-on-azure-kubernetes-service-aks"></a><span data-ttu-id="970a8-103">Azure Kubernetes 服务 (AKS) 中的微服务体系结构</span><span class="sxs-lookup"><span data-stu-id="970a8-103">Microservices architecture on Azure Kubernetes Service (AKS)</span></span>

<span data-ttu-id="970a8-104">本参考体系结构演示一个部署到 Azure Kubernetes 服务 (AKS) 中的微服务应用程序。</span><span class="sxs-lookup"><span data-stu-id="970a8-104">This reference architectures shows a microservices application deployed to Azure Kubernetes Service (AKS).</span></span> <span data-ttu-id="970a8-105">其中演示的基本 AKS 配置可用作大多数部署的起点。</span><span class="sxs-lookup"><span data-stu-id="970a8-105">It shows a basic AKS configuration that can be the starting point for most deployments.</span></span> <span data-ttu-id="970a8-106">更高级的选项（包括高级网络选项）将在单独的参考体系结构中予以介绍。</span><span class="sxs-lookup"><span data-stu-id="970a8-106">More advanced options, including advanced networking options, will be covered in a separate reference architecture.</span></span>

<span data-ttu-id="970a8-107">本文假设读者基本了解 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="970a8-107">This article assumes basic knowledge of Kubernetes.</span></span> <span data-ttu-id="970a8-108">本文侧重于有关在 AKS 中运行微服务体系结构的基础结构和 DevOps 注意事项。</span><span class="sxs-lookup"><span data-stu-id="970a8-108">The article focuses mainly on the infrastructure and DevOps considerations of running a microservices architecture on AKS.</span></span> <span data-ttu-id="970a8-109">有关如何从域驱动设计 (DDD) 立场设计微服务的指导，请参阅[在 Azure 中设计、构建和操作微服务](/azure/architecture/microservices)。</span><span class="sxs-lookup"><span data-stu-id="970a8-109">For guidance on how to design microservices from a Domain Driven Design (DDD) perspective, see [Designing, building, and operating microservices on Azure](/azure/architecture/microservices).</span></span>

> [!NOTE]
> <span data-ttu-id="970a8-110">我们目前正在制作本文随附的参考实现 (RI)，预计在 2019 年初期发布。</span><span class="sxs-lookup"><span data-stu-id="970a8-110">We are working on a reference implementation (RI) to accompany this article, which we expect to publish in early 2019.</span></span> <span data-ttu-id="970a8-111">到时本文将会更新，以纳入该 RI 中的其他最佳做法。</span><span class="sxs-lookup"><span data-stu-id="970a8-111">This article will be updated to incorporate additional best practices from that RI.</span></span>

![AKS 参考体系结构](./_images/aks.png)

## <a name="architecture"></a><span data-ttu-id="970a8-113">体系结构</span><span class="sxs-lookup"><span data-stu-id="970a8-113">Architecture</span></span>

<span data-ttu-id="970a8-114">该体系结构包括以下组件。</span><span class="sxs-lookup"><span data-stu-id="970a8-114">The architecture consists of the following components.</span></span>

<span data-ttu-id="970a8-115">**Azure Kubernetes 服务** (AKS)。</span><span class="sxs-lookup"><span data-stu-id="970a8-115">**Azure Kubernetes Service** (AKS).</span></span> <span data-ttu-id="970a8-116">AKS 是可以部署 Kubernetes 托管群集的 Azure 服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-116">AKS is an Azure service that deploys a managed Kubernetes cluster.</span></span> 

<span data-ttu-id="970a8-117">**Kubernetes 群集**。</span><span class="sxs-lookup"><span data-stu-id="970a8-117">**Kubernetes cluster**.</span></span> <span data-ttu-id="970a8-118">AKS 负责部署 Kubernetes 群集和管理 Kubernetes 主节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-118">AKS is responsible for deploying the Kubernetes cluster and for managing the Kubernetes masters.</span></span> <span data-ttu-id="970a8-119">你只需管理代理节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-119">You only manage the agent nodes.</span></span>

<span data-ttu-id="970a8-120">虚拟网络。</span><span class="sxs-lookup"><span data-stu-id="970a8-120">**Virtual network**.</span></span> <span data-ttu-id="970a8-121">默认情况下，AKS 会创建一个要将代理节点部署到的虚拟网络。</span><span class="sxs-lookup"><span data-stu-id="970a8-121">By default, AKS creates a virtual network to deploy the agent nodes into.</span></span> <span data-ttu-id="970a8-122">对于更高级的方案，可以先创建虚拟网络，这样便可以控制子网的配置方式、本地连接和 IP 寻址等设置。</span><span class="sxs-lookup"><span data-stu-id="970a8-122">For more advanced scenarios, you can create the virtual network first, which lets you control things like how the subnets are configured, on-premises connectivity, and IP addressing.</span></span> <span data-ttu-id="970a8-123">有关详细信息，请参阅[在 Azure Kubernetes 服务 (AKS) 中配置高级网络](/azure/aks/configure-advanced-networking)。</span><span class="sxs-lookup"><span data-stu-id="970a8-123">For more information, see [Configure advanced networking in Azure Kubernetes Service (AKS)](/azure/aks/configure-advanced-networking).</span></span>

<span data-ttu-id="970a8-124">**入口**。</span><span class="sxs-lookup"><span data-stu-id="970a8-124">**Ingress**.</span></span> <span data-ttu-id="970a8-125">入口向群集中的服务公开 HTTP(S) 路由。</span><span class="sxs-lookup"><span data-stu-id="970a8-125">An ingress exposes HTTP(S) routes to services inside the cluster.</span></span> <span data-ttu-id="970a8-126">有关详细信息，请参阅下面的 [API 网关](#api-gateway)部分。</span><span class="sxs-lookup"><span data-stu-id="970a8-126">For more information, see the section [API Gateway](#api-gateway) below.</span></span>

<span data-ttu-id="970a8-127">**外部数据存储**。</span><span class="sxs-lookup"><span data-stu-id="970a8-127">**External data stores**.</span></span> <span data-ttu-id="970a8-128">微服务通常是无状态的，会将状态写入 Azure SQL 数据库或 Cosmos DB 等外部数据存储。</span><span class="sxs-lookup"><span data-stu-id="970a8-128">Microservices are typically stateless and write state to external data stores, such as Azure SQL Database or Cosmos DB.</span></span>

<span data-ttu-id="970a8-129">**Azure Active Directory**。</span><span class="sxs-lookup"><span data-stu-id="970a8-129">**Azure Active Directory**.</span></span> <span data-ttu-id="970a8-130">AKS 使用 Azure Active Directory (Azure AD) 标识来创建和管理 Azure 负载均衡器等其他 Azure 资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-130">AKS uses an Azure Active Directory (Azure AD) identity to create and manage other Azure resources such as Azure load balancers.</span></span> <span data-ttu-id="970a8-131">对于客户端应用程序中的用户身份验证，也建议使用 Azure AD。</span><span class="sxs-lookup"><span data-stu-id="970a8-131">Azure AD is also recommended for user authentication in client applications.</span></span>

<span data-ttu-id="970a8-132">**Azure 容器注册表**。</span><span class="sxs-lookup"><span data-stu-id="970a8-132">**Azure Container Registry**.</span></span> <span data-ttu-id="970a8-133">使用容器注册表来存储部署到群集中的专用 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="970a8-133">Use Container Registry to store private Docker images, which are deployed to the cluster.</span></span> <span data-ttu-id="970a8-134">AKS 可以使用 Azure AD 标识在容器注册表中进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-134">AKS can authenticate with Container Registry using its Azure AD identity.</span></span> <span data-ttu-id="970a8-135">请注意，AKS 不需要 Azure 容器注册表。</span><span class="sxs-lookup"><span data-stu-id="970a8-135">Note that AKS does not require Azure Container Registry.</span></span> <span data-ttu-id="970a8-136">可以使用其他容器注册表，例如 Docker 中心。</span><span class="sxs-lookup"><span data-stu-id="970a8-136">You can use other container registries, such as Docker Hub.</span></span>

<span data-ttu-id="970a8-137">**Azure Pipelines**。</span><span class="sxs-lookup"><span data-stu-id="970a8-137">**Azure Pipelines**.</span></span> <span data-ttu-id="970a8-138">管道是 Azure DevOps 服务的一部分，可运行自动化的生成、测试和部署。</span><span class="sxs-lookup"><span data-stu-id="970a8-138">Pipelines is part of Azure DevOps Services and runs automated builds, tests, and deployments.</span></span> <span data-ttu-id="970a8-139">也可以使用 Jenkins 等第三方 CI/CD 解决方案。</span><span class="sxs-lookup"><span data-stu-id="970a8-139">You can also use third-party CI/CD solutions such as Jenkins.</span></span> 

<span data-ttu-id="970a8-140">**Helm**。</span><span class="sxs-lookup"><span data-stu-id="970a8-140">**Helm**.</span></span> <span data-ttu-id="970a8-141">Helm 是 Kubernetes 的包管理器 &mdash; 使用它可将 Kubernetes 对象捆绑为单个可以发布、部署、进行版本控制和更新的单元。</span><span class="sxs-lookup"><span data-stu-id="970a8-141">Helm is as a package manager for Kubernetes &mdash; a way to bundle Kubernetes objects into a single unit that you can publish, deploy, version, and update.</span></span>

<span data-ttu-id="970a8-142">**Azure Monitor**。</span><span class="sxs-lookup"><span data-stu-id="970a8-142">**Azure Monitor**.</span></span> <span data-ttu-id="970a8-143">Azure Monitor 收集并存储指标和日志，包括解决方案中 Azure 服务的平台指标，以及应用程序遥测数据。</span><span class="sxs-lookup"><span data-stu-id="970a8-143">Azure Monitor collects and stores metrics and logs, including platform metrics for the Azure services in the solution and application telemetry.</span></span> <span data-ttu-id="970a8-144">使用此数据可以监视应用程序、设置警报和仪表板，以及针对故障执行根本原因分析。</span><span class="sxs-lookup"><span data-stu-id="970a8-144">Use this data to monitor the application, set up alerts and dashboards, and perform root cause analysis of failures.</span></span> <span data-ttu-id="970a8-145">Azure Monitor 与 AKS 相集成，可以从控制器、节点和容器收集指标，并可以收集容器日志和主节点日志。</span><span class="sxs-lookup"><span data-stu-id="970a8-145">Azure Monitor integrates with AKS to collect metrics from controllers, nodes, and containers, as well as container logs and master node logs.</span></span>

## <a name="design-considerations"></a><span data-ttu-id="970a8-146">设计注意事项</span><span class="sxs-lookup"><span data-stu-id="970a8-146">Design considerations</span></span>

<span data-ttu-id="970a8-147">本参考体系结构侧重于微服务体系结构，不过，许多建议的做法同样适用于 AKS 上运行的其他工作负荷。</span><span class="sxs-lookup"><span data-stu-id="970a8-147">This reference architecture is focused on microservices architectures, although many of the recommended practices will apply to other workloads running on AKS.</span></span>

### <a name="microservices"></a><span data-ttu-id="970a8-148">微服务</span><span class="sxs-lookup"><span data-stu-id="970a8-148">Microservices</span></span>

<span data-ttu-id="970a8-149">Kubernetes 服务对象是为 Kubernetes 中的微服务建模的自然方式。</span><span class="sxs-lookup"><span data-stu-id="970a8-149">The Kubernetes Service object is a natural way to model microservices in Kubernetes.</span></span> <span data-ttu-id="970a8-150">微服务是松散耦合的、可独立部署的代码单元。</span><span class="sxs-lookup"><span data-stu-id="970a8-150">A microservice is a loosely coupled, independently deployable unit of code.</span></span> <span data-ttu-id="970a8-151">微服务通常通过妥善定义的 API 进行通信，可以通过某种形式的服务发现来发现它们。</span><span class="sxs-lookup"><span data-stu-id="970a8-151">Microservices typically communicate through well-defined APIs, and are discoverable through some form of service discovery.</span></span> <span data-ttu-id="970a8-152">Kubernetes 服务对象提供一组符合以下要求的功能：</span><span class="sxs-lookup"><span data-stu-id="970a8-152">The Kubernetes Service object provides a set of capabilities that match these requirements:</span></span>

- <span data-ttu-id="970a8-153">IP 地址。</span><span class="sxs-lookup"><span data-stu-id="970a8-153">IP address.</span></span> <span data-ttu-id="970a8-154">服务对象为一组 pod（副本集）提供静态内部 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="970a8-154">The Service object provides a static internal IP address for a group of pods (ReplicaSet).</span></span> <span data-ttu-id="970a8-155">创建或移动 pod 时，始终可以通过此内部 IP 地址访问服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-155">As pods are created or moved around, the service is always reachable at this internal IP address.</span></span>

- <span data-ttu-id="970a8-156">负载均衡。</span><span class="sxs-lookup"><span data-stu-id="970a8-156">Load balancing.</span></span> <span data-ttu-id="970a8-157">发送到服务 IP 地址的流量在 pod 中进行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="970a8-157">Traffic sent to the service's IP address is load balanced to the pods.</span></span> 

- <span data-ttu-id="970a8-158">服务发现。</span><span class="sxs-lookup"><span data-stu-id="970a8-158">Service discovery.</span></span> <span data-ttu-id="970a8-159">Kubernetes DNS 服务为服务分配内部 DNS 条目。</span><span class="sxs-lookup"><span data-stu-id="970a8-159">Services are assigned internal DNS entries by the Kubernetes DNS service.</span></span> <span data-ttu-id="970a8-160">这意味着，API 网关可以使用 DNS 名称调用后端服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-160">That means the API gateway can call a backend service using the DNS name.</span></span> <span data-ttu-id="970a8-161">可以使用相同的机制进行服务间的通信。</span><span class="sxs-lookup"><span data-stu-id="970a8-161">The same mechanism can be used for service-to-service communication.</span></span> <span data-ttu-id="970a8-162">DNS 条目按命名空间进行组织，因此，如果命名空间对应于边界上下文，则服务的 DNS 名称将以自然方式映射到应用程序域。</span><span class="sxs-lookup"><span data-stu-id="970a8-162">The DNS entries are organized by namespace, so if your namespaces correspond to bounded contexts, then the DNS name for a service will map naturally to the application domain.</span></span>

<span data-ttu-id="970a8-163">下图演示了服务与 pod 之间的概念关系。</span><span class="sxs-lookup"><span data-stu-id="970a8-163">The following diagram show the conceptual relation between services and pods.</span></span> <span data-ttu-id="970a8-164">到终结点 IP 地址和端口的实际映射由 Kubernetes 网络代理 kube-proxy 执行。</span><span class="sxs-lookup"><span data-stu-id="970a8-164">The actual mapping to endpoint IP addresses and ports is done by kube-proxy, the Kubernetes network proxy.</span></span>

![服务和 pod](./_images/aks-services.png)

### <a name="api-gateway"></a><span data-ttu-id="970a8-166">API Gateway</span><span class="sxs-lookup"><span data-stu-id="970a8-166">API Gateway</span></span>

<span data-ttu-id="970a8-167">API 网关是位于外部客户端与微服务之间的网关。</span><span class="sxs-lookup"><span data-stu-id="970a8-167">An *API gateway* is a gateway that sits between external clients and the microservices.</span></span> <span data-ttu-id="970a8-168">它充当反向代理，将来自客户端的请求路由到微服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-168">It acts as a reverse proxy, routing requests from clients to microservices.</span></span> <span data-ttu-id="970a8-169">它还可以执行各种横切任务，例如身份验证、SSL 终止和速率限制。</span><span class="sxs-lookup"><span data-stu-id="970a8-169">It may also perform various cross-cutting tasks such as authentication, SSL termination, and rate limiting.</span></span> 

<span data-ttu-id="970a8-170">可按以下方式划分网关提供的功能：</span><span class="sxs-lookup"><span data-stu-id="970a8-170">Functionality provided by a gateway can be grouped as follows:</span></span>

- <span data-ttu-id="970a8-171">[网关路由](../../patterns/gateway-routing.md)：将客户端请求路由到适当的后端服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-171">[Gateway Routing](../../patterns/gateway-routing.md): Routing client requests to the right backend services.</span></span> <span data-ttu-id="970a8-172">这样可为客户端提供单一终结点，帮助将客户端与服务分开。</span><span class="sxs-lookup"><span data-stu-id="970a8-172">This provides a single endpoint for clients, and helps to decouple clients from services.</span></span>

- <span data-ttu-id="970a8-173">[网关聚合](../../patterns/gateway-aggregation.md)：将多个请求聚合成单个请求，以减少客户端与后端之间的通信频率。</span><span class="sxs-lookup"><span data-stu-id="970a8-173">[Gateway Aggregation](../../patterns/gateway-aggregation.md): Aggregation of multiple requests into a single request, to reduce chattiness between the client and the backend.</span></span>

- <span data-ttu-id="970a8-174">[网关卸载](../../patterns/gateway-offloading.md)。</span><span class="sxs-lookup"><span data-stu-id="970a8-174">[Gateway Offloading](../../patterns/gateway-offloading.md).</span></span> <span data-ttu-id="970a8-175">网关可以分担后端服务的功能，例如 SSL 终止、身份验证、IP 允许列表或客户端速率限制（限制）。</span><span class="sxs-lookup"><span data-stu-id="970a8-175">A gateway can offload functionality from the backend services, such as SSL termination, authentication, IP whitelisting, or client rate limiting (throttling).</span></span>

<span data-ttu-id="970a8-176">API 网关是一种通用的[微服务设计模式](https://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="970a8-176">API gateways are a general [microservices design pattern](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="970a8-177">可以使用多种不同的技术来实施 API 网关。</span><span class="sxs-lookup"><span data-stu-id="970a8-177">They can be implemented using a number of different technologies.</span></span> <span data-ttu-id="970a8-178">最常见的实施方案可能是在群集中部署边缘路由器或反向代理，例如 Nginx、HAProxy 或 Traefik。</span><span class="sxs-lookup"><span data-stu-id="970a8-178">Probably the most common implementation is to deploy an edge router or reverse proxy, such as Nginx, HAProxy, or Traefik, inside the cluster.</span></span> 

<span data-ttu-id="970a8-179">其他选项包括：</span><span class="sxs-lookup"><span data-stu-id="970a8-179">Other options include:</span></span>

- <span data-ttu-id="970a8-180">Azure 应用程序网关和/或 Azure API 管理，两者都是群集外部的托管服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-180">Azure Application Gateway and/or Azure API-Management, which are both managed services that reside outside of the cluster.</span></span> <span data-ttu-id="970a8-181">应用程序网关入口控制器目前为 beta 版。</span><span class="sxs-lookup"><span data-stu-id="970a8-181">An Application Gateway Ingress Controller is currently in beta.</span></span>

- <span data-ttu-id="970a8-182">Azure Functions 代理。</span><span class="sxs-lookup"><span data-stu-id="970a8-182">Azure Functions Proxies.</span></span> <span data-ttu-id="970a8-183">代理可以修改请求和响应，并可基于 URL 路由请求。</span><span class="sxs-lookup"><span data-stu-id="970a8-183">Proxies can modify requests and responses and route requests based on URL.</span></span>

<span data-ttu-id="970a8-184">Kubernetes **入口**资源类型可以抽象化代理服务器的配置设置。</span><span class="sxs-lookup"><span data-stu-id="970a8-184">The Kubernetes **Ingress** resource type abstracts the configuration settings for a proxy server.</span></span> <span data-ttu-id="970a8-185">它与入口控制器配合使用。入口控制器提供入口的底层实现。</span><span class="sxs-lookup"><span data-stu-id="970a8-185">It works in conjunction with an ingress controller, which provides the underlying implementation of the Ingress.</span></span> <span data-ttu-id="970a8-186">Nginx、HAProxy、Traefik 和应用程序网关（预览版）等服务都有入口控制器。</span><span class="sxs-lookup"><span data-stu-id="970a8-186">There are ingress controllers for Nginx, HAProxy, Traefik, and Application Gateway (preview), among others.</span></span>

<span data-ttu-id="970a8-187">入口控制器处理代理服务器的配置。</span><span class="sxs-lookup"><span data-stu-id="970a8-187">The ingress controller handles configuring the proxy server.</span></span> <span data-ttu-id="970a8-188">通常，这些服务需要复杂的配置文件，如果你不精通这些技术，则可能很难优化这些文件。因此，入口控制器是一种不错的抽象。</span><span class="sxs-lookup"><span data-stu-id="970a8-188">Often these require complex configuration files, which can be hard to tune if you aren't an expert, so the ingress controller is a nice abstraction.</span></span> <span data-ttu-id="970a8-189">此外，入口控制器可以访问 Kubernetes API，因此，使用它可以在路由和负载均衡方面做出明智的决策。</span><span class="sxs-lookup"><span data-stu-id="970a8-189">In addition, the Ingress Controller has access to the Kubernetes API, so it can make intelligent decisions about routing and load balancing.</span></span> <span data-ttu-id="970a8-190">例如，Nginx 入口控制器可绕过 kube-proxy 网络代理。</span><span class="sxs-lookup"><span data-stu-id="970a8-190">For example, the Nginx ingress controller bypasses the kube-proxy network proxy.</span></span>

<span data-ttu-id="970a8-191">另一方面，如果你想要对设置拥有完全控制权，则可能需要绕过这种抽象，并手动配置代理服务器。</span><span class="sxs-lookup"><span data-stu-id="970a8-191">On the other hand, if you need complete control over the settings, you may want to bypass this abstraction and configure the proxy server manually.</span></span> 

<span data-ttu-id="970a8-192">反向代理服务器是潜在的瓶颈或单一故障点，因此，应至少部署两个副本以实现高可用性。</span><span class="sxs-lookup"><span data-stu-id="970a8-192">A reverse proxy server is a potential bottleneck or single point of failure, so always deploy at least two replicas for high availability.</span></span>

### <a name="data-storage"></a><span data-ttu-id="970a8-193">数据存储</span><span class="sxs-lookup"><span data-stu-id="970a8-193">Data storage</span></span>

<span data-ttu-id="970a8-194">在微服务体系结构中，服务不应共享数据存储。</span><span class="sxs-lookup"><span data-stu-id="970a8-194">In a microservices architecture, services should not share data storage.</span></span> <span data-ttu-id="970a8-195">每个服务应在单独的逻辑存储中拥有自身的专用数据，以避免服务之间存在隐藏的依赖关系。</span><span class="sxs-lookup"><span data-stu-id="970a8-195">Each service should own its own private data in a separate logical storage, to avoid hidden dependencies among services.</span></span> <span data-ttu-id="970a8-196">原因是避免服务之间出现意外耦合 - 如果服务共享相同的底层数据架构，就会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="970a8-196">The reason is to avoid unintentional coupling between services, which can happen when services share the same underlying data schemas.</span></span> <span data-ttu-id="970a8-197">此外，当服务管理自身的数据存储时，可以使用适当的数据存储来满足特定的要求。</span><span class="sxs-lookup"><span data-stu-id="970a8-197">Also, when services manage their own data stores, they can use the right data store for their particular requirements.</span></span> <span data-ttu-id="970a8-198">有关详细信息，请参阅[设计微服务：数据注意事项](/azure/architecture/microservices/data-considerations)。</span><span class="sxs-lookup"><span data-stu-id="970a8-198">For more information, see [Designing microservices: Data considerations](/azure/architecture/microservices/data-considerations).</span></span>

<span data-ttu-id="970a8-199">避免在本地群集存储中存储持久性数据，因为这会将数据绑定到节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-199">Avoid storing persistent data in local cluster storage, because that ties the data to the node.</span></span> <span data-ttu-id="970a8-200">应该</span><span class="sxs-lookup"><span data-stu-id="970a8-200">Instead,</span></span> 

- <span data-ttu-id="970a8-201">使用 Azure SQL 数据库或 Cosmos DB 等外部服务，或者</span><span class="sxs-lookup"><span data-stu-id="970a8-201">Use an external service such as Azure SQL Database or Cosmos DB, *or*</span></span>

- <span data-ttu-id="970a8-202">使用 Azure 磁盘或 Azure 文件装载持久性卷。</span><span class="sxs-lookup"><span data-stu-id="970a8-202">Mount a persistent volume using Azure Disks or Azure Files.</span></span> <span data-ttu-id="970a8-203">如果同一个卷需要由多个 pod 共享，请使用 Azure 文件。</span><span class="sxs-lookup"><span data-stu-id="970a8-203">Use Azure Files if the same volume needs to be shared by multiple pods.</span></span>

### <a name="namespaces"></a><span data-ttu-id="970a8-204">命名空间</span><span class="sxs-lookup"><span data-stu-id="970a8-204">Namespaces</span></span>

<span data-ttu-id="970a8-205">使用命名空间来组织群集中的服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-205">Use namespaces to organize services within the cluster.</span></span> <span data-ttu-id="970a8-206">Kubernetes 群集中的每个对象属于某个命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-206">Every object in a Kubernetes cluster belongs to a namespace.</span></span> <span data-ttu-id="970a8-207">默认情况下，在创建新对象时，该对象将划归到 `default` 命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-207">By default, when you create a new object, it goes into the `default` namespace.</span></span> <span data-ttu-id="970a8-208">但是，良好的做法是创建更具描述性的命名空间，以帮助组织群集中的资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-208">But it's a good practice to create namespaces that are more descriptive to help organize the resources in the cluster.</span></span>

<span data-ttu-id="970a8-209">首先，命名空间有助于防止命名冲突。</span><span class="sxs-lookup"><span data-stu-id="970a8-209">First, namespaces help prevent naming collisions.</span></span> <span data-ttu-id="970a8-210">如果多个团队将微服务（也许有数百个）部署到同一群集，而这些微服务都属于同一命名空间，则管理就会变得艰难。</span><span class="sxs-lookup"><span data-stu-id="970a8-210">When multiple teams deploy microservices into the same cluster, with possibly hundreds of microservices, it gets hard to manage if they all go into the same namespace.</span></span> <span data-ttu-id="970a8-211">此外，命名空间还允许：</span><span class="sxs-lookup"><span data-stu-id="970a8-211">In addition, namespaces allow you to:</span></span>

- <span data-ttu-id="970a8-212">将资源约束应用到命名空间，以避免分配到该命名空间的 pod 集总数超过该命名空间的资源配额。</span><span class="sxs-lookup"><span data-stu-id="970a8-212">Apply resource constraints to a namespace, so that the total set of pods assigned to that namespace cannot exceed the resource quota of the namespace.</span></span>

- <span data-ttu-id="970a8-213">在命名空间级别应用策略，包括 RBAC 和安全策略。</span><span class="sxs-lookup"><span data-stu-id="970a8-213">Apply policies at the namespace level, including RBAC and security policies.</span></span>

<span data-ttu-id="970a8-214">对于微服务体系结构，考虑将微服务组织成边界上下文，并为每个边界上下文创建命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-214">For a microservices architecture, considering organizing the microservices into bounded contexts, and creating namespaces for each bounded context.</span></span> <span data-ttu-id="970a8-215">例如，与“订单履行”边界上下文相关的所有微服务可以划归到同一命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-215">For example, all microservices related to the "Order Fulfillment" bounded context could go into the same namespace.</span></span> <span data-ttu-id="970a8-216">或者，为每个开发团队创建一个命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-216">Alternatively, create a namespace for each development team.</span></span>

<span data-ttu-id="970a8-217">将公用服务放入其自身的独立命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-217">Place utility services into their own separate namespace.</span></span> <span data-ttu-id="970a8-218">例如，可以部署 Elasticsearch 或 Prometheus 进行群集监视，或者为 Helm 部署 Tiller。</span><span class="sxs-lookup"><span data-stu-id="970a8-218">For example, you might deploy Elasticsearch or Prometheus for cluster monitoring, or Tiller for Helm.</span></span>

## <a name="scalability-considerations"></a><span data-ttu-id="970a8-219">可伸缩性注意事项</span><span class="sxs-lookup"><span data-stu-id="970a8-219">Scalability considerations</span></span>

<span data-ttu-id="970a8-220">Kubernetes 支持两个级别的横向扩展：</span><span class="sxs-lookup"><span data-stu-id="970a8-220">Kubernetes supports scale-out at two levels:</span></span>

- <span data-ttu-id="970a8-221">增加分配给部署的 pod 数。</span><span class="sxs-lookup"><span data-stu-id="970a8-221">Scale the number of pods allocated to a deployment.</span></span>
- <span data-ttu-id="970a8-222">扩展群集中的节点，以增加群集可用的计算资源总量。</span><span class="sxs-lookup"><span data-stu-id="970a8-222">Scale the nodes in the cluster, to increase the total compute resources available to the cluster.</span></span>

<span data-ttu-id="970a8-223">尽管可以手动横向扩展 pod 和节点，但我们建议使用自动缩放，以尽量减少在负载较高的情况下，服务遇到资源严重不足的可能性。</span><span class="sxs-lookup"><span data-stu-id="970a8-223">Although you can scale out pods and nodes manually, we recommend using autoscaling, to minimize the chance that services will become resource starved under high load.</span></span> <span data-ttu-id="970a8-224">自动缩放策略必须同时考虑到 pod 和节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-224">An autoscaling strategy must take both pods and nodes into account.</span></span> <span data-ttu-id="970a8-225">如果只是横向扩展 pod，则最终会达到节点的资源限制。</span><span class="sxs-lookup"><span data-stu-id="970a8-225">If you just scale out the pods, eventually you will reach the resource limits of the nodes.</span></span> 

### <a name="pod-autoscaling"></a><span data-ttu-id="970a8-226">Pod 自动缩放</span><span class="sxs-lookup"><span data-stu-id="970a8-226">Pod autoscaling</span></span>

<span data-ttu-id="970a8-227">Horizontal Pod Autoscaler (HPA) 可以根据观察到的 CPU、内存或自定义指标缩放 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-227">The Horizontal Pod Autoscaler (HPA) scales pods based on observed CPU, memory, or custom metrics.</span></span> <span data-ttu-id="970a8-228">若要配置水平 pod 缩放，请指定目标指标（例如，70% 的 CPU），以及最小和最大副本数。</span><span class="sxs-lookup"><span data-stu-id="970a8-228">To configure horizontal pod scaling, you specify a target metric (for example, 70% of CPU), and the minimum and maximum number of replicas.</span></span> <span data-ttu-id="970a8-229">应该对服务进行负载测试，以派生这些数字。</span><span class="sxs-lookup"><span data-stu-id="970a8-229">You should load test your services to derive these numbers.</span></span>

<span data-ttu-id="970a8-230">自动缩放的负面影响是发生横向扩展和缩减事件时，会更频繁地创建或逐出 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-230">A side-effect of autoscaling is that pods may be created or evicted more frequently, as scale-out and scale-in events happen.</span></span> <span data-ttu-id="970a8-231">缓解这种影响的方法：</span><span class="sxs-lookup"><span data-stu-id="970a8-231">To mitigate the effects of this:</span></span>

- <span data-ttu-id="970a8-232">使用就绪情况探测来让 Kubernetes 知道新 pod 已准备好接受流量。</span><span class="sxs-lookup"><span data-stu-id="970a8-232">Use readiness probes to let Kubernetes know when a new pod is ready to accept traffic.</span></span>
- <span data-ttu-id="970a8-233">使用 pod 中断预算来限制每次可从服务中逐出的 pod 数。</span><span class="sxs-lookup"><span data-stu-id="970a8-233">Use pod disruption budgets to limit how many pods can be evicted from a service at a time.</span></span>

### <a name="cluster-autoscaling"></a><span data-ttu-id="970a8-234">群集自动缩放</span><span class="sxs-lookup"><span data-stu-id="970a8-234">Cluster autoscaling</span></span>

<span data-ttu-id="970a8-235">群集自动缩放程序可以缩放节点数目。</span><span class="sxs-lookup"><span data-stu-id="970a8-235">The cluster autoscaler scales the number of nodes.</span></span> <span data-ttu-id="970a8-236">如果由于资源约束而无法计划 pod，群集自动缩放程序将预配更多节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-236">If pods can't be scheduled because of resource constraints, the cluster autoscaler will provision more nodes.</span></span>  <span data-ttu-id="970a8-237">（注意：AKS 与群集自动缩放程序之间的集成目前以预览版提供。）</span><span class="sxs-lookup"><span data-stu-id="970a8-237">(Note: Integration between AKS and the cluster autoscaler is currently in preview.)</span></span>

<span data-ttu-id="970a8-238">HPA 监视实际消耗的资源量以及正在运行的 pod 中的其他指标，而群集自动缩放程序是为尚未计划的 pod 预配节点。</span><span class="sxs-lookup"><span data-stu-id="970a8-238">Whereas HPA looks at actual resources consumed or other metrics from running pods, the cluster autoscaler is provisioning nodes for pods that aren't scheduled yet.</span></span> <span data-ttu-id="970a8-239">因此，自动缩放程序将会监视部署的 Kubernetes pod 规范中指定的请求资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-239">Therefore, it looks at the requested resources, as specified in the Kubernetes pod spec for a deployment.</span></span> <span data-ttu-id="970a8-240">使用负载测试可以微调这些值。</span><span class="sxs-lookup"><span data-stu-id="970a8-240">Use load testing to fine-tune these values.</span></span>

<span data-ttu-id="970a8-241">创建群集后无法更改 VM 大小，因此，在创建群集时，应该进行某种形式的初始容量规划，以便为代理节点选择适当的 VM 大小。</span><span class="sxs-lookup"><span data-stu-id="970a8-241">You can't change the VM size after you create the cluster, so you should do some initial capacity planning to choose an appropriate VM size for the agent nodes when you create the cluster.</span></span> 

## <a name="availability-considerations"></a><span data-ttu-id="970a8-242">可用性注意事项</span><span class="sxs-lookup"><span data-stu-id="970a8-242">Availability considerations</span></span>

### <a name="health-probes"></a><span data-ttu-id="970a8-243">运行状况探测</span><span class="sxs-lookup"><span data-stu-id="970a8-243">Health probes</span></span>

<span data-ttu-id="970a8-244">Kubernetes 定义 pod 可以公开的两种类型的运行状况探测：</span><span class="sxs-lookup"><span data-stu-id="970a8-244">Kubernetes defines two types of health probe that a pod can expose:</span></span>

- <span data-ttu-id="970a8-245">就绪情况探测：告知 Kubernetes pod 是否已准备好接受请求。</span><span class="sxs-lookup"><span data-stu-id="970a8-245">Readiness probe: Tells Kubernetes whether the pod is ready to accept requests.</span></span>

- <span data-ttu-id="970a8-246">运行情况探测：告知 Kubernetes 是否应删除一个 pod 并启动新实例。</span><span class="sxs-lookup"><span data-stu-id="970a8-246">Liveness probe: Tells Kubernetes whether a pod should be removed and a new instance started.</span></span>

<span data-ttu-id="970a8-247">考虑探测的设置时，建议回顾 Kubernetes 中的服务工作原理。</span><span class="sxs-lookup"><span data-stu-id="970a8-247">When thinking about probes, it's useful to recall how a service works in Kubernetes.</span></span> <span data-ttu-id="970a8-248">服务提供与 pod 集（零个或多个）匹配的标签选择器。</span><span class="sxs-lookup"><span data-stu-id="970a8-248">A service has a label selector that matches a set of (zero or more) pods.</span></span> <span data-ttu-id="970a8-249">Kubernetes 对发往匹配该选择器的 pod 的流量进行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="970a8-249">Kubernetes load balances traffic to the pods that match the selector.</span></span> <span data-ttu-id="970a8-250">只有成功启动且正常的 pod 才能收到流量。</span><span class="sxs-lookup"><span data-stu-id="970a8-250">Only pods that started successfully and are healthy receive traffic.</span></span> <span data-ttu-id="970a8-251">如果某个容器崩溃，Kubernetes 会终止 pod，并计划替代的 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-251">If a container crashes, Kubernetes kills the pod and schedules a replacement.</span></span>

<span data-ttu-id="970a8-252">有时，尽管某个 pod 已成功启动，但不一定已准备好接收流量。</span><span class="sxs-lookup"><span data-stu-id="970a8-252">Sometimes, a pod may not be ready to receive traffic, even though the pod started successfully.</span></span> <span data-ttu-id="970a8-253">例如，在执行初始化任务期间，容器中运行的应用程序会将内容载入内存或读取配置数据。</span><span class="sxs-lookup"><span data-stu-id="970a8-253">For example, there may be initialization tasks, where the application running in the container loads things into memory or reads configuration data.</span></span> <span data-ttu-id="970a8-254">若要指示某个 pod 正常但尚未准备好接收流量，请定义就绪情况探测。</span><span class="sxs-lookup"><span data-stu-id="970a8-254">To indicate that a pod is healthy but not ready to receive traffic, define a readiness probe.</span></span> 

<span data-ttu-id="970a8-255">运行情况探测可以处理 pod 仍在运行但不正常，应予以回收的情况。</span><span class="sxs-lookup"><span data-stu-id="970a8-255">Liveness probes handle the case where a pod is still running, but is unhealthy and should be recycled.</span></span> <span data-ttu-id="970a8-256">例如，假设某个容器正在为 HTTP 请求提供服务，但出于某种原因而挂起。</span><span class="sxs-lookup"><span data-stu-id="970a8-256">For example, suppose that a container is serving HTTP requests but hangs for some reason.</span></span> <span data-ttu-id="970a8-257">该容器未崩溃，但已停止为任何请求提供服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-257">The container doesn't crash, but it has stopped serving any requests.</span></span> <span data-ttu-id="970a8-258">如果定义了 HTTP 运行情况探测，则探测将停止响应，并告知 Kubernetes 重启 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-258">If you define an HTTP liveness probe, the probe will stop responding and that informs Kubernetes to restart the pod.</span></span>

<span data-ttu-id="970a8-259">设计探测时请注意以下事项：</span><span class="sxs-lookup"><span data-stu-id="970a8-259">Here are some considerations when designing probes:</span></span>

- <span data-ttu-id="970a8-260">如果代码的启动时间较长，则可能存在以下风险：运行情况探测在启动完成之前报告故障。</span><span class="sxs-lookup"><span data-stu-id="970a8-260">If your code has a long startup time, there is a danger that a liveness probe will report failure before the startup completes.</span></span> <span data-ttu-id="970a8-261">为防止这种情况，请使用 initialDelaySeconds 设置来延迟探测的启动。</span><span class="sxs-lookup"><span data-stu-id="970a8-261">To prevent this, use the initialDelaySeconds setting, which delays the probe from starting.</span></span>

- <span data-ttu-id="970a8-262">除非重启 pod 有可能会将其还原到正常状态，否则运行情况探测没有作用。</span><span class="sxs-lookup"><span data-stu-id="970a8-262">A liveness probe doesn't help unless restarting the pod is likely to restore it to a healthy state.</span></span> <span data-ttu-id="970a8-263">可以使用运行情况探测来防范内存泄漏或意外死锁，但是，没有必要重启立即会再发生故障的 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-263">You can use a liveness probe to mitigate against memory leaks or unexpected deadlocks, but there's no point in restarting a pod that's going to immediately fail again.</span></span>

- <span data-ttu-id="970a8-264">有时，就绪情况探测可用于检查依赖服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-264">Sometimes readiness probes are used to check dependent services.</span></span> <span data-ttu-id="970a8-265">例如，如果某个 pod 依赖于某个数据库，则运行情况探测可以检查数据库连接。</span><span class="sxs-lookup"><span data-stu-id="970a8-265">For example, if a pod has a dependency on a database, the liveness probe might check the database connection.</span></span> <span data-ttu-id="970a8-266">但是，此方法可能造成意外的问题。</span><span class="sxs-lookup"><span data-stu-id="970a8-266">However, this approach can create unexpected problems.</span></span> <span data-ttu-id="970a8-267">外部服务可能出于某种原因而暂时不可用。</span><span class="sxs-lookup"><span data-stu-id="970a8-267">An external service might be temporarily unavailable for some reason.</span></span> <span data-ttu-id="970a8-268">这会导致就绪情况探测无法针对服务中的所有 pod 运行，从而导致从负载均衡中删除所有这些 pod，进而又导致上游发生连锁故障。</span><span class="sxs-lookup"><span data-stu-id="970a8-268">That will cause the readiness probe to fail for all the pods in your service, causing all of them to be removed from load balancing, and thus creating cascading failures upstream.</span></span> <span data-ttu-id="970a8-269">更好的方法是在服务中实施重试处理，使服务能够从暂时性故障中正常恢复。</span><span class="sxs-lookup"><span data-stu-id="970a8-269">A better approach is to implement retry handling within your service, so that your service can recover correctly from transient failures.</span></span>

### <a name="resource-constraints"></a><span data-ttu-id="970a8-270">资源约束</span><span class="sxs-lookup"><span data-stu-id="970a8-270">Resource constraints</span></span>

<span data-ttu-id="970a8-271">资源争用可能影响服务的可用性。</span><span class="sxs-lookup"><span data-stu-id="970a8-271">Resource contention can affect the availability of a service.</span></span> <span data-ttu-id="970a8-272">为容器定义资源约束，以避免单个容器占用过多的群集资源（内存和 CPU）。</span><span class="sxs-lookup"><span data-stu-id="970a8-272">Define resource constraints for containers, so that a single container cannot overwhelm the cluster resources (memory and CPU).</span></span> <span data-ttu-id="970a8-273">对于非容器资源（例如线程或网络连接），请考虑使用[隔舱模式](/azure/architecture/patterns/bulkhead)来隔离资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-273">For non-container resources, such as threads or network connections, consider using the [Bulkhead Pattern](/azure/architecture/patterns/bulkhead) to isolate resources.</span></span>

<span data-ttu-id="970a8-274">使用资源配额限制允许命名空间使用的资源总量。</span><span class="sxs-lookup"><span data-stu-id="970a8-274">Use resource quotas to limit the total resources allowed for a namespace.</span></span> <span data-ttu-id="970a8-275">这样可以避免前端耗尽后端服务的资源，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="970a8-275">That way, the front end can't starve the backend services for resources or vice-versa.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="970a8-276">安全注意事项</span><span class="sxs-lookup"><span data-stu-id="970a8-276">Security considerations</span></span>

### <a name="role-based-access-control-rbac"></a><span data-ttu-id="970a8-277">基于角色的访问控制 (RBAC)</span><span class="sxs-lookup"><span data-stu-id="970a8-277">Role based access control (RBAC)</span></span>

<span data-ttu-id="970a8-278">Kubernetes 和 Azure 都提供基于角色的访问控制 (RBAC) 机制：</span><span class="sxs-lookup"><span data-stu-id="970a8-278">Kubernetes and Azure both have mechanisms for role-based access control (RBAC):</span></span>

- <span data-ttu-id="970a8-279">Azure RBAC 控制对 Azure 中的资源的访问，还可以创建新的 Azure 资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-279">Azure RBAC controls access to resources in Azure, including the ability to create new Azure resources.</span></span> <span data-ttu-id="970a8-280">可将权限分配给用户、组或服务主体。</span><span class="sxs-lookup"><span data-stu-id="970a8-280">Permissions can be assigned to users, groups, or service principals.</span></span> <span data-ttu-id="970a8-281">（服务主体是应用程序使用的安全标识。）</span><span class="sxs-lookup"><span data-stu-id="970a8-281">(A service principal is a security identity used by applications.)</span></span>

- <span data-ttu-id="970a8-282">Kubernetes RBAC 控制 Kubernetes API 的权限。</span><span class="sxs-lookup"><span data-stu-id="970a8-282">Kubernetes RBAC controls permissions to the Kubernetes API.</span></span> <span data-ttu-id="970a8-283">例如，可以通过 RBAC 授权（或拒绝）用户执行创建 pod 和列出 pod 的操作。</span><span class="sxs-lookup"><span data-stu-id="970a8-283">For example, creating pods and listing pods are actions that can be authorized (or denied) to a user through RBAC.</span></span> <span data-ttu-id="970a8-284">若要将 Kubernetes 权限分配给用户，请创建角色和角色绑定：</span><span class="sxs-lookup"><span data-stu-id="970a8-284">To assign Kubernetes permissions to users, you create *roles* and *role bindings*:</span></span>

  - <span data-ttu-id="970a8-285">角色是在命名空间内部应用的一组权限。</span><span class="sxs-lookup"><span data-stu-id="970a8-285">A Role is a set of permissions that apply within a namespace.</span></span> <span data-ttu-id="970a8-286">权限定义为针对资源（pod、部署等）应用的谓词（获取、更新、创建、删除）。</span><span class="sxs-lookup"><span data-stu-id="970a8-286">Permissions are defined as verbs (get, update, create, delete) on resources (pods, deployments, etc.).</span></span>

  - <span data-ttu-id="970a8-287">角色绑定将用户或组分配到角色。</span><span class="sxs-lookup"><span data-stu-id="970a8-287">A RoleBinding assigns users or groups to a Role.</span></span>

  - <span data-ttu-id="970a8-288">此外还有一个群集角色对象，该对象类似于角色，但会应用到整个群集中的所有命名空间。</span><span class="sxs-lookup"><span data-stu-id="970a8-288">There is also a ClusterRole object, which is like a Role but applies to the entire cluster, across all namespaces.</span></span> <span data-ttu-id="970a8-289">若要将用户或组分配到群集角色，请创建群集角色绑定。</span><span class="sxs-lookup"><span data-stu-id="970a8-289">To assign users or groups to a ClusterRole, create a ClusterRoleBinding.</span></span>

<span data-ttu-id="970a8-290">AKS 集成了这两种 RBAC 机制。</span><span class="sxs-lookup"><span data-stu-id="970a8-290">AKS integrates these two RBAC mechanisms.</span></span> <span data-ttu-id="970a8-291">创建 AKS 群集时，可将其配置为使用 Azure AD 进行用户身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-291">When you create an AKS cluster, you can configure it to use Azure AD for user authentication.</span></span> <span data-ttu-id="970a8-292">有关此设置的详细信息，请参阅[将 Azure Active Directory 与 Azure Kubernetes 服务集成](/azure/aks/aad-integration)。</span><span class="sxs-lookup"><span data-stu-id="970a8-292">For details on how to set this up, see [Integrate Azure Active Directory with Azure Kubernetes Service](/azure/aks/aad-integration).</span></span>

<span data-ttu-id="970a8-293">完成此配置后，想要访问 Kubernetes API（例如，通过 kubectl）的用户必须使用其 Azure AD 凭据登录。</span><span class="sxs-lookup"><span data-stu-id="970a8-293">Once this is configured, a user who wants to access the Kubernetes API (for example, through kubectl) must sign in using their Azure AD credentials.</span></span>

<span data-ttu-id="970a8-294">默认情况下，Azure AD 用户无权访问群集。</span><span class="sxs-lookup"><span data-stu-id="970a8-294">By default, an Azure AD user has no access to the cluster.</span></span> <span data-ttu-id="970a8-295">若要授予访问权限，群集管理员需创建引用 Azure AD 用户或组的角色绑定。</span><span class="sxs-lookup"><span data-stu-id="970a8-295">To grant access, the cluster administrator creates RoleBindings that refer to Azure AD users or groups.</span></span> <span data-ttu-id="970a8-296">如果用户对特定的操作没有权限，则该操作将会失败。</span><span class="sxs-lookup"><span data-stu-id="970a8-296">If a user doesn't have permissions for a particular operation, it will fail.</span></span>

<span data-ttu-id="970a8-297">如果用户默认没有访问权限，群集管理员最初又怎么有权创建角色绑定呢？</span><span class="sxs-lookup"><span data-stu-id="970a8-297">If users have no access by default, how does the cluster admin have permission to create the role bindings in the first place?</span></span> <span data-ttu-id="970a8-298">实际上，AKS 群集提供两种类型的凭据来调用 Kubernetes API 服务器：群集用户和群集管理员凭据。群集管理员凭据授予群集的完全访问权限。</span><span class="sxs-lookup"><span data-stu-id="970a8-298">An AKS cluster actually has two types of credentials for calling the Kubernetes API server: cluster user and cluster admin. The cluster admin credentials grant full access to the cluster.</span></span> <span data-ttu-id="970a8-299">Azure CLI 命令 `az aks get-credentials --admin` 下载群集管理员凭据，并将其保存到 kubeconfig 文件中。</span><span class="sxs-lookup"><span data-stu-id="970a8-299">The Azure CLI command `az aks get-credentials --admin` downloads the cluster admin credentials and saves them into your kubeconfig file.</span></span> <span data-ttu-id="970a8-300">群集管理员可以使用此 kubeconfig 来创建角色和角色绑定。</span><span class="sxs-lookup"><span data-stu-id="970a8-300">The cluster administrator can use this kubeconfig to create roles and role bindings.</span></span>

<span data-ttu-id="970a8-301">由于群集管理员凭据的权限如此强大，因此需要使用 Azure RBAC 来限制其访问权限：</span><span class="sxs-lookup"><span data-stu-id="970a8-301">Because the cluster admin credentials are so powerful, use Azure RBAC to restrict access to them:</span></span>

- <span data-ttu-id="970a8-302">“Azure Kubernetes 服务群集管理员角色”有权下载群集管理员凭据。</span><span class="sxs-lookup"><span data-stu-id="970a8-302">The "Azure Kubernetes Service Cluster Admin Role" has permission to download the cluster admin credentials.</span></span> <span data-ttu-id="970a8-303">应该只将群集管理员分配到此角色。</span><span class="sxs-lookup"><span data-stu-id="970a8-303">Only cluster administrators should be assigned to this role.</span></span>

- <span data-ttu-id="970a8-304">“Azure Kubernetes 服务群集用户角色”有权下载群集用户凭据。</span><span class="sxs-lookup"><span data-stu-id="970a8-304">The "Azure Kubernetes Service Cluster User Role" has permission to download the cluster user credentials.</span></span> <span data-ttu-id="970a8-305">可将非管理员用户分配到此角色。</span><span class="sxs-lookup"><span data-stu-id="970a8-305">Non-admin users can be assigned to this role.</span></span> <span data-ttu-id="970a8-306">此角色不会授予对群集中 Kubernetes 资源的任何特定权限 &mdash; 它只允许用户连接到 API 服务器。</span><span class="sxs-lookup"><span data-stu-id="970a8-306">This role does not give any particular permissions on Kubernetes resources inside the cluster &mdash; it just allows a user to connect to the API server.</span></span> 

<span data-ttu-id="970a8-307">定义 RBAC 策略（Kubernetes 和 Azure）时，请考虑组织中的角色：</span><span class="sxs-lookup"><span data-stu-id="970a8-307">When you define your RBAC policies (both Kubernetes and Azure), think about the roles in your organization:</span></span>

- <span data-ttu-id="970a8-308">谁可以创建或删除 AKS 群集和下载管理员凭据？</span><span class="sxs-lookup"><span data-stu-id="970a8-308">Who can create or delete an AKS cluster and download the admin credentials?</span></span>
- <span data-ttu-id="970a8-309">谁可以管理群集？</span><span class="sxs-lookup"><span data-stu-id="970a8-309">Who can administer a cluster?</span></span>
- <span data-ttu-id="970a8-310">谁可以创建或更新命名空间中的资源？</span><span class="sxs-lookup"><span data-stu-id="970a8-310">Who can create or update resources within a namespace?</span></span>

<span data-ttu-id="970a8-311">良好的做法是使用角色和角色绑定（而不是群集角色和群集角色绑定）按命名空间限定 Kubernetes RBAC 权限的范围。</span><span class="sxs-lookup"><span data-stu-id="970a8-311">It's a good practice to scope Kubernetes RBAC permissions by namespace, using Roles and RoleBindings, rather than ClusterRoles and ClusterRoleBindings.</span></span>

<span data-ttu-id="970a8-312">最后还有这样一个问题：AKS 群集需要拥有哪些权限才能创建和管理负载均衡器、网络或存储等 Azure 资源。</span><span class="sxs-lookup"><span data-stu-id="970a8-312">Finally, there is the question of what permissions the AKS cluster has to create and manage Azure resources, such as load balancers, networking, or storage.</span></span> <span data-ttu-id="970a8-313">若要使用 Azure API 对自身进行身份验证，群集可以使用 Azure AD 服务主体。</span><span class="sxs-lookup"><span data-stu-id="970a8-313">To authenticate itself with Azure APIs, the cluster uses an Azure AD service principal.</span></span> <span data-ttu-id="970a8-314">如果创建群集时未指定服务主体，则系统会自动创建一个服务主体。</span><span class="sxs-lookup"><span data-stu-id="970a8-314">If you don't specify a service principal when you create the cluster, one is created automatically.</span></span> <span data-ttu-id="970a8-315">但是，良好的安全做法是先创建服务主体，然后为其分配最少量的 RBAC 权限。</span><span class="sxs-lookup"><span data-stu-id="970a8-315">However, it's a good security practice to create the service principal first and assign the minimal RBAC permissions to it.</span></span> <span data-ttu-id="970a8-316">有关详细信息，请参阅 [Azure Kubernetes 服务中的服务主体](/azure/aks/kubernetes-service-principal)。</span><span class="sxs-lookup"><span data-stu-id="970a8-316">For more information, see [Service principals with Azure Kubernetes Service](/azure/aks/kubernetes-service-principal).</span></span>

### <a name="secrets-management-and-application-credentials"></a><span data-ttu-id="970a8-317">机密管理和应用程序凭据</span><span class="sxs-lookup"><span data-stu-id="970a8-317">Secrets management and application credentials</span></span>

<span data-ttu-id="970a8-318">应用程序和服务通常需要使用凭据连接到 Azure 存储或 SQL 数据库等外部服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-318">Applications and services often need credentials that allow them to connect to external services such as Azure Storage or SQL Database.</span></span> <span data-ttu-id="970a8-319">此处的难题在于如何保护这些凭据的安全，避免将其透露。</span><span class="sxs-lookup"><span data-stu-id="970a8-319">The challenge is to keep these credentials safe and not leak them.</span></span> 

<span data-ttu-id="970a8-320">对于 Azure 资源，一种做法是使用托管标识。</span><span class="sxs-lookup"><span data-stu-id="970a8-320">For Azure resources, one option is to use managed identities.</span></span> <span data-ttu-id="970a8-321">托管标识的概念是指，应用程序或服务在 Azure AD 中存储一个标识，并使用此标识在 Azure 服务中进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-321">The idea of a managed identity is that an application or service has an identity stored in Azure AD, and uses this identity to authenticate with an Azure service.</span></span> <span data-ttu-id="970a8-322">在 Azure AD 中为应用程序或服务创建一个服务主体，应用程序或服务使用 OAuth 2.0 令牌进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-322">The application or service has a Service Principal created for it in Azure AD, and authenticates using OAuth 2.0 tokens.</span></span> <span data-ttu-id="970a8-323">正在执行的进程调用 localhost 地址来获取令牌。</span><span class="sxs-lookup"><span data-stu-id="970a8-323">The executing process calls a localhost address to get the token.</span></span> <span data-ttu-id="970a8-324">这样，就不需要存储任何密码或连接字符串。</span><span class="sxs-lookup"><span data-stu-id="970a8-324">That way, you don't need to store any passwords or connection strings.</span></span> <span data-ttu-id="970a8-325">若要在 AKS 中使用托管标识，可以使用 [aad-pod-identity](https://github.com/Azure/aad-pod-identity) 项目将标识分配到单个 pod。</span><span class="sxs-lookup"><span data-stu-id="970a8-325">You can use managed identities in AKS by assigning identities to individual pods, using the [aad-pod-identity](https://github.com/Azure/aad-pod-identity) project.</span></span>

<span data-ttu-id="970a8-326">目前，并非所有 Azure 服务都支持使用托管标识进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-326">Currently, not all Azure services support authentication using managed identities.</span></span> <span data-ttu-id="970a8-327">有关列表，请参阅[支持 Azure AD 身份验证的 Azure 服务](/azure/active-directory/managed-identities-azure-resources/services-support-msi)。</span><span class="sxs-lookup"><span data-stu-id="970a8-327">For a list, see [Azure services that support Azure AD authentication](/azure/active-directory/managed-identities-azure-resources/services-support-msi).</span></span>

<span data-ttu-id="970a8-328">即使使用托管标识，也可能需要存储某些凭据或其他应用程序机密，不管是对于不支持托管标识的 Azure 服务、第三方服务、API 密钥，还是其他服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-328">Even with managed identities, you'll probably need to store some credentials or other application secrets, whether for Azure services that don't support managed identities, third-party services, API keys, and so on.</span></span> <span data-ttu-id="970a8-329">下面是可安全存储机密的某些选项：</span><span class="sxs-lookup"><span data-stu-id="970a8-329">Here are some options for storing secrets securely:</span></span>

- <span data-ttu-id="970a8-330">Azure Key Vault。</span><span class="sxs-lookup"><span data-stu-id="970a8-330">Azure Key Vault.</span></span> <span data-ttu-id="970a8-331">在 AKS 中，可将 Key Vault 中的一个或多个机密装载为一个卷。</span><span class="sxs-lookup"><span data-stu-id="970a8-331">In AKS, you can mount one or more secrets from Key Vault as a volume.</span></span> <span data-ttu-id="970a8-332">该卷从 Key Vault 读取机密。</span><span class="sxs-lookup"><span data-stu-id="970a8-332">The volume reads the secrets from Key Vault.</span></span> <span data-ttu-id="970a8-333">然后，pod 可以像读取普通卷一样读取机密。</span><span class="sxs-lookup"><span data-stu-id="970a8-333">The pod can then read the secrets just like a regular volume.</span></span> <span data-ttu-id="970a8-334">有关详细信息，请参阅 GitHub 中的 [Kubernetes-KeyVault-FlexVolume](https://github.com/Azure/kubernetes-keyvault-flexvol) 项目。</span><span class="sxs-lookup"><span data-stu-id="970a8-334">For more information, see the [Kubernetes-KeyVault-FlexVolume](https://github.com/Azure/kubernetes-keyvault-flexvol) project on GitHub.</span></span>

    <span data-ttu-id="970a8-335">pod 使用 pod 标识（如上所述）或者结合使用 Azure AD 服务主体和客户端机密对自身进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-335">The pod authenticates itself by using either a pod identity (described above) or by using an Azure AD Service Principal along with a client secret.</span></span> <span data-ttu-id="970a8-336">建议使用 pod 标识，因为这样就不需要客户端机密。</span><span class="sxs-lookup"><span data-stu-id="970a8-336">Using pod identities is recommended because the client secret isn't needed in that case.</span></span> 

- <span data-ttu-id="970a8-337">HashiCorp Vault。</span><span class="sxs-lookup"><span data-stu-id="970a8-337">HashiCorp Vault.</span></span> <span data-ttu-id="970a8-338">Kubernetes 应用程序可以使用 Azure AD 托管标识在 HashiCorp Vault 中进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-338">Kubernetes applications can authenticate with HashiCorp Vault using Azure AD managed identities.</span></span> <span data-ttu-id="970a8-339">请参阅 [HashiCorp Vault 为 Azure Active Directory 代言](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/)。</span><span class="sxs-lookup"><span data-stu-id="970a8-339">See [HashiCorp Vault speaks Azure Active Directory](https://open.microsoft.com/2018/04/10/scaling-tips-hashicorp-vault-azure-active-directory/).</span></span> <span data-ttu-id="970a8-340">可将 Vault 本身部署到 Kubernetes，但建议在不同于应用程序群集的单独专用群集中运行它。</span><span class="sxs-lookup"><span data-stu-id="970a8-340">You can deploy Vault itself to Kubernetes, but it's recommend to run it in a separate dedicated cluster from your application cluster.</span></span> 

- <span data-ttu-id="970a8-341">Kubernetes 机密。</span><span class="sxs-lookup"><span data-stu-id="970a8-341">Kubernetes secrets.</span></span> <span data-ttu-id="970a8-342">另一个选项是直接使用 Kubernetes 机密。</span><span class="sxs-lookup"><span data-stu-id="970a8-342">Another option is simply to use Kubernetes secrets.</span></span> <span data-ttu-id="970a8-343">此选项最容易配置，但存在一些难题。</span><span class="sxs-lookup"><span data-stu-id="970a8-343">This option is the easiest to configure but has some challenges.</span></span> <span data-ttu-id="970a8-344">机密存储在分布式密钥-值存储 etcd 中。</span><span class="sxs-lookup"><span data-stu-id="970a8-344">Secrets are stored in etcd, which is a distributed key-value store.</span></span> <span data-ttu-id="970a8-345">AKS [静态加密 etcd](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks)。</span><span class="sxs-lookup"><span data-stu-id="970a8-345">AKS [encrypts etcd at rest](https://github.com/Azure/kubernetes-kms#azure-kubernetes-service-aks).</span></span> <span data-ttu-id="970a8-346">Microsoft 管理加密密钥。</span><span class="sxs-lookup"><span data-stu-id="970a8-346">Microsoft manages the encryption keys.</span></span>

<span data-ttu-id="970a8-347">使用 HashiCorp Vault 或 Azure Key Vault 等系统可以获得多种优势，例如：</span><span class="sxs-lookup"><span data-stu-id="970a8-347">Using a system like HashiCorp Vault or Azure Key Vault provides several advantages, such as:</span></span>

- <span data-ttu-id="970a8-348">对机密进行集中控制。</span><span class="sxs-lookup"><span data-stu-id="970a8-348">Centralized control of secrets.</span></span>
- <span data-ttu-id="970a8-349">确保所有机密静态加密。</span><span class="sxs-lookup"><span data-stu-id="970a8-349">Ensuring that all secrets are encrypted at rest.</span></span>
- <span data-ttu-id="970a8-350">集中式密钥管理。</span><span class="sxs-lookup"><span data-stu-id="970a8-350">Centralized key management.</span></span>
- <span data-ttu-id="970a8-351">对机密进行访问控制。</span><span class="sxs-lookup"><span data-stu-id="970a8-351">Access control of secrets.</span></span>
- <span data-ttu-id="970a8-352">审核</span><span class="sxs-lookup"><span data-stu-id="970a8-352">Auditing</span></span>

### <a name="pod-and-container-security"></a><span data-ttu-id="970a8-353">Pod 和容器安全性</span><span class="sxs-lookup"><span data-stu-id="970a8-353">Pod and container security</span></span>

<span data-ttu-id="970a8-354">当然，此列表并不详尽，不过，其中提供了有关保护 pod 和容器的一些建议做法：</span><span class="sxs-lookup"><span data-stu-id="970a8-354">This list is certainly not exhaustive, but here are some recommended practices for securing your pods and containers:</span></span> 

<span data-ttu-id="970a8-355">不要以特权模式运行容器。</span><span class="sxs-lookup"><span data-stu-id="970a8-355">Don't run containers in privileged mode.</span></span> <span data-ttu-id="970a8-356">特权模式可让容器访问主机上的所有设备。</span><span class="sxs-lookup"><span data-stu-id="970a8-356">Privileged mode gives a container access to all devices on the host.</span></span> <span data-ttu-id="970a8-357">可以设置 Pod 安全策略，以禁止容器以特权模式运行。</span><span class="sxs-lookup"><span data-stu-id="970a8-357">You can set Pod Security Policy to disallow containers from running in privileged mode.</span></span> 

<span data-ttu-id="970a8-358">如果可能，请避免以 root 身份在容器中运行进程。</span><span class="sxs-lookup"><span data-stu-id="970a8-358">When possible, avoid running processes as root inside containers.</span></span> <span data-ttu-id="970a8-359">从安全角度看，容器不能提供完全的隔离，因此，最好是以非特权用户的身份运行容器进程。</span><span class="sxs-lookup"><span data-stu-id="970a8-359">Containers do not provide complete isolation from a security standpoint, so it's better to run a container process as a non-privileged user.</span></span> 

<span data-ttu-id="970a8-360">将映像存储在受信任的专用注册表中，例如 Azure 容器注册表或 Docker 信任的注册表。</span><span class="sxs-lookup"><span data-stu-id="970a8-360">Store images in a trusted private registry, such as Azure Container Registry or Docker Trusted Registry.</span></span> <span data-ttu-id="970a8-361">在 Kubernetes 中使用验证许可 Webhook，以确保 pod 只能从受信任的注册表提取映像。</span><span class="sxs-lookup"><span data-stu-id="970a8-361">Use a validating admission webhook in Kubernetes to ensure that pods can only pull images from the trusted registry.</span></span>

<span data-ttu-id="970a8-362">使用 Azure 市场中提供的扫描解决方案（例如 Twistlock 和 Aqua）扫描映像中的已知漏洞。</span><span class="sxs-lookup"><span data-stu-id="970a8-362">Scan images for known vulnerabilities, using a scanning solution such as Twistlock and Aqua, which are available through the Azure Marketplace.</span></span>

<span data-ttu-id="970a8-363">使用 ACR 任务（Azure 容器注册表的一项功能）自动执行映像修补。</span><span class="sxs-lookup"><span data-stu-id="970a8-363">Automate image patching using ACR Tasks, a feature of Azure Container Registry.</span></span> <span data-ttu-id="970a8-364">容器映像是在层中生成的。</span><span class="sxs-lookup"><span data-stu-id="970a8-364">A container image is built up from layers.</span></span> <span data-ttu-id="970a8-365">基本层包括 OS 映像和应用程序框架映像，例如 ASP.NET Core 或 Node.js。</span><span class="sxs-lookup"><span data-stu-id="970a8-365">The base layers include the OS image and application framework images, such as ASP.NET Core or Node.js.</span></span> <span data-ttu-id="970a8-366">基本映像通常是由应用程序开发人员在上游创建的，由其他项目维护人员维护。</span><span class="sxs-lookup"><span data-stu-id="970a8-366">The base images are typically created upstream from the application developers, and are maintained by other project maintainers.</span></span> <span data-ttu-id="970a8-367">在上游修补这些映像时，必须更新、测试并重新部署自己的映像，以便不会留下任何已知的安全漏洞。</span><span class="sxs-lookup"><span data-stu-id="970a8-367">When these images are patched upstream, it's important to update, test, and redeploy your own images, so that you don't leave any known security vulnerabilities.</span></span> <span data-ttu-id="970a8-368">ACR 任务可以帮助将此过程自动化。</span><span class="sxs-lookup"><span data-stu-id="970a8-368">ACR Tasks can help to automate this process.</span></span>

## <a name="deployment-cicd-considerations"></a><span data-ttu-id="970a8-369">部署 (CI/CD) 注意事项</span><span class="sxs-lookup"><span data-stu-id="970a8-369">Deployment (CI/CD) considerations</span></span>

<span data-ttu-id="970a8-370">下面是微服务体系结构的可靠 CI/CD 过程的一些目标：</span><span class="sxs-lookup"><span data-stu-id="970a8-370">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="970a8-371">每个团队可以独立生成并部署自有的服务，而不影响或干扰其他团队。</span><span class="sxs-lookup"><span data-stu-id="970a8-371">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="970a8-372">新服务版本在部署到生产环境之前，会先部署到开发/测试/QA 环境进行验证。</span><span class="sxs-lookup"><span data-stu-id="970a8-372">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="970a8-373">在每个阶段强制实施质量控制。</span><span class="sxs-lookup"><span data-stu-id="970a8-373">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="970a8-374">新服务版本可以连同前一版本一起部署。</span><span class="sxs-lookup"><span data-stu-id="970a8-374">A new version of a service can be deployed side-by-side with the previous version.</span></span>

- <span data-ttu-id="970a8-375">实施足够的访问控制策略。</span><span class="sxs-lookup"><span data-stu-id="970a8-375">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="970a8-376">可以信任部署到生产环境的容器映像。</span><span class="sxs-lookup"><span data-stu-id="970a8-376">You can trust the container images that are deployed to production.</span></span>

### <a name="isolation-of-environments"></a><span data-ttu-id="970a8-377">环境隔离</span><span class="sxs-lookup"><span data-stu-id="970a8-377">Isolation of environments</span></span>

<span data-ttu-id="970a8-378">将在多个环境中部署服务，包括用于开发、版本验收测试、集成测试、负载测试和最终生产的环境。</span><span class="sxs-lookup"><span data-stu-id="970a8-378">You will have multiple environments where you deploy services, including environments for development, smoke testing, integration testing, load testing, and finally production.</span></span> <span data-ttu-id="970a8-379">这些环境需要某种程度的隔离。</span><span class="sxs-lookup"><span data-stu-id="970a8-379">These environments need some level of isolation.</span></span> <span data-ttu-id="970a8-380">在 Kubernetes 中，可以选择物理隔离或逻辑隔离。</span><span class="sxs-lookup"><span data-stu-id="970a8-380">In Kubernetes, you have a choice between physical isolation and logical isolation.</span></span> <span data-ttu-id="970a8-381">物理隔离表示部署到独立的群集。</span><span class="sxs-lookup"><span data-stu-id="970a8-381">Physical isolation means deploying to separate clusters.</span></span> <span data-ttu-id="970a8-382">逻辑隔离利用前面所述的命名空间和策略。</span><span class="sxs-lookup"><span data-stu-id="970a8-382">Logical isolation makes use of namespaces and policies, as described earlier.</span></span>

<span data-ttu-id="970a8-383">我们建议创建专用的生产群集，并为开发/测试环境创建独立的群集。</span><span class="sxs-lookup"><span data-stu-id="970a8-383">Our recommendation is to create a dedicated production cluster along with a separate cluster for your dev/test environments.</span></span> <span data-ttu-id="970a8-384">使用逻辑隔离来隔离开发/测试群集中的环境。</span><span class="sxs-lookup"><span data-stu-id="970a8-384">Use logical isolation to separate environments within the dev/test cluster.</span></span> <span data-ttu-id="970a8-385">部署到开发/测试群集的服务不得有权访问保存业务数据的数据存储。</span><span class="sxs-lookup"><span data-stu-id="970a8-385">Services deployed to the dev/test cluster should never have access to data stores that hold business data.</span></span> 

### <a name="helm"></a><span data-ttu-id="970a8-386">Helm</span><span class="sxs-lookup"><span data-stu-id="970a8-386">Helm</span></span>

<span data-ttu-id="970a8-387">考虑使用 Helm 来管理服务的生成和部署。</span><span class="sxs-lookup"><span data-stu-id="970a8-387">Consider using Helm to manage building and deploying services.</span></span> <span data-ttu-id="970a8-388">可帮助实现 CI/CD 的部分 Helm 功能包括：</span><span class="sxs-lookup"><span data-stu-id="970a8-388">Some of the features of Helm that help with CI/CD include:</span></span>

- <span data-ttu-id="970a8-389">将特定微服务的所有 Kubernetes 对象组织成单个 Helm 图表。</span><span class="sxs-lookup"><span data-stu-id="970a8-389">Organizing all of the Kubernetes objects for a particular microservice into a single Helm chart.</span></span>
- <span data-ttu-id="970a8-390">使用单个 Helm 命令而不是一系列 kubectl 命令部署该图表。</span><span class="sxs-lookup"><span data-stu-id="970a8-390">Deploying the chart as a single helm command, rather than a series of kubectl commands.</span></span>
- <span data-ttu-id="970a8-391">使用语义版本控制以及用于回滚到以前版本的功能来跟踪更新和修订。</span><span class="sxs-lookup"><span data-stu-id="970a8-391">Tracking updates and revisions, using semantic versioning, along with the ability to roll back to a previous version.</span></span>
- <span data-ttu-id="970a8-392">使用模板来避免在多个文件之间复制标签和选择器等信息。</span><span class="sxs-lookup"><span data-stu-id="970a8-392">The use of templates to avoid duplicating information, such as labels and selectors, across many files.</span></span>
- <span data-ttu-id="970a8-393">管理图表之间的依赖关系。</span><span class="sxs-lookup"><span data-stu-id="970a8-393">Managing dependencies between charts.</span></span>
- <span data-ttu-id="970a8-394">将图表发布到 Azure 容器注册表等 Helm 存储库，并将其与生成管道相集成。</span><span class="sxs-lookup"><span data-stu-id="970a8-394">Publishing charts to a Helm repository, such as Azure Container Registry, and integrating them with the build pipeline.</span></span>

<span data-ttu-id="970a8-395">有关将容器注册表用作 Helm 存储库的详细信息，请参阅[将 Azure 容器注册表用作应用程序图表的 Helm 存储库](/azure/container-registry/container-registry-helm-repos)。</span><span class="sxs-lookup"><span data-stu-id="970a8-395">For more information about using Container Registry as a Helm repository, see [Use Azure Container Registry as a Helm repository for your application charts](/azure/container-registry/container-registry-helm-repos).</span></span>

### <a name="cicd-workflow"></a><span data-ttu-id="970a8-396">CI/CD 工作流</span><span class="sxs-lookup"><span data-stu-id="970a8-396">CI/CD workflow</span></span>

<span data-ttu-id="970a8-397">在创建 CI/CD 工作流之前，必须了解如何对代码库进行结构设计和管理。</span><span class="sxs-lookup"><span data-stu-id="970a8-397">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="970a8-398">团队是在多个单独的存储库中工作，还是在一个 monorepo（单存储库）中工作？</span><span class="sxs-lookup"><span data-stu-id="970a8-398">Do teams work in separate respositories or in a monorepo (single respository)?</span></span>
- <span data-ttu-id="970a8-399">什么是分库策略？</span><span class="sxs-lookup"><span data-stu-id="970a8-399">What is your branching strategy?</span></span>
- <span data-ttu-id="970a8-400">谁可以将代码推送到生产环境中？</span><span class="sxs-lookup"><span data-stu-id="970a8-400">Who can push code to production?</span></span> <span data-ttu-id="970a8-401">是否有发布经理角色？</span><span class="sxs-lookup"><span data-stu-id="970a8-401">Is there a release manager role?</span></span>

<span data-ttu-id="970a8-402">首选单存储库方法，但二者各有优缺点。</span><span class="sxs-lookup"><span data-stu-id="970a8-402">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="970a8-403">单存储库</span><span class="sxs-lookup"><span data-stu-id="970a8-403">Monorepo</span></span> | <span data-ttu-id="970a8-404">多存储库</span><span class="sxs-lookup"><span data-stu-id="970a8-404">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="970a8-405">**优点**</span><span class="sxs-lookup"><span data-stu-id="970a8-405">**Advantages**</span></span> | <span data-ttu-id="970a8-406">代码共享</span><span class="sxs-lookup"><span data-stu-id="970a8-406">Code sharing</span></span><br/><span data-ttu-id="970a8-407">更易于实现代码和工具的标准化</span><span class="sxs-lookup"><span data-stu-id="970a8-407">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="970a8-408">更易于重构代码</span><span class="sxs-lookup"><span data-stu-id="970a8-408">Easier to refactor code</span></span><br/><span data-ttu-id="970a8-409">可发现性 - 代码的单一视图</span><span class="sxs-lookup"><span data-stu-id="970a8-409">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="970a8-410">按团队清除所有权</span><span class="sxs-lookup"><span data-stu-id="970a8-410">Clear ownership per team</span></span><br/><span data-ttu-id="970a8-411">合并冲突可能会更少</span><span class="sxs-lookup"><span data-stu-id="970a8-411">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="970a8-412">有助于强制分离微服务</span><span class="sxs-lookup"><span data-stu-id="970a8-412">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="970a8-413">**挑战**</span><span class="sxs-lookup"><span data-stu-id="970a8-413">**Challenges**</span></span> | <span data-ttu-id="970a8-414">对共享代码进行的更改可能影响多个微服务</span><span class="sxs-lookup"><span data-stu-id="970a8-414">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="970a8-415">合并冲突可能会更多</span><span class="sxs-lookup"><span data-stu-id="970a8-415">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="970a8-416">工具必须缩放成大型代码库</span><span class="sxs-lookup"><span data-stu-id="970a8-416">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="970a8-417">访问控制</span><span class="sxs-lookup"><span data-stu-id="970a8-417">Access control</span></span><br/><span data-ttu-id="970a8-418">部署过程更复杂</span><span class="sxs-lookup"><span data-stu-id="970a8-418">More complex deployment process</span></span> | <span data-ttu-id="970a8-419">更难以共享代码</span><span class="sxs-lookup"><span data-stu-id="970a8-419">Harder to share code</span></span><br/><span data-ttu-id="970a8-420">更难以强制实施编码标准</span><span class="sxs-lookup"><span data-stu-id="970a8-420">Harder to enforce coding standards</span></span><br/><span data-ttu-id="970a8-421">依赖项管理</span><span class="sxs-lookup"><span data-stu-id="970a8-421">Dependency management</span></span><br/><span data-ttu-id="970a8-422">代码库分散，可发现性低</span><span class="sxs-lookup"><span data-stu-id="970a8-422">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="970a8-423">缺少共享的基础架构</span><span class="sxs-lookup"><span data-stu-id="970a8-423">Lack of shared infrastructure</span></span>

<span data-ttu-id="970a8-424">在此部分，我们根据以下假设演示可能的 CI/CD 工作流：</span><span class="sxs-lookup"><span data-stu-id="970a8-424">In this section, we present a possible CI/CD workflow, based on the following assumptions:</span></span>

- <span data-ttu-id="970a8-425">代码存储库为单存储库，文件夹按微服务进行组织。</span><span class="sxs-lookup"><span data-stu-id="970a8-425">The code repository is monorepo, with folders organized by microservice.</span></span>
- <span data-ttu-id="970a8-426">团队的分库策略以[基于主库的开发](https://trunkbaseddevelopment.com/)为基础。</span><span class="sxs-lookup"><span data-stu-id="970a8-426">The team's branching strategy is based on [trunk-based development](https://trunkbaseddevelopment.com/).</span></span>
- <span data-ttu-id="970a8-427">团队使用 [Azure Pipelines](/azure/devops/pipelines) 来运行 CI/CD 过程。</span><span class="sxs-lookup"><span data-stu-id="970a8-427">The team uses [Azure Pipelines](/azure/devops/pipelines) to run the CI/CD process.</span></span>
- <span data-ttu-id="970a8-428">团队使用 Azure 容器注册表中的[命名空间](/azure/container-registry/container-registry-best-practices#repository-namespaces)将已获批在生产环境中使用的映像与仍在进行测试的映像隔离开来。</span><span class="sxs-lookup"><span data-stu-id="970a8-428">The team uses [namespaces](/azure/container-registry/container-registry-best-practices#repository-namespaces) in Azure Container Registry to isolate images that are approved for production from images that are still being tested.</span></span>

<span data-ttu-id="970a8-429">在此示例中，一位开发人员在名为“传送服务”的微服务上工作。</span><span class="sxs-lookup"><span data-stu-id="970a8-429">In this example, a developer is working on a microservice called Delivery Service.</span></span> <span data-ttu-id="970a8-430">（此名称来自[此处](../../microservices/index.md#the-drone-delivery-application)所述的引用实现。）在开发新功能时，开发人员会将代码签入到某个功能分库中。</span><span class="sxs-lookup"><span data-stu-id="970a8-430">(The name comes from the reference implementation described [here](../../microservices/index.md#the-drone-delivery-application).) While developing a new feature, the developer checks code into a feature branch.</span></span>

![CI/CD 工作流](./_images/aks-cicd-1.png)

<span data-ttu-id="970a8-432">将提交内容推送到此分库会触发一个适用于微服务的 CI 生成。</span><span class="sxs-lookup"><span data-stu-id="970a8-432">Pushing commits to this branch tiggers a CI build for the microservice.</span></span> <span data-ttu-id="970a8-433">根据约定，功能分库名为 `feature/*`。</span><span class="sxs-lookup"><span data-stu-id="970a8-433">By convention, feature branches are named `feature/*`.</span></span> <span data-ttu-id="970a8-434">[生成定义文件](/azure/devops/pipelines/yaml-schema)包括一个触发器，用于按分库名称和源路径进行筛选。</span><span class="sxs-lookup"><span data-stu-id="970a8-434">The [build definition file](/azure/devops/pipelines/yaml-schema) includes a trigger that filters by the branch name and the source path.</span></span> <span data-ttu-id="970a8-435">使用此方法，每个团队都可以有自己的生成管道。</span><span class="sxs-lookup"><span data-stu-id="970a8-435">Using this approach, each team can have its own build pipeline.</span></span>

```yaml
trigger:
  batch: true
  branches:
    include:
    - master
    - feature/*

    exclude:
    - feature/experimental/*

  paths:
     include:
     - /src/shipping/delivery/
```

<span data-ttu-id="970a8-436">在工作流中，CI 生成此时会运行某种最低程度的代码验证：</span><span class="sxs-lookup"><span data-stu-id="970a8-436">At this point in the workflow, the CI build runs some minimal code verification:</span></span>

1. <span data-ttu-id="970a8-437">生成代码</span><span class="sxs-lookup"><span data-stu-id="970a8-437">Build code</span></span>
1. <span data-ttu-id="970a8-438">运行单元测试</span><span class="sxs-lookup"><span data-stu-id="970a8-438">Run unit tests</span></span>

<span data-ttu-id="970a8-439">此处的理念是缩短生成时间，这样开发人员就可以获得快速反馈。</span><span class="sxs-lookup"><span data-stu-id="970a8-439">The idea here is to keep the build times short so the developer can get quick feedback.</span></span> <span data-ttu-id="970a8-440">当此功能可以合并到主库中时，开发人员会打开一个 PR。</span><span class="sxs-lookup"><span data-stu-id="970a8-440">When the feature is ready to merge into master, the developer opens a PR.</span></span> <span data-ttu-id="970a8-441">此时会触发另一个 CI 生成来执行一些其他的检查：</span><span class="sxs-lookup"><span data-stu-id="970a8-441">This triggers another CI build that performs some additional checks:</span></span>

1. <span data-ttu-id="970a8-442">生成代码</span><span class="sxs-lookup"><span data-stu-id="970a8-442">Build code</span></span>
1. <span data-ttu-id="970a8-443">运行单元测试</span><span class="sxs-lookup"><span data-stu-id="970a8-443">Run unit tests</span></span>
1. <span data-ttu-id="970a8-444">生成运行时容器映像</span><span class="sxs-lookup"><span data-stu-id="970a8-444">Build the runtime container image</span></span>
1. <span data-ttu-id="970a8-445">在映像上运行漏洞扫描</span><span class="sxs-lookup"><span data-stu-id="970a8-445">Run vulnerability scans on the image</span></span>

![CI/CD 工作流](./_images/aks-cicd-2.png)

> [!NOTE]
> <span data-ttu-id="970a8-447">在 Azure Repos 中，可以定义[策略](/azure/devops/repos/git/branch-policies)来保护分库。</span><span class="sxs-lookup"><span data-stu-id="970a8-447">In Azure Repos, you can define [policies](/azure/devops/repos/git/branch-policies) to protect branches.</span></span> <span data-ttu-id="970a8-448">例如，策略可以要求在合并到主库之前，必须成功完成 CI 生成并由审批人员签署同意书。</span><span class="sxs-lookup"><span data-stu-id="970a8-448">For example, the policy could require a successful CI build plus a sign-off from an approver in order to merge into master.</span></span>

<span data-ttu-id="970a8-449">有时候，团队可以部署新版传送服务。</span><span class="sxs-lookup"><span data-stu-id="970a8-449">At some point, the team is ready to deploy a new version of the Delivery service.</span></span> <span data-ttu-id="970a8-450">为此，发布经理会创建主库的分库，采用以下命名模式：`release/<microservice name>/<semver>`。</span><span class="sxs-lookup"><span data-stu-id="970a8-450">To do so, the release manager creates a branch from master with this naming pattern: `release/<microservice name>/<semver>`.</span></span> <span data-ttu-id="970a8-451">例如，`release/delivery/v1.0.2`。</span><span class="sxs-lookup"><span data-stu-id="970a8-451">For example, `release/delivery/v1.0.2`.</span></span>
<span data-ttu-id="970a8-452">这样就会触发一个完整的 CI 生成，该生成运行所有上述步骤并执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="970a8-452">This triggers a full CI build that runs all the previous steps plus:</span></span>

1. <span data-ttu-id="970a8-453">向 Azure 容器注册表推送 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="970a8-453">Push the Docker image to Azure Container Registry.</span></span> <span data-ttu-id="970a8-454">该映像标记有版本号（取自分库名称）。</span><span class="sxs-lookup"><span data-stu-id="970a8-454">The image is tagged with the version number taken from the branch name.</span></span>
2. <span data-ttu-id="970a8-455">运行 `helm package`，将 Helm 图表打包</span><span class="sxs-lookup"><span data-stu-id="970a8-455">Run `helm package` to package the Helm chart</span></span>
3. <span data-ttu-id="970a8-456">通过运行 `az acr helm push` 将 Helm 包推送到容器注册表。</span><span class="sxs-lookup"><span data-stu-id="970a8-456">Push the Helm package to Container Registry by running `az acr helm push`.</span></span>

<span data-ttu-id="970a8-457">假定此生成成功，它会使用 Azure Pipelines [发布管道](/azure/devops/pipelines/release/what-is-release-management)触发部署过程。</span><span class="sxs-lookup"><span data-stu-id="970a8-457">Assuming this build succeeds, it triggers a deployment process using an Azure Pipelines [release pipeline](/azure/devops/pipelines/release/what-is-release-management).</span></span> <span data-ttu-id="970a8-458">此管道</span><span class="sxs-lookup"><span data-stu-id="970a8-458">This pipeline</span></span>

1. <span data-ttu-id="970a8-459">通过运行 `helm upgrade` 将 Helm 图表部署到 QA 环境。</span><span class="sxs-lookup"><span data-stu-id="970a8-459">Run `helm upgrade` to deploy the Helm chart to a QA environment.</span></span>
1. <span data-ttu-id="970a8-460">审批者签署同意书，然后包就会转到生产环境。</span><span class="sxs-lookup"><span data-stu-id="970a8-460">An approver signs off before the package moves to production.</span></span> <span data-ttu-id="970a8-461">请参阅[通过审批进行发布部署控制](/azure/devops/pipelines/release/approvals/approvals)。</span><span class="sxs-lookup"><span data-stu-id="970a8-461">See [Release deployment control using approvals](/azure/devops/pipelines/release/approvals/approvals).</span></span>
1. <span data-ttu-id="970a8-462">在 Azure 容器注册表中为生产命名空间重新标记 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="970a8-462">Re-tag the Docker image for the production namespace in Azure Container Registry.</span></span> <span data-ttu-id="970a8-463">例如，如果当前标记为 `myrepo.azurecr.io/delivery:v1.0.2`，则生产标记为 `reponame.azurecr.io/prod/delivery:v1.0.2`。</span><span class="sxs-lookup"><span data-stu-id="970a8-463">For example, if the current tag is `myrepo.azurecr.io/delivery:v1.0.2`, the production tag is `reponame.azurecr.io/prod/delivery:v1.0.2`.</span></span>
1. <span data-ttu-id="970a8-464">通过运行 `helm upgrade` 将 Helm 图表部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="970a8-464">Run `helm upgrade` to deploy the Helm chart to the production environment.</span></span>

![CI/CD 工作流](./_images/aks-cicd-3.png)

<span data-ttu-id="970a8-466">必须记住的是，即使在单存储库中，也可让这些任务的范围局限于单个微服务，这样团队就能快速进行部署。</span><span class="sxs-lookup"><span data-stu-id="970a8-466">It's important to remember that even in a monorepo, these tasks can be scoped to individual microservices, so that teams can deploy with high velocity.</span></span> <span data-ttu-id="970a8-467">此过程有一些手动步骤：审批 PR、创建发布分库，以及审批部署到生产群集中的内容。</span><span class="sxs-lookup"><span data-stu-id="970a8-467">There are some manual steps in the process: Approving PRs, creating release branches, and approving deployments into the production cluster.</span></span> <span data-ttu-id="970a8-468">根据策略，这些步骤是手动的 &mdash; 如果公司愿意，可以将其彻底变为自动。</span><span class="sxs-lookup"><span data-stu-id="970a8-468">These steps are manual by policy &mdash; they could be completely automated if the organization prefers.</span></span>
